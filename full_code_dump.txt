

// ==========================================
// FILE: src/lib/fonts.ts
// ==========================================

import { Inter, Cairo, Tajawal, Amiri } from 'next/font/google';

export const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
});

export const cairo = Cairo({
  subsets: ['arabic', 'latin'],
  variable: '--font-cairo',
  display: 'swap',
});

export const tajawal = Tajawal({
  subsets: ['arabic', 'latin'],
  weight: ['400', '500', '700'],
  variable: '--font-tajawal',
  display: 'swap',
});

export const amiri = Amiri({
  subsets: ['arabic', 'latin'],
  weight: ['400', '700'],
  variable: '--font-amiri',
  display: 'swap',
});

// ==========================================
// FILE: src/lib/upload.ts
// ==========================================

import { toast } from '@/hooks/use-toast';

interface UploadResult {
  fileId: string;
  fileName: string;
  fileUrl: string;
}

/**
 * Uploads a file to the backend /api/upload endpoint.
 * @param file The file to upload.
 * @param parentFolderId The Google Drive folder ID to upload to.
 * @returns A Promise that resolves to UploadResult on success, or rejects on failure.
 */
export async function uploadFileToDrive(file: File, parentFolderId: string): Promise<UploadResult> {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('parentFolderId', parentFolderId);

  try {
    const response = await fetch('/api/upload', {
      method: 'POST',
      body: formData,
    });

    const result = await response.json();

    if (!response.ok) {
      throw new Error(result.message || 'ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù');
    }

    return result.data as UploadResult;
  } catch (error: any) {
    console.error('File upload error:', error);
    toast({
      title: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø±ÙØ¹',
      description: error.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù',
      variant: 'destructive',
    });
    throw error;
  }
}


// ==========================================
// FILE: src/lib/route.ts
// ==========================================



// ==========================================
// FILE: src/lib/prisma.ts
// ==========================================

import { PrismaClient } from '@prisma/client';

const globalForPrisma = global as unknown as { 
  prisma: PrismaClient;
  prismaCleanupSet?: boolean;
};

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

// ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª Ø¹Ù†Ø¯ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
// Ø§Ø³ØªØ®Ø¯Ø§Ù… once Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† on Ù„ØªØ¬Ù†Ø¨ memory leak
if (typeof window === 'undefined') {
  if (!globalForPrisma.prismaCleanupSet) {
    process.once('beforeExit', async () => {
      await prisma.$disconnect();
    });
    globalForPrisma.prismaCleanupSet = true;
  }
}


// ==========================================
// FILE: src/lib/types.ts
// ==========================================


export type UserRole = 'directeur' | 'supervisor_general' | 'supervisor_specific' | 'teacher' | 'student' | 'parent';

export interface Stage {
  id: number;
  name: string;
  order: number;
}

export interface Level {
  id: number;
  name: string;
  stage_id: number;
  order: number;
}

export interface Subject {
  id: number;
  name: string;
  description: string;
  stageId?: number;
  levelId?: number;
  // Legacy support
  stage_id?: number;
  level_id?: number;
}

export interface User {
  id: number;
  nom: string;
  prenom: string;
  name: string;
  email: string;
  role: UserRole;
  stage_id?: number;
  level_id?: number;
  subject_id?: number;
  teacher_code?: string;
  student_code?: string;
  parent_code?: string;
  connected_teacher_code?: string;
  parent_id?: number;
  avatar: string;
  ai_evaluation_mode: 'manual' | 'auto';
}

export interface Lesson {
  id: number;
  title: string;
  content: string;
  video_url: string;
  pdf_url?: string;
  subject_id: number;
  level_id: number;
  author_id: number;
  type: 'public' | 'private';
  is_locked: boolean;
}

export interface Exercise {
  id: number;
  lesson_id: number;
  question: string;
  question_file_url?: string;
  model_answer: string;
  order: number;
}

export interface Submission {
  id: number;
  student_id: number;
  exercise_id: number;
  answer: string;
  submission_file_url?: string;
  attempt_number: number;
  ai_feedback?: string;
  score?: number;
  submitted_at: string;
  status?: 'pending' | 'graded';
}

export interface Message {
  id: number;
  subject: string;
  sender_name: string;
  author_id: number;
  content: string;
  recipient_id: number;
  is_read: boolean;
  created_at: string;
}


// ==========================================
// FILE: src/lib/mock-data.ts
// ==========================================

// This file is deprecated - all data should come from API
// Keeping minimal exports for backward compatibility only

export const USERS: any[] = [];
export const LESSONS: any[] = [];
export const SUBJECTS: any[] = [];
export const EXERCISES: any[] = [];
export const SUBMISSIONS: any[] = [];
export const STAGES: any[] = [];
export const LEVELS: any[] = [];
export const MESSAGES: any[] = [];

// Deprecated functions - use API instead
export const getUserById = (id: number) => null;
export const getLessonById = (id: number) => null;
export const getExerciseById = (id: number) => null;
export const getSubjectById = (id: number) => null;
export const getStudent = (id: number) => null;
export const getTeacher = (id: number) => null;
export const getParent = (id: number) => null;
export const getSubjectSupervisor = (id: number) => null;
export const getLessons = () => [];
export const getSubjects = () => [];
export const getExercisesForLesson = (lessonId: number) => [];
export const getSubmissionsForStudent = (studentId: number) => [];
export const getSubmissionsForTeacher = (teacherId: number) => [];
export const getSubmissionById = (id: number) => null;
export const getChildrenOfParent = (parentId: number) => [];
export const getSubmissionsForStudents = (studentIds: number[]) => [];


// ==========================================
// FILE: src/lib/logger.ts
// ==========================================

/**
 * Logging System for SmartEdu Platform
 * Comprehensive logging with different levels and categories
 */

import { prisma } from './prisma';

export enum LogLevel {
  INFO = 'INFO',
  WARNING = 'WARNING',
  ERROR = 'ERROR',
  SUCCESS = 'SUCCESS',
  DEBUG = 'DEBUG'
}

export enum LogCategory {
  AUTH = 'AUTH',
  USER = 'USER',
  LESSON = 'LESSON',
  EXERCISE = 'EXERCISE',
  SUBMISSION = 'SUBMISSION',
  MESSAGE = 'MESSAGE',
  NOTIFICATION = 'NOTIFICATION',
  BACKUP = 'BACKUP',
  SYSTEM = 'SYSTEM',
  AI = 'AI',
  DRIVE = 'DRIVE',
}

interface LogData {
  level: LogLevel;
  category: LogCategory;
  action: string;
  userId?: string;
  targetId?: string;
  details?: any;
  ipAddress?: string;
  userAgent?: string;
}

/**
 * Main logging function
 */
export async function log(data: LogData): Promise<void> {
  try {
    await prisma.log.create({
      data: {
        level: data.level,
        category: data.category,
        action: data.action,
        userId: data.userId,
        targetId: data.targetId,
        details: data.details ? JSON.stringify(data.details) : null,
        ipAddress: data.ipAddress,
        userAgent: data.userAgent,
        timestamp: new Date()
      }
    });

    // Console logging in development
    if (process.env.NODE_ENV === 'development') {
      const emoji = getLogEmoji(data.level);
      console.log(
        `${emoji} [${data.level}] [${data.category}] ${data.action}`,
        data.details || ''
      );
    }
  } catch (error) {
    // Fallback to console if database logging fails
    console.error('Failed to write log to database:', error);
    console.log('[FALLBACK LOG]', data);
  }
}

/**
 * Quick logging helpers
 */
export const logger = {
  // Authentication logs
  auth: {
    login: (userId: string, details?: any) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.AUTH, action: 'USER_LOGIN', userId, details }),
    logout: (userId: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.AUTH, action: 'USER_LOGOUT', userId }),
    loginFailed: (email: string, reason: string) =>
      log({ level: LogLevel.WARNING, category: LogCategory.AUTH, action: 'LOGIN_FAILED', details: { email, reason } }),
    signup: (userId: string, details?: any) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.AUTH, action: 'USER_SIGNUP', userId, details }),
  },

  // User management logs
  user: {
    created: (userId: string, createdBy: string, details?: any) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.USER, action: 'USER_CREATED', userId: createdBy, targetId: userId, details }),
    updated: (userId: string, updatedBy: string, changes?: any) =>
      log({ level: LogLevel.INFO, category: LogCategory.USER, action: 'USER_UPDATED', userId: updatedBy, targetId: userId, details: changes }),
    deleted: (userId: string, deletedBy: string) =>
      log({ level: LogLevel.WARNING, category: LogCategory.USER, action: 'USER_DELETED', userId: deletedBy, targetId: userId }),
    profileCompleted: (userId: string) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.USER, action: 'PROFILE_COMPLETED', userId }),
  },

  // Lesson logs
  lesson: {
    created: (lessonId: string, teacherId: string, details?: any) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.LESSON, action: 'LESSON_CREATED', userId: teacherId, targetId: lessonId, details }),
    updated: (lessonId: string, teacherId: string, changes?: any) =>
      log({ level: LogLevel.INFO, category: LogCategory.LESSON, action: 'LESSON_UPDATED', userId: teacherId, targetId: lessonId, details: changes }),
    deleted: (lessonId: string, teacherId: string) =>
      log({ level: LogLevel.WARNING, category: LogCategory.LESSON, action: 'LESSON_DELETED', userId: teacherId, targetId: lessonId }),
    viewed: (lessonId: string, userId: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.LESSON, action: 'LESSON_VIEWED', userId, targetId: lessonId }),
  },

  // Exercise logs
  exercise: {
    created: (exerciseId: string, teacherId: string, details?: any) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.EXERCISE, action: 'EXERCISE_CREATED', userId: teacherId, targetId: exerciseId, details }),
    updated: (exerciseId: string, teacherId: string, changes?: any) =>
      log({ level: LogLevel.INFO, category: LogCategory.EXERCISE, action: 'EXERCISE_UPDATED', userId: teacherId, targetId: exerciseId, details: changes }),
    deleted: (exerciseId: string, teacherId: string) =>
      log({ level: LogLevel.WARNING, category: LogCategory.EXERCISE, action: 'EXERCISE_DELETED', userId: teacherId, targetId: exerciseId }),
    attempted: (exerciseId: string, studentId: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.EXERCISE, action: 'EXERCISE_ATTEMPTED', userId: studentId, targetId: exerciseId }),
  },

  // Submission logs
  submission: {
    created: (submissionId: string, studentId: string, exerciseId: string) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.SUBMISSION, action: 'SUBMISSION_CREATED', userId: studentId, targetId: submissionId, details: { exerciseId } }),
    evaluated: (submissionId: string, score: number, byAI: boolean) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.SUBMISSION, action: 'SUBMISSION_EVALUATED', targetId: submissionId, details: { score, byAI } }),
    reviewed: (submissionId: string, teacherId: string, finalScore: number) =>
      log({ level: LogLevel.INFO, category: LogCategory.SUBMISSION, action: 'SUBMISSION_REVIEWED', userId: teacherId, targetId: submissionId, details: { finalScore } }),
  },

  // Message logs
  message: {
    sent: (messageId: string, senderId: string, recipientId: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.MESSAGE, action: 'MESSAGE_SENT', userId: senderId, targetId: messageId, details: { recipientId } }),
    read: (messageId: string, recipientId: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.MESSAGE, action: 'MESSAGE_READ', userId: recipientId, targetId: messageId }),
  },

  // Notification logs
  notification: {
    created: (notificationId: string, userId: string, type: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.NOTIFICATION, action: 'NOTIFICATION_CREATED', targetId: notificationId, details: { userId, type } }),
    read: (notificationId: string, userId: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.NOTIFICATION, action: 'NOTIFICATION_READ', userId, targetId: notificationId }),
  },

  // Backup logs
  backup: {
    started: (userId: string, type: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.BACKUP, action: 'BACKUP_STARTED', userId, details: { type } }),
    completed: (userId: string, filename: string, size: number) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.BACKUP, action: 'BACKUP_COMPLETED', userId, details: { filename, size } }),
    failed: (userId: string, error: any) =>
      log({ level: LogLevel.ERROR, category: LogCategory.BACKUP, action: 'BACKUP_FAILED', userId, details: { error: error.message } }),
    restored: (userId: string, filename: string) =>
      log({ level: LogLevel.WARNING, category: LogCategory.BACKUP, action: 'BACKUP_RESTORED', userId, details: { filename } }),
  },

  // AI logs
  ai: {
    evaluationStarted: (exerciseId: string, submissionId: string) =>
      log({ level: LogLevel.INFO, category: LogCategory.AI, action: 'AI_EVALUATION_STARTED', targetId: submissionId, details: { exerciseId } }),
    evaluationCompleted: (submissionId: string, score: number, duration: number) =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.AI, action: 'AI_EVALUATION_COMPLETED', targetId: submissionId, details: { score, duration } }),
    evaluationFailed: (submissionId: string, error: any) =>
      log({ level: LogLevel.ERROR, category: LogCategory.AI, action: 'AI_EVALUATION_FAILED', targetId: submissionId, details: { error: error.message } }),
  },

  // System logs
  system: {
    started: () =>
      log({ level: LogLevel.SUCCESS, category: LogCategory.SYSTEM, action: 'SYSTEM_STARTED' }),
    error: (error: any, context?: any) =>
      log({ level: LogLevel.ERROR, category: LogCategory.SYSTEM, action: 'SYSTEM_ERROR', details: { error: error.message, stack: error.stack, context } }),
    warning: (message: string, details?: any) =>
      log({ level: LogLevel.WARNING, category: LogCategory.SYSTEM, action: 'SYSTEM_WARNING', details: { message, ...details } }),
  }
};

/**
 * Get emoji for log level
 */
function getLogEmoji(level: LogLevel): string {
  switch (level) {
    case LogLevel.SUCCESS: return 'âœ…';
    case LogLevel.INFO: return 'â„¹ï¸';
    case LogLevel.WARNING: return 'âš ï¸';
    case LogLevel.ERROR: return 'âŒ';
    case LogLevel.DEBUG: return 'ğŸ”';
    default: return 'ğŸ“';
  }
}

/**
 * Get logs with filters
 */
export async function getLogs(filters: {
  level?: LogLevel;
  category?: LogCategory;
  userId?: string;
  startDate?: Date;
  endDate?: Date;
  limit?: number;
  offset?: number;
}) {
  const where: any = {};

  if (filters.level) where.level = filters.level;
  if (filters.category) where.category = filters.category;
  if (filters.userId) where.userId = filters.userId;
  if (filters.startDate || filters.endDate) {
    where.timestamp = {};
    if (filters.startDate) where.timestamp.gte = filters.startDate;
    if (filters.endDate) where.timestamp.lte = filters.endDate;
  }

  const [logs, total] = await Promise.all([
    prisma.log.findMany({
      where,
      orderBy: { timestamp: 'desc' },
      take: filters.limit || 50,
      skip: filters.offset || 0,
      include: {
        user: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            role: true
          }
        }
      }
    }),
    prisma.log.count({ where })
  ]);

  return { logs, total };
}

/**
 * Clean old logs (for maintenance)
 */
export async function cleanOldLogs(daysToKeep: number = 90): Promise<number> {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);

  const result = await prisma.log.deleteMany({
    where: {
      timestamp: {
        lt: cutoffDate
      }
    }
  });

  await logger.system.warning(`Cleaned ${result.count} old logs`, { daysToKeep, cutoffDate });

  return result.count;
}


// ==========================================
// FILE: src/lib/api-response.ts
// ==========================================

import { NextResponse } from 'next/server';

export function successResponse<T>(data: T, message?: string, status = 200) {
  return NextResponse.json(
    {
      success: true,
      message,
      data,
    },
    { status }
  );
}

export function errorResponse(error: string, status = 400, details?: any) {
  return NextResponse.json(
    {
      success: false,
      error,
      details,
    },
    { status }
  );
}

export function unauthorizedResponse(message = 'ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„') {
  return errorResponse(message, 401);
}

export function notFoundResponse(message = 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ±Ø¯') {
  return errorResponse(message, 404);
}

export function validationErrorResponse(errors: any) {
  return errorResponse('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 422, errors);
}


// ==========================================
// FILE: src/lib/google-drive.ts
// ==========================================

import { google } from 'googleapis';
import { Readable } from 'stream';

// Ù…ØªØºÙŠØ± Ù„ØªØ®Ø²ÙŠÙ† Ù†Ø³Ø®Ø© Ø§Ù„Ø¹Ù…ÙŠÙ„ (Singleton Pattern)
let driveClient: any = null;

// Ø°Ø§ÙƒØ±Ø© ØªØ®Ø²ÙŠÙ† Ù…Ø¤Ù‚Øª Ù„Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø± ÙˆÙ…Ø´Ø§ÙƒÙ„ Ø§Ù„ÙÙ‡Ø±Ø³Ø© (Caching)
// Ù†Ø³ØªØ®Ø¯Ù… Promise Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø¬Ø§Ø±ÙŠØ©ØŒ Ù…Ù…Ø§ ÙŠÙ…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± Ø¹Ù†Ø¯ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…ØªØ²Ø§Ù…Ù†Ø© (Race Conditions)
const folderCache = new Map<string, Promise<string>>();

/**
 * Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¹Ù†Ø¯ Ø­Ø¯ÙˆØ« Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©
 */
async function withRetry<T>(operation: () => Promise<T>, retries = 3, delay = 1000): Promise<T> {
  try {
    return await operation();
  } catch (error: any) {
    const isNetworkError = 
      error.code === 'EAI_AGAIN' || 
      error.code === 'ETIMEDOUT' || 
      error.code === 'ECONNRESET' ||
      error.message?.includes('EAI_AGAIN');

    if (retries > 0 && isNetworkError) {
      console.warn(`[GoogleDrive] âš ï¸ Network error (${error.code || 'EAI_AGAIN'}). Retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      return withRetry(operation, retries - 1, delay * 2);
    }
    throw error;
  }
}

/**
 * Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ù…ÙŠÙ„ Google Drive Ù…Ø¹ Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ³ÙˆÙ„Ø© (Lazy Loading)
 * ØªÙ…Ù†Ø¹ ØªÙˆÙ‚Ù Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¹Ù†Ø¯ Ø§Ù„Ø¨Ø¯Ø¡ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù…ÙÙ‚ÙˆØ¯Ø©
 */
function getDriveClient() {
  if (driveClient) return driveClient;

  const email = process.env.GOOGLE_CLIENT_EMAIL;
  const key = process.env.GOOGLE_PRIVATE_KEY;
  
  const clientId = process.env.GOOGLE_CLIENT_ID;
  const clientSecret = process.env.GOOGLE_CLIENT_SECRET;
  const refreshToken = process.env.GOOGLE_REFRESH_TOKEN;

  // 1. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¹Ø¨Ø± Service Account (Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©)
  if (email && key) {
    console.log('[GoogleDrive] ğŸ”‘ Using Service Account authentication.');
    const auth = new google.auth.GoogleAuth({
      credentials: {
        client_email: email,
        private_key: key.replace(/\\n/g, '\n'),
      },
      scopes: ['https://www.googleapis.com/auth/drive'],
    });
    driveClient = google.drive({ version: 'v3', auth });
    return driveClient;
  }

  // 2. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø¹Ø¨Ø± OAuth2 (Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ù„Ù .env Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ)
  if (clientId && clientSecret && refreshToken) {
    console.log('[GoogleDrive] ğŸ”‘ Using OAuth2 authentication.');
    const oauth2Client = new google.auth.OAuth2(
      clientId,
      clientSecret,
      "https://developers.google.com/oauthplayground" // Redirect URL Ù‚ÙŠØ§Ø³ÙŠ
    );

    oauth2Client.setCredentials({
      refresh_token: refreshToken
    });

    driveClient = google.drive({ version: 'v3', auth: oauth2Client });
    return driveClient;
  }

  // 3. ÙØ´Ù„ Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©
  throw new Error("Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø¹ØªÙ…Ø§Ø¯ Google Drive Ù…ÙÙ‚ÙˆØ¯Ø©. ÙŠØ±Ø¬Ù‰ ØªÙˆÙÙŠØ± Ø¥Ù…Ø§ Service Account (EMAIL/KEY) Ø£Ùˆ OAuth2 (CLIENT_ID/SECRET/REFRESH_TOKEN) ÙÙŠ Ù…Ù„Ù .env");

  return driveClient;
}

/**
 * Ø¯Ø§Ù„Ø© Ø°Ø±ÙŠØ© Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø¬Ù„Ø¯ Ø£Ùˆ Ø¥Ù†Ø´Ø§Ø¦Ù‡ Ø¯Ø§Ø®Ù„ Ù…Ø¬Ù„Ø¯ Ø£Ø¨ Ù…Ø­Ø¯Ø¯
 */
async function findOrCreateFolder(folderName: string, parentId: string | null): Promise<string> {
  const cleanFolderName = folderName.trim();
  // Ù…ÙØªØ§Ø­ Ø§Ù„ÙƒØ§Ø´: Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø¨ + Ø§Ø³Ù… Ø§Ù„Ù…Ø¬Ù„Ø¯
  const cacheKey = `${parentId || 'root'}|${cleanFolderName}`;

  if (folderCache.has(cacheKey)) {
    console.log(`[GoogleDrive] âš¡ Joining existing folder request for: "${cleanFolderName}"`);
    return folderCache.get(cacheKey)!;
  }

  // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù‡Ù…Ø© (Promise) Ù„Ù„Ø¨Ø­Ø« Ø£Ùˆ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡
  const folderPromise = (async () => {
    const sanitizedName = cleanFolderName.replace(/'/g, "\\'");
    const drive = getDriveClient();

    const query = [
      `mimeType='application/vnd.google-apps.folder'`,
      `name='${sanitizedName}'`,
      `trashed=false`,
      parentId ? `'${parentId}' in parents` : `'root' in parents`
    ].join(' and ');

    console.log(`[GoogleDrive] ğŸ” Searching for folder: "${cleanFolderName}" in parent: ${parentId || 'root'}`);

    try {
      const listRes = await withRetry(() => drive.files.list({
        q: query,
        fields: 'files(id, name, parents)',
        spaces: 'drive',
      }));

      const existingFolder = listRes.data.files?.[0];

      if (existingFolder?.id) {
        console.log(`[GoogleDrive] âœ… Found folder: "${cleanFolderName}" (ID: ${existingFolder.id})`);
        return existingFolder.id;
      }

      console.log(`[GoogleDrive] âš ï¸ Creating folder: "${cleanFolderName}" inside ${parentId || 'root'}`);
      const createRes = await withRetry(() => drive.files.create({
        requestBody: {
          name: cleanFolderName,
          mimeType: 'application/vnd.google-apps.folder',
          parents: parentId ? [parentId] : undefined,
        },
        fields: 'id, parents',
      }));

      if (!createRes.data.id) {
        throw new Error(`Failed to create folder: ${cleanFolderName}`);
      }
      console.log(`[GoogleDrive] âœ¨ Created folder ID: ${createRes.data.id}`);
      return createRes.data.id;
    } catch (error) {
      console.error(`[GoogleDrive] âŒ Error in findOrCreateFolder for "${cleanFolderName}":`, error);
      throw error;
    }
  })();

  folderCache.set(cacheKey, folderPromise);

  try {
    return await folderPromise;
  } catch (error) {
    // ÙÙŠ Ø­Ø§Ù„ Ø§Ù„ÙØ´Ù„ØŒ Ù†Ø­Ø°Ù Ø§Ù„Ù…ÙØªØ§Ø­ Ù…Ù† Ø§Ù„ÙƒØ§Ø´ Ù„Ù†Ø³Ù…Ø­ Ø¨Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
    folderCache.delete(cacheKey);
    throw error;
  }
}

/**
 * Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø­Ù„ Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª ÙˆØ¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø¹Ø±Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
 */
export async function resolveHierarchy(pathHierarchy: string[]): Promise<string> {
  let currentParentId: string | null = getRootFolderId();

  console.log(`[GoogleDrive] ğŸŒ³ Resolving hierarchy: ${JSON.stringify(pathHierarchy)} starting from parent: ${currentParentId || 'root'}`);

  for (const folderName of pathHierarchy) {
    if (!folderName || !folderName.trim()) continue;
    currentParentId = await findOrCreateFolder(folderName, currentParentId);
    console.log(`[GoogleDrive] ğŸ“ Resolved "${folderName}" -> ID: ${currentParentId}`);
  }

  if (!currentParentId) {
    throw new Error("Hierarchy resolution failed: Final folder ID is null.");
  }

  return currentParentId;
}

/**
 * Ø¯Ø§Ù„Ø© Ù„Ø±ÙØ¹ Ù…Ù„Ù Ù…Ø¨Ø§Ø´Ø±Ø© Ø¥Ù„Ù‰ Ù…Ø¬Ù„Ø¯ Ù…Ø­Ø¯Ø¯
 */
export async function uploadFile(
  fileBuffer: Buffer,
  fileName: string,
  mimeType: string,
  folderId: string
) {
  console.log(`[GoogleDrive] ğŸš€ Uploading file "${fileName}" to Folder ID: ${folderId}`);
  
  const drive = getDriveClient();

  const requestBody = {
    name: fileName,
    parents: [folderId],
  };
  console.log(`[GoogleDrive] ğŸ“¦ Request Body: ${JSON.stringify(requestBody)}`);

  // Ù†Ø³ØªØ®Ø¯Ù… withRetry ÙˆÙ†Ù‚ÙˆÙ… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù€ stream Ø¯Ø§Ø®Ù„Ù‡Ø§ Ù„Ø£Ù† Ø§Ù„Ù€ stream Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù‚Ø±Ø§Ø¡ØªÙ‡ Ø¥Ù„Ø§ Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©
  const response = await withRetry(() => {
    const stream = Readable.from(fileBuffer);
    return drive.files.create({
      requestBody: requestBody,
      media: {
        mimeType: mimeType,
        body: stream,
      },
      fields: 'id, webViewLink, webContentLink, parents',
    });
  });

  console.log(`[GoogleDrive] ğŸ‰ Upload successful. File ID: ${response.data.id}`);
  console.log(`[GoogleDrive] ğŸ“¨ Response Parents: ${JSON.stringify(response.data.parents)}`);

  // Ø®Ø·ÙˆØ© Ø§Ù„ØªØ­Ù‚Ù‚ ÙˆØ§Ù„ØªØµØ­ÙŠØ­
  const actualParents = response.data.parents || [];
  
  if (!actualParents.includes(folderId)) {
    console.warn(`[GoogleDrive] âš ï¸ File landed in wrong folder(s): [${actualParents.join(', ')}]. Moving to: ${folderId}...`);
    
    try {
      await withRetry(() => drive.files.update({
        fileId: response.data.id!,
        addParents: folderId,
        removeParents: actualParents.join(','),
        fields: 'id, parents',
      }));
      console.log(`[GoogleDrive] âœ… File moved successfully to correct folder.`);
    } catch (moveError) {
      console.error(`[GoogleDrive] âŒ Failed to move file:`, moveError);
    }
  }

  // ============================================================
  // Ø®Ø·ÙˆØ© Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª: Ø¬Ø¹Ù„ Ø§Ù„Ù…Ù„Ù Ø¹Ø§Ù…Ø§Ù‹ Ù„Ù„Ù‚Ø±Ø§Ø¡Ø© (Public Reader)
  // ============================================================
  try {
    await withRetry(() => drive.permissions.create({
      fileId: response.data.id!,
      requestBody: {
        role: 'reader',
        type: 'anyone',
      },
    }));
    console.log(`[GoogleDrive] ğŸ”“ File made public (anyone with link).`);
  } catch (permError) {
    console.warn(`[GoogleDrive] âš ï¸ Failed to make file public:`, permError);
  }

  let publicUrl = `https://drive.google.com/uc?export=view&id=${response.data.id}`;

  // ØªØ®ØµÙŠØµ Ø§Ù„Ø±Ø§Ø¨Ø· Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø¹Ø±Ø¶
  if (mimeType?.startsWith('image/')) {
    // Ù„Ù„ØµÙˆØ±: Ù†Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø§Ø± Ø§Ù„ÙˆÙƒÙŠÙ„ (Proxy) Ø§Ù„Ø®Ø§Øµ Ø¨Ù†Ø§ Ù„ØªØ¬Ø§ÙˆØ² Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ùˆ 403
    // Ù‡Ø°Ø§ Ø§Ù„Ø±Ø§Ø¨Ø· Ø³ÙŠØªÙ… ØªØ®Ø²ÙŠÙ†Ù‡ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆÙŠØ³ØªØ®Ø¯Ù…Ù‡ Ø§Ù„ÙØ±ÙˆÙ†Øª Ø¥Ù†Ø¯
    publicUrl = `/api/images/proxy?fileId=${response.data.id}`;
  } else if (mimeType === 'application/pdf') {
    // Ù„Ù…Ù„ÙØ§Øª PDF: Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠ (uc?export=view) Ù„Ø¶Ù…Ø§Ù† Ø­ÙØ¸Ù‡ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    // Ø³ÙŠØªÙ… ØªØ­ÙˆÙŠÙ„Ù‡ Ø¥Ù„Ù‰ Ø±Ø§Ø¨Ø· Ù…Ø¹Ø§ÙŠÙ†Ø© (preview) ÙÙŠ ØµÙØ­Ø© Ø§Ù„Ø¹Ø±Ø¶
    publicUrl = `https://drive.google.com/uc?export=view&id=${response.data.id}`;
  }

  console.log(`[GoogleDrive] ğŸ”— Generated Public URL: ${publicUrl}`);

  return {
    fileId: response.data.id!,
    webViewLink: publicUrl,
    webContentLink: response.data.webContentLink,
  };
}

/**
 * Ø¯Ø§Ù„Ø© Ù„Ø¬Ù„Ø¨ ØªØ¯ÙÙ‚ Ø§Ù„Ù…Ù„Ù (Stream) Ù…Ù† Google Drive
 * ØªØ³ØªØ®Ø¯Ù… ÙÙŠ API Proxy Ù„ØªØ¬Ø§ÙˆØ² Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„ÙƒÙˆÙƒÙŠØ² Ùˆ 403 Forbidden
 */
export async function getFileStream(fileId: string) {
  const drive = getDriveClient();
  try {
    const response = await withRetry(() => drive.files.get(
      { fileId, alt: 'media' },
      { responseType: 'stream' }
    ));

    return {
      stream: response.data, // Node.js Readable Stream
      contentType: response.headers['content-type'] || 'application/octet-stream',
      contentLength: response.headers['content-length'],
    };
  } catch (error) {
    console.error(`[GoogleDrive] âŒ Failed to get file stream for ${fileId}:`, error);
    throw error;
  }
}

/**
 * Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
 */
export async function uploadFileToHierarchy(
  fileBuffer: Buffer,
  fileName: string,
  mimeType: string,
  pathHierarchy: string[]
) {
  try {
    const currentParentId = await resolveHierarchy(pathHierarchy);
    return await uploadFile(fileBuffer, fileName, mimeType, currentParentId);
  } catch (error) {
    console.error("[GoogleDrive] Upload failed:", error);
    throw error;
  }
}

/**
 * Ø¯Ø§Ù„Ø© Ù„Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø¬Ø°Ø±ÙŠ (Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©)
 */
export function getRootFolderId() {
  return process.env.GOOGLE_DRIVE_ROOT_FOLDER_ID || null;
}

// ========================================================
// Ø·Ø¨Ù‚Ø© Ø§Ù„ØªÙˆØ§ÙÙ‚ (Compatibility Layer)
// Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙÙŠ api/lessons/route.ts Ùˆ api/users/[id]/route.ts
// ========================================================

export const GoogleDriveService = {
  // Ø¯Ø§Ù„Ø© Ø§Ù„Ø¨Ø­Ø« Ø£Ùˆ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ (Ù†ÙØ³ Ø§Ù„Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¬Ø¯ÙŠØ¯)
  getOrCreateFolder: findOrCreateFolder,
  
  // Ø¯Ø§Ù„Ø© Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (ØªØ³ØªØ®Ø¯Ù… Ù†ÙØ³ Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¨Ø­Ø« Ø£Ùˆ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… Ø§Ù„ØªÙƒØ±Ø§Ø±)
  createFolder: findOrCreateFolder,

  // Ø¯Ø§Ù„Ø© Ø§Ù„Ø±ÙØ¹ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (ÙƒØ§Ù†Øª ØªØ³ØªÙ‚Ø¨Ù„ Ø§Ù„Ø§Ø³Ù… Ø£ÙˆÙ„Ø§Ù‹)
  // Ù†Ù‚ÙˆÙ… Ø¨Ù‚Ù„Ø¨ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ù„ØªØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
  uploadFile: async (fileName: string, fileBuffer: Buffer, mimeType: string, folderId: string) => {
    return uploadFile(fileBuffer, fileName, mimeType, folderId);
  },

  // Ø¯Ø§Ù„Ø© Ø¬Ø¹Ù„ Ø§Ù„Ù…Ù„Ù Ø¹Ø§Ù…Ø§Ù‹ (ÙŠÙ…ÙƒÙ† ØªØ±ÙƒÙ‡Ø§ ÙØ§Ø±ØºØ© Ø£Ùˆ ØªÙ†ÙÙŠØ°Ù‡Ø§ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±)
  makeFilePublic: async (fileId: string) => {
    try {
      const drive = getDriveClient();
      await drive.permissions.create({
        fileId,
        requestBody: { role: 'reader', type: 'anyone' },
      });
    } catch (e) {
      console.warn(`[GoogleDrive] Failed to make file public: ${fileId}`, e);
    }
  }
};

// ==========================================
// FILE: src/lib/actions.ts
// ==========================================

"use server";

import { z } from "zod";
import { getAiFeedback } from "@/ai/flows/ai-submission-feedback";

export type SubmissionState = {
  feedback?: string;
  score?: number;
  suggestedPrompts?: string[];
  error?: string;
};

const submissionSchema = z.object({
  answer: z.string(),
  exerciseId: z.string(),
  submissionFile: z.instanceof(File).optional(),
});

export async function handleSubmission(
  prevState: SubmissionState,
  formData: FormData
): Promise<SubmissionState> {
  try {
    const parsed = submissionSchema.safeParse({
      answer: formData.get("answer"),
      exerciseId: formData.get("exerciseId"),
      submissionFile: formData.get("submissionFile"),
    });

    if (!parsed.success) {
      return { error: "Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©." };
    }

    const { answer, exerciseId, submissionFile } = parsed.data;

    if (!answer && (!submissionFile || submissionFile.size === 0)) {
        return { error: "ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© Ø¥Ø¬Ø§Ø¨Ø© Ø£Ùˆ Ø¥Ø±ÙØ§Ù‚ Ù…Ù„Ù." };
    }

    // Fetch exercise from API
    const exerciseRes = await fetch(`${process.env.NEXTAUTH_URL || 'http://localhost:9002'}/api/exercises/${exerciseId}`);
    if (!exerciseRes.ok) {
      return { error: "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…Ø±ÙŠÙ†." };
    }
    const exercise = await exerciseRes.json();

    // TODO: Get student from session instead of mock
    const student = { id: 1, level_id: 1, ai_evaluation_mode: 'auto' };

    let fileDataUri: string | undefined = undefined;
    if (submissionFile && submissionFile.size > 0) {
        const fileBuffer = Buffer.from(await submissionFile.arrayBuffer());
        fileDataUri = `data:${submissionFile.type};base64,${fileBuffer.toString("base64")}`;
    }

    const feedbackResponse = await getAiFeedback({
      studentId: student.id,
      exerciseId: exercise.id,
      answer: answer,
      modelAnswer: exercise.model_answer,
      studentProfile: `Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${student.level_id}, Ù†Ù…Ø· Ø§Ù„ØªÙ‚ÙŠÙŠÙ…: ${student.ai_evaluation_mode}`,
      submissionFile: fileDataUri
    });

    if (!feedbackResponse) {
      return { error: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ." };
    }

    return {
      feedback: feedbackResponse.feedback,
      score: feedbackResponse.score,
      suggestedPrompts: feedbackResponse.suggestedPrompts,
    };
  } catch (e) {
    console.error(e);
    return { error: "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰." };
  }
}


// ==========================================
// FILE: src/lib/utils.ts
// ==========================================

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


// ==========================================
// FILE: src/lib/auth.ts
// ==========================================

import { NextAuthOptions } from 'next-auth';
import { PrismaAdapter } from '@next-auth/prisma-adapter';
import CredentialsProvider from 'next-auth/providers/credentials';
import GoogleProvider from 'next-auth/providers/google';
import { prisma } from '@/lib/prisma';
import bcrypt from 'bcryptjs';

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ', type: 'email' },
        password: { label: 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          throw new Error('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ø·Ù„ÙˆØ¨Ø§Ù†');
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
          include: {
            role: true,
            userDetails: {
              include: {
                stage: true,
                level: {
                  include: {
                    stage: true,
                  },
                },
                subject: true,
              },
            },
          },
        });

        if (!user || !user.password) {
          throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
        }

        const isPasswordValid = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isPasswordValid) {
          throw new Error('Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ØºÙŠØ± ØµØ­ÙŠØ­Ø©');
        }

        // Get stage_id from level if available, otherwise from userDetails
        const stageId = user.userDetails?.level?.stageId || user.userDetails?.stageId;

        return {
          id: user.id,
          email: user.email,
          name: `${user.firstName} ${user.lastName}`,
          image: user.image,
          role: user.role.name,
          roleId: user.roleId,
          stage_id: stageId,
        };
      },
    }),

    // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ø¨Ø± Google
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID || '',
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
      authorization: {
        params: {
          prompt: 'consent',
          access_type: 'offline',
          response_type: 'code',
        },
      },
    }),
  ],

  callbacks: {
    async jwt({ token, user, account, profile }) {
      // Ø¹Ù†Ø¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ø£ÙˆÙ„ Ù…Ø±Ø©
      if (user) {
        token.id = user.id;
        token.role = user.role;
        token.roleId = user.roleId;
        token.stage_id = user.stage_id;
      }

      // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¹Ø¨Ø± Google ÙˆÙ„Ø£ÙˆÙ„ Ù…Ø±Ø©
      if (account?.provider === 'google' && profile) {
        const existingUser = await prisma.user.findUnique({
          where: { id: token.sub },
          include: { 
            role: true, 
            userDetails: {
              include: {
                level: {
                  include: {
                    stage: true,
                  },
                },
              },
            },
          },
        });

        if (existingUser) {
          token.role = existingUser.role.name;
          token.roleId = existingUser.roleId;
          token.stage_id = existingUser.userDetails?.level?.stageId || existingUser.userDetails?.stageId;
          
          // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ…Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ù„ÙÙ‡ Ø§Ù„Ø´Ø®ØµÙŠØŒ Ù†ÙˆØ¬Ù‡Ù‡ Ù„ØµÙØ­Ø© Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„
          if (!existingUser.userDetails) {
            token.needsProfileCompletion = true;
          }
        }
      }

      return token;
    },

    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
        session.user.role = token.role as string;
        session.user.roleId = token.roleId as number;
        session.user.stage_id = token.stage_id as number | undefined;
        session.user.needsProfileCompletion = token.needsProfileCompletion as boolean;
      }
      return session;
    },

    async signIn({ user, account, profile }) {
      // Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ø¨Ø± Credentials Ø¯Ø§Ø¦Ù…Ø§Ù‹
      if (account?.provider === 'credentials') {
        return true;
      }

      // Ù„Ù„ØªØ³Ø¬ÙŠÙ„ Ø¹Ø¨Ø± Google
      if (account?.provider === 'google' && profile?.email) {
        const existingUser = await prisma.user.findUnique({
          where: { email: profile.email },
          include: { userDetails: true },
        });

        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ØŒ Ù†Ø³Ù…Ø­ Ø¨Ø§Ù„Ø¯Ø®ÙˆÙ„
        if (existingUser) {
          return true;
        }

        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯ Ø¹Ø¨Ø± GoogleØŒ Ù†Ù†Ø´Ø¦ Ø­Ø³Ø§Ø¨ Ø£Ø³Ø§Ø³ÙŠ
        // Ø³ÙŠÙƒÙˆÙ† Ø¹Ù„ÙŠÙ‡ Ø¥ÙƒÙ…Ø§Ù„ Ù…Ù„ÙÙ‡ Ø§Ù„Ø´Ø®ØµÙŠ Ù„Ø§Ø­Ù‚Ø§Ù‹
        try {
          // Ù†Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø¯ÙˆØ± Ø§Ù„Ø·Ø§Ù„Ø¨ ÙƒØ§ÙØªØ±Ø§Ø¶ÙŠ (ÙŠÙ…ÙƒÙ† ØªØºÙŠÙŠØ±Ù‡)
          const studentRole = await prisma.role.findFirst({
            where: { name: 'student' },
          });

          if (!studentRole) {
            throw new Error('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¯ÙˆØ± Ø§Ù„Ø·Ø§Ù„Ø¨');
          }

          // Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨ÙˆØ§Ø³Ø·Ø© PrismaAdapter
          // Ù„ÙƒÙ† Ù†Ø­ØªØ§Ø¬ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ firstName Ùˆ lastName
          return true;
        } catch (error) {
          console.error('Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:', error);
          return false;
        }
      }

      return true;
    },
  },

  pages: {
    signIn: '/login',
    error: '/login',
    newUser: '/complete-profile', // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ø¬Ø¯Ø¯ Ø¹Ø¨Ø± Google
  },

  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 ÙŠÙˆÙ…
  },

  secret: process.env.NEXTAUTH_SECRET,
};


// ==========================================
// FILE: src/lib/file-handler.ts
// ==========================================

import fs from 'fs';
import path from 'path';

/**
 * Saves a Base64 encoded string as a file in the public directory.
 * @param base64String The Base64 encoded string of the file.
 * @param fileType The type of file, e.g., 'lessons', 'profiles'. Used for sub-directory.
 * @param fileExtension The extension of the file, e.g., '.pdf', '.png'.
 * @returns The public URL of the saved file.
 */
export const saveBase64ToFile = (base64String: string, fileType: string, fileExtension: string): string => {
  // 1. Sanitize inputs
  if (!base64String || typeof base64String !== 'string') {
    throw new Error('Invalid Base64 string provided.');
  }
  const sanitizedFileType = path.normalize(fileType).replace(/\\/g, '/').replace(/\.\	sÃ³/g, '');
  const sanitizedFileExtension = path.normalize(fileExtension).replace(/\\/g, '/').replace(/\.\	sÃ³/g, '');
  
  // 2. Extract the actual Base64 content (remove data:image/png;base64,)
  const base64Data = base64String.split(';base64,').pop();
  if (!base64Data) {
    throw new Error('Invalid Base64 format.');
  }

  // 3. Create buffer
  const fileBuffer = Buffer.from(base64Data, 'base64');

  // 4. Generate unique filename
  const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1E9)}`;
  const filename = `${uniqueSuffix}${sanitizedFileExtension}`;

  // 5. Define directory path and ensure it exists
  const uploadDir = path.join(process.cwd(), 'public', 'uploads', sanitizedFileType);
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
  }

  // 6. Define file path and write file
  const filePath = path.join(uploadDir, filename);
  fs.writeFileSync(filePath, fileBuffer);

  // 7. Return the public URL
  const publicUrl = `/uploads/${sanitizedFileType}/${filename}`;
  return publicUrl;
};


// ==========================================
// FILE: src/lib/placeholder-images.ts
// ==========================================

import data from './placeholder-images.json';

export type ImagePlaceholder = {
  id: string;
  description: string;
  imageUrl: string;
  imageHint: string;
};

export const PlaceHolderImages: ImagePlaceholder[] = data.placeholderImages;


// ==========================================
// FILE: src/lib/api-auth.ts
// ==========================================

import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function getSession() {
  return await getServerSession(authOptions);
}

export async function requireAuth() {
  const session = await getSession();
  if (!session || !session.user) {
    throw new Error('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹');
  }
  return session;
}

export async function requireRole(allowedRoles: string[]) {
  const session = await requireAuth();
  if (!allowedRoles.includes(session.user.role)) {
    throw new Error('Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ù„ÙˆØµÙˆÙ„');
  }
  return session;
}


// ==========================================
// FILE: src/middleware.ts
// ==========================================

import { withAuth } from 'next-auth/middleware';
import { NextResponse } from 'next/server';

export default withAuth(
  function middleware(req) {
    const token = req.nextauth.token;
    const path = req.nextUrl.pathname;

    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ­ØªØ§Ø¬ Ù„Ø¥ÙƒÙ…Ø§Ù„ Ù…Ù„ÙÙ‡ Ø§Ù„Ø´Ø®ØµÙŠ
    if (token?.needsProfileCompletion && path !== '/complete-profile') {
      return NextResponse.redirect(new URL('/complete-profile', req.url));
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø¯ÙˆØ±
    const role = token?.role;

    // Ø­Ù…Ø§ÙŠØ© ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø¯ÙŠØ±
    if (path.startsWith('/dashboard/directeur') && role !== 'directeur') {
      return NextResponse.redirect(new URL('/dashboard', req.url));
    }

    // Ø­Ù…Ø§ÙŠØ© ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø´Ø±Ù
    if (
      path.startsWith('/dashboard/subject-supervisor') &&
      role !== 'supervisor_specific' &&
      role !== 'supervisor_general'
    ) {
      return NextResponse.redirect(new URL('/dashboard', req.url));
    }

    // Ø­Ù…Ø§ÙŠØ© ØµÙØ­Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù…
    if (path.startsWith('/dashboard/teacher') && role !== 'teacher') {
      return NextResponse.redirect(new URL('/dashboard', req.url));
    }

    // Ø­Ù…Ø§ÙŠØ© ØµÙØ­Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨
    if (path.startsWith('/dashboard/student') && role !== 'student') {
      return NextResponse.redirect(new URL('/dashboard', req.url));
    }

    // Ø­Ù…Ø§ÙŠØ© ØµÙØ­Ø§Øª ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±
    if (path.startsWith('/dashboard/parent') && role !== 'parent') {
      return NextResponse.redirect(new URL('/dashboard', req.url));
    }

    return NextResponse.next();
  },
  {
    callbacks: {
      authorized: ({ token }) => !!token,
    },
    pages: {
      signIn: '/login',
    },
  }
);

// ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø­Ù…ÙŠØ©
export const config = {
  matcher: [
    '/dashboard/:path*',
    '/lessons/:path*',
    '/messages/:path*',
    '/profile/:path*',
    '/subjects/:path*',
  ],
};

// ==========================================
// FILE: src/ai/dev.ts
// ==========================================

import { config } from 'dotenv';
config();

import '@/ai/flows/ai-submission-feedback.ts';
import '@/ai/flows/probabilistic-feedback-prompt-selection.ts';

// ==========================================
// FILE: src/ai/genkit.ts
// ==========================================

import {genkit} from 'genkit';
import {googleAI} from '@genkit-ai/google-genai';

export const ai = genkit({
  plugins: [googleAI()],
  model: 'googleai/gemini-2.5-flash',
});


// ==========================================
// FILE: src/ai/flows/ai-submission-feedback.ts
// ==========================================

'use server';

/**
 * @fileOverview An AI agent providing feedback on student exercise submissions.
 *
 * - getAiFeedback - A function that handles the AI feedback process.
 * - AiFeedbackInput - The input type for the getAiFeedback function.
 * - AiFeedbackOutput - The return type for the getAiFeedback function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const AiFeedbackInputSchema = z.object({
  studentId: z.number().describe('The ID of the student submitting the answer.'),
  exerciseId: z.number().describe('The ID of the exercise being answered.'),
  answer: z.string().describe('The studentâ€™s answer to the exercise.'),
  modelAnswer: z.string().describe('The model answer to the exercise.'),
  studentProfile: z.string().describe('The student profile including learning history and preferences.'),
  submissionFile: z.string().optional().describe(
    "An optional file (image or PDF) submitted by the student, as a data URI. Expected format: 'data:<mimetype>;base64,<encoded_data>'."
  ),
});
export type AiFeedbackInput = z.infer<typeof AiFeedbackInputSchema>;

const AiFeedbackOutputSchema = z.object({
  feedback: z.string().describe('The AI-generated feedback on the studentâ€™s answer.'),
  score: z.number().describe('The score assigned to the studentâ€™s answer, from 0 to 10. A score of 10 represents a perfect answer.'),
  suggestedPrompts: z.array(z.string()).describe('List of suggested prompts.'),
});
export type AiFeedbackOutput = z.infer<typeof AiFeedbackOutputSchema>;

export async function getAiFeedback(input: AiFeedbackInput): Promise<AiFeedbackOutput> {
  return aiFeedbackFlow(input);
}

const prompt = ai.definePrompt({
  name: 'aiFeedbackPrompt',
  input: {schema: AiFeedbackInputSchema},
  output: {schema: AiFeedbackOutputSchema},
  prompt: `Ø£Ù†Øª Ù…Ø³Ø§Ø¹Ø¯ ØªØ¹Ù„ÙŠÙ…ÙŠ ÙŠØ¹Ù…Ù„ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠØŒ ÙˆÙ…Ù‡Ù…ØªÙƒ ØªÙ‚Ø¯ÙŠÙ… Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…ÙˆØ¬Ø²Ø© Ù„Ù„Ø·Ù„Ø§Ø¨ Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.

Ù…Ù‡Ù…ØªÙƒ Ù‡ÙŠ ØªÙ‚ÙŠÙŠÙ… Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨. Ù‚Ø¯ ØªØ­ØªÙˆÙŠ Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ù…ÙƒØªÙˆØ¨Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© ÙÙ‚Ø·ØŒ Ø¨ÙŠÙ†Ù…Ø§ ÙŠØ­ØªÙˆÙŠ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø±ÙÙ‚ (ØµÙˆØ±Ø© Ø£Ùˆ PDF) Ø¹Ù„Ù‰ Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø­Ù„ Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©.

- ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø±ÙÙ‚ Ù„ÙÙ‡Ù… Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ ÙˆØ®Ø·ÙˆØ§ØªÙ‡. Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù„Ù„ØªÙ‚ÙŠÙŠÙ….
- Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù…ÙƒØªÙˆØ¨Ø© Ù‡ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¬Ø­ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©. Ù‚Ø§Ø±Ù†Ù‡Ø§ Ø¨Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©.
- Ù‚Ø¯Ù‘Ù… Ø¯Ø±Ø¬Ø© Ù…Ù† 0 Ø¥Ù„Ù‰ 10 Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ØµØ­Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© ÙˆØ§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù…ÙˆØ¶Ø­Ø© ÙÙŠ Ø§Ù„Ù…Ù„Ù. Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù…Ø«Ø§Ù„ÙŠØ© ÙŠØ¬Ø¨ Ø£Ù† ØªØ­ØµÙ„ Ø¹Ù„Ù‰ 10 Ø¯Ø±Ø¬Ø§Øª.
- ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ Ù‚ØµÙŠØ±Ø© ÙˆÙ…ÙˆØ¬Ø²Ø© ÙˆØ¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©.
- Ù‚Ø¯Ù‘Ù… Ù‚Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„ØªÙˆØ¬ÙŠÙ‡Ø§Øª Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø© Ø¨Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø·Ø§Ù„Ø¨.

Ù…Ù„Ù Ø§Ù„Ø·Ø§Ù„Ø¨: {{{studentProfile}}}
Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©: {{{modelAnswer}}}
Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ù…ÙƒØªÙˆØ¨Ø© (Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©): {{{answer}}}
{{#if submissionFile}}
Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø±ÙÙ‚ Ù…Ù† Ø§Ù„Ø·Ø§Ù„Ø¨ (Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø­Ù„): {{media url=submissionFile}}
{{/if}}

Ø¥Ù„ÙŠÙƒ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…:
  `,
});

const aiFeedbackFlow = ai.defineFlow(
  {
    name: 'aiFeedbackFlow',
    inputSchema: AiFeedbackInputSchema,
    outputSchema: AiFeedbackOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);
    return output!;
  }
);


// ==========================================
// FILE: src/ai/flows/probabilistic-feedback-prompt-selection.ts
// ==========================================

'use server';
/**
 * @fileOverview This file implements a Genkit flow for selecting the most relevant feedback prompts for student submissions using a probabilistic model.
 *
 * - probabilisticFeedbackPromptSelection - A function that handles the selection of feedback prompts.
 * - ProbabilisticFeedbackPromptSelectionInput - The input type for the probabilisticFeedbackPromptSelection function.
 * - ProbabilisticFeedbackPromptSelectionOutput - The return type for the probabilisticFeedbackPromptSelection function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const StudentProfileSchema = z.object({
  stage: z.string().describe('The educational stage of the student (e.g., primary, secondary).'),
  level: z.string().describe('The grade level of the student (e.g., 1st grade, 2nd grade).'),
  ai_evaluation_mode: z.enum(['manual', 'auto']).describe('The AI evaluation mode set by the student.'),
});

const SubmissionContentSchema = z.object({
  answer: z.string().describe('The student\'s answer to the exercise question.'),
  question: z.string().describe('The exercise question.'),
  model_answer: z.string().describe('The model answer to the exercise.'),
});

const ProbabilisticFeedbackPromptSelectionInputSchema = z.object({
  studentProfile: StudentProfileSchema.describe('The profile of the student.'),
  submissionContent: SubmissionContentSchema.describe('The content of the student submission.'),
  availablePrompts: z.array(z.string()).describe('The list of available feedback prompts.'),
});

export type ProbabilisticFeedbackPromptSelectionInput = z.infer<typeof ProbabilisticFeedbackPromptSelectionInputSchema>;

const ProbabilisticFeedbackPromptSelectionOutputSchema = z.object({
  selectedPrompt: z.string().describe('The most relevant feedback prompt selected by the AI.'),
});

export type ProbabilisticFeedbackPromptSelectionOutput = z.infer<typeof ProbabilisticFeedbackPromptSelectionOutputSchema>;


export async function probabilisticFeedbackPromptSelection(input: ProbabilisticFeedbackPromptSelectionInput): Promise<ProbabilisticFeedbackPromptSelectionOutput> {
  return probabilisticFeedbackPromptSelectionFlow(input);
}

const probabilisticFeedbackPromptSelectionPrompt = ai.definePrompt({
  name: 'probabilisticFeedbackPromptSelectionPrompt',
  input: {
    schema: ProbabilisticFeedbackPromptSelectionInputSchema,
  },
  output: {
    schema: ProbabilisticFeedbackPromptSelectionOutputSchema,
  },
  prompt: `You are an AI assistant designed to select the most relevant feedback prompt for a student submission.

  Given the following student profile:
  {{studentProfile}}

  And the following submission content:
  {{submissionContent}}

  From the following available prompts:
  {{#each availablePrompts}}
  - {{{this}}}
  {{/each}}

  Select the single most relevant feedback prompt.  Just respond with the text of the single most relevant prompt.
  `,
});

const probabilisticFeedbackPromptSelectionFlow = ai.defineFlow(
  {
    name: 'probabilisticFeedbackPromptSelectionFlow',
    inputSchema: ProbabilisticFeedbackPromptSelectionInputSchema,
    outputSchema: ProbabilisticFeedbackPromptSelectionOutputSchema,
  },
  async input => {
    const {output} = await probabilisticFeedbackPromptSelectionPrompt(input);
    return {
      selectedPrompt: output!.selectedPrompt,
    };
  }
);


// ==========================================
// FILE: src/types/next-auth.d.ts
// ==========================================

import 'next-auth';

declare module 'next-auth' {
  interface Session {
    user: {
      id: string;
      email: string;
      name?: string | null;
      image?: string | null;
      role: string;
      roleId: number;
      stage_id?: number;
      needsProfileCompletion?: boolean;
    };
  }

  interface User {
    id: string;
    email: string;
    name?: string | null;
    image?: string | null;
    role?: string;
    roleId?: number;
    stage_id?: number;
  }
}

declare module 'next-auth/jwt' {
  interface JWT {
    id: string;
    role: string;
    roleId: number;
    stage_id?: number;
    needsProfileCompletion?: boolean;
  }
}


// ==========================================
// FILE: src/hooks/index.ts
// ==========================================

// Main hooks exports
export { useLessons } from './use-lessons';
export { useExercises } from './use-exercises';
export { useSubmissions } from './use-submissions';
export { useMessages } from './use-messages';
export { useUsers } from './use-users';

// Content management hooks
export { useStages } from './use-stages';
export { useLevels } from './use-levels-content';
export { useSubjects } from './use-subjects';

// Re-export existing hooks
export { useToast } from './use-toast';
export { useIsMobile } from './use-mobile';


// ==========================================
// FILE: src/hooks/use-users.ts
// ==========================================

import { useState, useEffect, useCallback } from 'react';
import { useSession } from 'next-auth/react';

interface User {
  id: number;
  email: string;
  name: string;
  image: string | null;
  role: string;
  profileComplete: boolean;
  isBanned?: boolean;
  lessonsCount?: number;
  exercisesCount?: number;
  createdAt: string;
  updatedAt: string;
  details?: {
    phone: string | null;
    address: string | null;
    bio: string | null;
    stageId: number | null;
    subjectId: number | null;
    levelId: number | null;
    parentCode: string | null;
    teacherCode: string | null;
    subject?: {
      id: number;
      name: string;
    };
    level?: {
      id: number;
      name: string;
      stage: {
        id: number;
        name: string;
      };
    };
  };
}

interface UseUsersParams {
  role?: string;
  search?: string;
  page?: number;
  limit?: number;
}

interface UseUsersReturn {
  users: User[];
  total: number;
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
  createUser: (data: CreateUserData) => Promise<{ success: boolean; data?: User; error?: string }>;
  updateUser: (id: number, data: UpdateUserData) => Promise<{ success: boolean; data?: User; error?: string }>;
  deleteUser: (id: number) => Promise<{ success: boolean; error?: string }>;
}

interface CreateUserData {
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  roleName: string;
  stageId?: number;
  subjectId?: number;
  levelId?: number;
}

interface UpdateUserData {
  firstName?: string;
  lastName?: string;
  role?: string;
  password?: string;
  phone?: string;
  address?: string;
  bio?: string;
  subjectId?: number;
  levelId?: number;
  isBanned?: boolean;
}

export function useUsers(params?: UseUsersParams): UseUsersReturn {
  const { data: session } = useSession();
  const [users, setUsers] = useState<User[]>([]);
  const [total, setTotal] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchUsers = useCallback(async () => {
    if (!session) {
      setIsLoading(false);
      return;
    }
    
    setIsLoading(true);
    setError(null);

    try {
      const queryParams = new URLSearchParams();
      if (params?.role) queryParams.append('role', params.role);
      if (params?.search) queryParams.append('search', params.search);
      if (params?.page) queryParams.append('page', params.page.toString());
      if (params?.limit) queryParams.append('limit', params.limit.toString());

      const response = await fetch(`/api/users?${queryParams.toString()}`);
      const result = await response.json();

      if (result.success) {
        setUsers(result.data);
        setTotal(result.total || result.data.length);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†');
      console.error('Error fetching users:', err);
    } finally {
      setIsLoading(false);
    }
  }, [session, params?.role, params?.search, params?.page, params?.limit]);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  const createUser = async (data: CreateUserData) => {
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        await fetchUsers();
        return { success: true, data: result.data };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' };
      }
    } catch (err) {
      console.error('Error creating user:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' };
    }
  };

  const updateUser = async (id: number, data: UpdateUserData) => {
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        await fetchUsers();
        return { success: true, data: result.data };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' };
      }
    } catch (err) {
      console.error('Error updating user:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' };
    }
  };

  const deleteUser = async (id: number) => {
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'DELETE',
      });

      const result = await response.json();

      if (result.success) {
        await fetchUsers();
        return { success: true };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' };
      }
    } catch (err) {
      console.error('Error deleting user:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…' };
    }
  };

  return {
    users,
    total,
    isLoading,
    error,
    refetch: fetchUsers,
    createUser,
    updateUser,
    deleteUser,
  };
}


// ==========================================
// FILE: src/hooks/use-levels-content.ts
// ==========================================

'use client';

import { useState, useEffect, useCallback } from 'react';

export interface Level {
  id: number;
  name: string;
  stageId: number;
  displayOrder: number;
  stage?: {
    id: number;
    name: string;
  };
}

export interface UseLevelsParams {
  stageId?: number;
}

export interface UseLevelsReturn {
  levels: Level[];
  isLoading: boolean;
  error: string | null;
  createLevel: (data: Omit<Level, 'id' | 'stage'>) => Promise<{ success: boolean; level?: Level; error?: string }>;
  updateLevel: (data: Omit<Level, 'stage'>) => Promise<{ success: boolean; level?: Level; error?: string }>;
  deleteLevel: (id: number) => Promise<{ success: boolean; error?: string }>;
  refetch: () => Promise<void>;
}

export function useLevels(params?: UseLevelsParams): UseLevelsReturn {
  const [levels, setLevels] = useState<Level[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchLevels = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const queryParams = new URLSearchParams();
      if (params?.stageId) {
        queryParams.append('stageId', params.stageId.toString());
      }

      const response = await fetch(`/api/levels?${queryParams}`);
      if (!response.ok) {
        throw new Error('Failed to fetch levels');
      }

      const data = await response.json();
      if (data.success) {
        const levelsData = data.data?.levels || data.levels || data.data || [];
        setLevels(Array.isArray(levelsData) ? levelsData : []);
      } else {
        throw new Error(data.error || 'Failed to fetch levels');
      }
    } catch (err) {
      console.error('Error fetching levels:', err);
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
    }
  }, [params?.stageId]);

  useEffect(() => {
    fetchLevels();
  }, [fetchLevels]);

  const createLevel = async (levelData: Omit<Level, 'id' | 'stage'>) => {
    try {
      const response = await fetch('/api/levels', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(levelData),
      });

      if (!response.ok) {
        const data = await response.json();
        return { success: false, error: data.error || 'Failed to create level' };
      }

      const data = await response.json();
      setLevels((prev) => [...prev, data.level]);
      return { success: true, level: data.level };
    } catch (err) {
      console.error('Error creating level:', err);
      return { success: false, error: 'An error occurred' };
    }
  };

  const updateLevel = async (levelData: Omit<Level, 'stage'>) => {
    try {
      const response = await fetch('/api/levels', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(levelData),
      });

      if (!response.ok) {
        const data = await response.json();
        return { success: false, error: data.error || 'Failed to update level' };
      }

      const data = await response.json();
      setLevels((prev) => prev.map((l) => (l.id === data.level.id ? data.level : l)));
      return { success: true, level: data.level };
    } catch (err) {
      console.error('Error updating level:', err);
      return { success: false, error: 'An error occurred' };
    }
  };

  const deleteLevel = async (id: number) => {
    try {
      const response = await fetch(`/api/levels?id=${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const data = await response.json();
        return { success: false, error: data.error || 'Failed to delete level' };
      }

      setLevels((prev) => prev.filter((l) => l.id !== id));
      return { success: true };
    } catch (err) {
      console.error('Error deleting level:', err);
      return { success: false, error: 'An error occurred' };
    }
  };

  return {
    levels,
    isLoading,
    error,
    createLevel,
    updateLevel,
    deleteLevel,
    refetch: fetchLevels,
  };
}


// ==========================================
// FILE: src/hooks/use-submission.ts
// ==========================================

import { useState, useEffect, useCallback } from 'react';
import { useSession } from 'next-auth/react';

export interface Submission {
  id: string; // Changed to string to match cuid from prisma schema
  answer: string;
  fileUrl: string | null;
  submittedAt: string; // DateTime
  aiEvalMode: 'auto' | 'manual';
  aiFeedback: string | null;
  aiScore: number | null;
  teacherNotes: string | null;
  finalScore: number | null;
  gradedAt: string | null; // DateTime
  exerciseId: string; // Changed to string
  studentId: string; // Changed to string
  gradedById: string | null; // Changed to string
  exercise: {
    id: string;
    questionRichContent: string;
    modelAnswer: string | null;
    maxScore: number | null;
    type: 'main' | 'support_with_results' | 'support_only';
    lesson: {
      id: string;
      title: string;
      subject: {
        id: string;
        name: string;
      };
      level: {
        id: string;
        name: string;
      }
    };
  };
  student: {
    id: string;
    name: string;
    email: string;
    image: string | null;
  };
  gradedBy: {
    id: string;
    name: string;
    email: string;
  } | null;
}

interface UseSubmissionReturn {
  submission: Submission | null;
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
  updateSubmission: (data: Partial<Submission>) => Promise<{ success: boolean; data?: Submission; error?: string }>;
}

export function useSubmission(submissionId: string | undefined): UseSubmissionReturn {
  const { data: session } = useSession();
  const [submission, setSubmission] = useState<Submission | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchSubmission = useCallback(async () => {
    if (!session || !submissionId) {
      setIsLoading(false);
      return;
    }
    
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/submissions/${submissionId}`);
      const result = await response.json();

      if (result.success) {
        setSubmission(result.data);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©');
      console.error('Error fetching submission:', err);
    } finally {
      setIsLoading(false);
    }
  }, [session, submissionId]);

  useEffect(() => {
    fetchSubmission();
  }, [fetchSubmission]);

  const updateSubmission = async (data: Partial<Submission>) => {
    if (!session || !submissionId) {
      return { success: false, error: 'ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø£Ùˆ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ø±Ù Ù„Ù„Ø¥Ø¬Ø§Ø¨Ø©' };
    }

    try {
      const response = await fetch(`/api/submissions/${submissionId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        setSubmission(result.data); // Update local state with the new data
        return { success: true, data: result.data };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©' };
      }
    } catch (err) {
      console.error('Error updating submission:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©' };
    }
  };


  return {
    submission,
    isLoading,
    error,
    refetch: fetchSubmission,
    updateSubmission,
  };
}

// ==========================================
// FILE: src/hooks/use-subjects.ts
// ==========================================

'use client';

import { useState, useEffect, useCallback } from 'react';

export interface Subject {
  id: number;
  name: string;
  description: string;
  stageId?: number;
  levelId?: number;
  levelIds?: number[];
  levels?: { id: number; name: string }[];
}

export interface UseSubjectsReturn {
  subjects: Subject[];
  isLoading: boolean;
  error: string | null;
  createSubject: (data: Omit<Subject, 'id'>) => Promise<{ success: boolean; subject?: Subject; error?: string }>;
  updateSubject: (data: Subject) => Promise<{ success: boolean; subject?: Subject; error?: string }>;
  deleteSubject: (id: number) => Promise<{ success: boolean; error?: string }>;
  refetch: () => Promise<void>;
}

export function useSubjects(): UseSubjectsReturn {
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchSubjects = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch('/api/subjects');
      if (!response.ok) {
        throw new Error('Failed to fetch subjects');
      }

      const data = await response.json();
      if (data.success) {
        const subjectsData = data.data?.subjects || data.subjects || data.data || [];
        setSubjects(Array.isArray(subjectsData) ? subjectsData : []);
      } else {
        throw new Error(data.error || 'Failed to fetch subjects');
      }
    } catch (err) {
      console.error('Error fetching subjects:', err);
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchSubjects();
  }, [fetchSubjects]);

  const createSubject = async (subjectData: Omit<Subject, 'id'>) => {
    try {
      const response = await fetch('/api/subjects', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(subjectData),
      });

      let result;
      try {
        result = await response.json();
      } catch (err) {
        result = { success: response.ok };
      }

      if (response.ok && result.success) {
        await fetchSubjects();
        return { success: true, subject: result.data?.subject || result.subject };
      } else {
        const errorMessage = result.error || `Request failed with status ${response.status}`;
        return { success: false, error: errorMessage };
      }
    } catch (err) {
      console.error('Error creating subject:', err);
      return { success: false, error: err instanceof Error ? err.message : 'An error occurred' };
    }
  };

  const updateSubject = async (subjectData: Subject) => {
    try {
      const response = await fetch(`/api/subjects/${subjectData.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(subjectData),
      });

      let result: any = {};
      try {
        result = await response.json();
      } catch (err) {
        result = { success: response.ok };
      }

      if (response.ok && result.success) {
        await fetchSubjects();
        return { success: true, subject: result.data?.subject || result.subject };
      } else {
        const errorMessage = result.error || `Request failed with status ${response.status}`;
        return { success: false, error: errorMessage };
      }
    } catch (err) {
      console.error('Error updating subject:', err);
      return { success: false, error: err instanceof Error ? err.message : 'An error occurred' };
    }
  };

  const deleteSubject = async (id: number) => {
    try {
      const response = await fetch(`/api/subjects/${id}`, {
        method: 'DELETE',
      });

      let result;
      try {
        result = await response.json();
      } catch (err) {
        result = { success: response.ok };
      }

      if (response.ok && result.success) {
        await fetchSubjects();
        return { success: true };
      } else {
        const errorMessage = result.error || `Request failed with status ${response.status}`;
        return { success: false, error: errorMessage };
      }
    } catch (err) {
      console.error('Error deleting subject:', err);
      return { success: false, error: err instanceof Error ? err.message : 'An error occurred' };
    }
  };

  return {
    subjects,
    isLoading,
    error,
    createSubject,
    updateSubject,
    deleteSubject,
    refetch: fetchSubjects,
  };
}


// ==========================================
// FILE: src/hooks/use-data.ts
// ==========================================

import { useState, useEffect, useCallback } from 'react';
import { useSession } from 'next-auth/react';

// ==================== Stages Hook ====================

interface Stage {
  id: number;
  name: string;
  description: string;
}

interface UseStagesReturn {
  stages: Stage[];
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
}

export function useStages(): UseStagesReturn {
  const { data: session } = useSession();
  const [stages, setStages] = useState<Stage[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchStages = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/stages');
      const result = await response.json();

      if (result.success) {
        const stagesData = result.data?.stages || result.data || [];
        setStages(Array.isArray(stagesData) ? stagesData : []);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„');
      console.error('Error fetching stages:', err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStages();
  }, [fetchStages]);

  return {
    stages,
    isLoading,
    error,
    refetch: fetchStages,
  };
}

// ==================== Levels Hook ====================

interface Level {
  id: number;
  name: string;
  stage_id: number;
  stage?: {
    id: number;
    name: string;
  };
}

interface UseLevelsParams {
  stageId?: number;
}

interface UseLevelsReturn {
  levels: Level[];
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
}

export function useLevels(params?: UseLevelsParams): UseLevelsReturn {
  const [levels, setLevels] = useState<Level[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchLevels = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const queryParams = new URLSearchParams();
      if (params?.stageId) queryParams.append('stageId', params.stageId.toString());

      const response = await fetch(`/api/levels?${queryParams.toString()}`);
      const result = await response.json();

      if (result.success) {
        // Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø­Ø§Ù„ØªÙŠÙ†: data.levels Ø£Ùˆ data Ù…Ø¨Ø§Ø´Ø±Ø©
        const levelsData = result.data.levels || result.data;
        setLevels(Array.isArray(levelsData) ? levelsData : []);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª');
      console.error('Error fetching levels:', err);
    } finally {
      setIsLoading(false);
    }
  }, [params?.stageId]);

  useEffect(() => {
    fetchLevels();
  }, [fetchLevels]);

  return {
    levels,
    isLoading,
    error,
    refetch: fetchLevels,
  };
}

// ==================== Subjects Hook ====================

interface Subject {
  id: number;
  name: string;
  description: string | null;
  icon: string | null;
}

interface UseSubjectsReturn {
  subjects: Subject[];
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
}

export function useSubjects(): UseSubjectsReturn {
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchSubjects = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/subjects');
      const result = await response.json();

      if (result.success) {
        const subjectsData = result.data?.subjects || result.data || [];
        setSubjects(Array.isArray(subjectsData) ? subjectsData : []);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯');
      console.error('Error fetching subjects:', err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchSubjects();
  }, [fetchSubjects]);

  return {
    subjects,
    isLoading,
    error,
    refetch: fetchSubjects,
  };
}


// ==========================================
// FILE: src/hooks/use-messages.ts
// ==========================================

import { useState, useEffect, useCallback } from 'react';
import { useSession } from 'next-auth/react';

interface Message {
  id: number;
  subject: string;
  body: string;
  isRead: boolean;
  sentAt: string;
  senderId: number;
  recipientId: number;
  sender?: {
    id: number;
    name: string;
    email: string;
    role: string;
  };
  recipient?: {
    id: number;
    name: string;
    email: string;
    role: string;
  };
}

interface UseMessagesParams {
  type?: 'sent' | 'received' | 'all';
  isRead?: boolean;
  page?: number;
  limit?: number;
}

interface UseMessagesReturn {
  messages: Message[];
  total: number;
  unreadCount: number;
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
  sendMessage: (data: SendMessageData) => Promise<{ success: boolean; data?: Message; error?: string }>;
  markAsRead: (id: number) => Promise<{ success: boolean; error?: string }>;
  deleteMessage: (id: number) => Promise<{ success: boolean; error?: string }>;
}

interface SendMessageData {
  recipientId: number;
  subject: string;
  body: string;
}

export function useMessages(params?: UseMessagesParams): UseMessagesReturn {
  const { data: session } = useSession();
  const [messages, setMessages] = useState<Message[]>([]);
  const [total, setTotal] = useState(0);
  const [unreadCount, setUnreadCount] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchMessages = useCallback(async () => {
    if (!session) return;
    
    setIsLoading(true);
    setError(null);

    try {
      const queryParams = new URLSearchParams();
      if (params?.type) queryParams.append('type', params.type);
      if (params?.isRead !== undefined) queryParams.append('isRead', params.isRead.toString());
      if (params?.page) queryParams.append('page', params.page.toString());
      if (params?.limit) queryParams.append('limit', params.limit.toString());

      const response = await fetch(`/api/messages?${queryParams.toString()}`);
      const result = await response.json();

      if (result.success) {
        setMessages(result.data);
        setTotal(result.total || result.data.length);
        setUnreadCount(result.unreadCount || 0);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„');
      console.error('Error fetching messages:', err);
    } finally {
      setIsLoading(false);
    }
  }, [session, params?.type, params?.isRead, params?.page, params?.limit]);

  useEffect(() => {
    fetchMessages();
  }, [fetchMessages]);

  const sendMessage = async (data: SendMessageData) => {
    try {
      const response = await fetch('/api/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        await fetchMessages();
        return { success: true, data: result.data };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
      }
    } catch (err) {
      console.error('Error sending message:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
    }
  };

  const markAsRead = async (id: number) => {
    try {
      const response = await fetch(`/api/messages/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ isRead: true }),
      });

      const result = await response.json();

      if (result.success) {
        await fetchMessages();
        return { success: true };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
      }
    } catch (err) {
      console.error('Error marking message as read:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
    }
  };

  const deleteMessage = async (id: number) => {
    try {
      const response = await fetch(`/api/messages/${id}`, {
        method: 'DELETE',
      });

      const result = await response.json();

      if (result.success) {
        await fetchMessages();
        return { success: true };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
      }
    } catch (err) {
      console.error('Error deleting message:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©' };
    }
  };

  return {
    messages,
    total,
    unreadCount,
    isLoading,
    error,
    refetch: fetchMessages,
    sendMessage,
    markAsRead,
    deleteMessage,
  };
}


// ==========================================
// FILE: src/hooks/use-stages.ts
// ==========================================

'use client';

import { useState, useEffect, useCallback } from 'react';

export interface Stage {
  id: number;
  name: string;
  displayOrder: number;
}

export interface UseStagesReturn {
  stages: Stage[];
  isLoading: boolean;
  error: string | null;
  createStage: (data: Omit<Stage, 'id'>) => Promise<{ success: boolean; stage?: Stage; error?: string }>;
  updateStage: (data: Stage) => Promise<{ success: boolean; stage?: Stage; error?: string }>;
  deleteStage: (id: number) => Promise<{ success: boolean; error?: string }>;
  refetch: () => Promise<void>;
}

export function useStages(): UseStagesReturn {
  const [stages, setStages] = useState<Stage[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchStages = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch('/api/stages');
      if (!response.ok) {
        throw new Error('Failed to fetch stages');
      }

      const data = await response.json();
      if (data.success) {
        const stagesData = data.data?.stages || data.stages || data.data || [];
        setStages(Array.isArray(stagesData) ? stagesData : []);
      } else {
        throw new Error(data.error || 'Failed to fetch stages');
      }
    } catch (err) {
      console.error('Error fetching stages:', err);
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStages();
  }, [fetchStages]);

  const createStage = async (stageData: Omit<Stage, 'id'>) => {
    try {
      const response = await fetch('/api/stages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(stageData),
      });

      if (!response.ok) {
        const data = await response.json();
        return { success: false, error: data.error || 'Failed to create stage' };
      }

      const data = await response.json();
      setStages((prev) => [...prev, data.stage]);
      return { success: true, stage: data.stage };
    } catch (err) {
      console.error('Error creating stage:', err);
      return { success: false, error: 'An error occurred' };
    }
  };

  const updateStage = async (stageData: Stage) => {
    try {
      const response = await fetch('/api/stages', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(stageData),
      });

      if (!response.ok) {
        const data = await response.json();
        return { success: false, error: data.error || 'Failed to update stage' };
      }

      const data = await response.json();
      setStages((prev) => prev.map((s) => (s.id === data.stage.id ? data.stage : s)));
      return { success: true, stage: data.stage };
    } catch (err) {
      console.error('Error updating stage:', err);
      return { success: false, error: 'An error occurred' };
    }
  };

  const deleteStage = async (id: number) => {
    try {
      const response = await fetch(`/api/stages?id=${id}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const data = await response.json();
        return { success: false, error: data.error || 'Failed to delete stage' };
      }

      setStages((prev) => prev.filter((s) => s.id !== id));
      return { success: true };
    } catch (err) {
      console.error('Error deleting stage:', err);
      return { success: false, error: 'An error occurred' };
    }
  };

  return {
    stages,
    isLoading,
    error,
    createStage,
    updateStage,
    deleteStage,
    refetch: fetchStages,
  };
}


// ==========================================
// FILE: src/hooks/use-exercises.ts
// ==========================================

import { useState, useEffect, useCallback } from 'react';
import { useSession } from 'next-auth/react';

interface Exercise {
  id: number;
  lessonId: number;
  type: string;
  question?: string | null;
  questionFileUrl?: string | null;
  questionRichContent?: string | null;
  modelAnswer?: string | null;
  modelAnswerImage?: string | null;
  expectedResults?: any;
  maxScore: number;
  allowRetry: boolean;
  maxAttempts: number;
  displayOrder: number;
  createdAt: string;
  updatedAt: string;
  lesson?: {
    id: number;
    title: string;
    subject?: {
      id: number;
      name: string;
    };
    level?: {
      id: number;
      name: string;
    };
  };
  _count?: {
    submissions: number;
  };
}

interface UseExercisesParams {
  lessonId?: number;
  authorId?: string;
  difficulty?: 'easy' | 'medium' | 'hard';
  type?: 'multiple_choice' | 'true_false' | 'short_answer' | 'essay' | 'code';
  page?: number;
  limit?: number;
}

interface UseExercisesReturn {
  exercises: Exercise[];
  total: number;
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
  createExercise: (data: CreateExerciseData) => Promise<{ success: boolean; data?: Exercise; error?: string }>;
  updateExercise: (id: number, data: UpdateExerciseData) => Promise<{ success: boolean; data?: Exercise; error?: string }>;
  deleteExercise: (id: number) => Promise<{ success: boolean; error?: string }>;
}

interface CreateExerciseData {
  title: string;
  description?: string;
  question: string;
  correctAnswer?: string;
  points: number;
  difficulty: 'easy' | 'medium' | 'hard';
  type: 'multiple_choice' | 'true_false' | 'short_answer' | 'essay' | 'code';
  lessonId: number;
}

interface UpdateExerciseData {
  title?: string;
  description?: string;
  question?: string;
  correctAnswer?: string;
  points?: number;
  difficulty?: 'easy' | 'medium' | 'hard';
  type?: 'multiple_choice' | 'true_false' | 'short_answer' | 'essay' | 'code';
}

export function useExercises(params?: UseExercisesParams): UseExercisesReturn {
  const { data: session } = useSession();
  const [exercises, setExercises] = useState<Exercise[]>([]);
  const [total, setTotal] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchExercises = useCallback(async () => {
    if (!session) return;
    
    setIsLoading(true);
    setError(null);

    try {
      const queryParams = new URLSearchParams();
      if (params?.lessonId) queryParams.append('lessonId', params.lessonId.toString());
      if (params?.authorId) queryParams.append('authorId', params.authorId);
      if (params?.difficulty) queryParams.append('difficulty', params.difficulty);
      if (params?.type) queryParams.append('type', params.type);
      if (params?.page) queryParams.append('page', params.page.toString());
      if (params?.limit) queryParams.append('limit', params.limit.toString());

      const response = await fetch(`/api/exercises?${queryParams.toString()}`);
      const result = await response.json();

      if (result.success) {
        const exercisesList = result.data?.exercises || result.data || [];
        setExercises(Array.isArray(exercisesList) ? exercisesList : []);
        setTotal(result.total || exercisesList.length);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†');
      console.error('Error fetching exercises:', err);
    } finally {
      setIsLoading(false);
    }
  }, [session, params?.lessonId, params?.authorId, params?.difficulty, params?.type, params?.page, params?.limit]);

  useEffect(() => {
    fetchExercises();
  }, [fetchExercises]);

  const createExercise = async (data: CreateExerciseData) => {
    try {
      const response = await fetch('/api/exercises', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        await fetchExercises();
        return { success: true, data: result.data };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ†' };
      }
    } catch (err) {
      console.error('Error creating exercise:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ†' };
    }
  };

  const updateExercise = async (id: number, data: UpdateExerciseData) => {
    try {
      const response = await fetch(`/api/exercises/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        await fetchExercises();
        return { success: true, data: result.data };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ…Ø±ÙŠÙ†' };
      }
    } catch (err) {
      console.error('Error updating exercise:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ…Ø±ÙŠÙ†' };
    }
  };

  const deleteExercise = async (id: number) => {
    try {
      const response = await fetch(`/api/exercises/${id}`, {
        method: 'DELETE',
      });

      const result = await response.json();

      if (result.success) {
        await fetchExercises();
        return { success: true };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„ØªÙ…Ø±ÙŠÙ†' };
      }
    } catch (err) {
      console.error('Error deleting exercise:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„ØªÙ…Ø±ÙŠÙ†' };
    }
  };

  return {
    exercises,
    total,
    isLoading,
    error,
    refetch: fetchExercises,
    createExercise,
    updateExercise,
    deleteExercise,
  };
}


// ==========================================
// FILE: src/hooks/use-toast.ts
// ==========================================

"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }


// ==========================================
// FILE: src/hooks/use-lessons.ts
// ==========================================

import { useState, useEffect, useCallback } from 'react';
import { useSession } from 'next-auth/react';

// 1. ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
export interface Subject {
  id: number;
  name: string;
}

export interface Level {
  id: number;
  name: string;
}

// 2. ØªØ­Ø¯ÙŠØ« Ù†ÙˆØ¹ Ø§Ù„Ø¯Ø±Ø³ Ù„ÙŠØ´Ù…Ù„ Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
export interface Lesson {
  id: number;
  title: string;
  content: string;
  authorId: string;
  subjectId: number;
  levelId: number;
  createdAt: string;
  updatedAt: string;
  videoUrl?: string;
  imageUrl?: string;
  pdfUrl?: string;
  // ØªØ¶Ù…ÙŠÙ† Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø³ØªÙˆÙ‰
  subject: Subject;
  level: Level;
}

interface CreateLessonData {
  title: string;
  content: string;
  subjectId: number;
  levelId: number;
  videoUrl?: string;
  imageUrl?: string;
  pdfUrl?: string;
}

// 3. ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨Ø§Ø±Ø§Ù…ØªØ±Ø§Øª Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø·Ù„Ø¨ Ø§Ù„ØªØ¶Ù…ÙŠÙ†
interface UseLessonsParams {
  authorId?: string;
  subjectId?: number;
  levelId?: number;
  page?: number;
  limit?: number;
  status?: string;
  include?: { 
    subject?: boolean;
    level?: boolean;
  };
}

interface UseLessonsReturn {
  lessons: Lesson[];
  isLoading: boolean;
  error: string | null;
  createLesson: (data: CreateLessonData) => Promise<{ success: boolean; data?: Lesson; error?: string }>;
}

export function useLessons(params?: UseLessonsParams): UseLessonsReturn {
  const { data: session } = useSession();
  const [lessons, setLessons] = useState<Lesson[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchLessons = useCallback(async () => {
    if (!session) {
        setIsLoading(false);
        return;
    }
    
    setIsLoading(true);
    setError(null);

    try {
      // 4. Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù€ query string Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ§Ù‹ Ù„ÙŠØ´Ù…Ù„ Ø¨Ø§Ø±Ø§Ù…ØªØ±Ø§Øª `include`
      const queryParams = new URLSearchParams();
      if (params?.authorId) queryParams.append('authorId', params.authorId);
      if (params?.subjectId) queryParams.append('subjectId', params.subjectId.toString());
      if (params?.levelId) queryParams.append('levelId', params.levelId.toString());
      if (params?.page) queryParams.append('page', params.page.toString());
      if (params?.limit) queryParams.append('limit', params.limit.toString());
      if (params?.status) queryParams.append('status', params.status);

      // Ø¥Ø¶Ø§ÙØ© Ø¨Ø§Ø±Ø§Ù…ØªØ±Ø§Øª Ø§Ù„ØªØ¶Ù…ÙŠÙ† Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
      if (params?.include) {
        const includes = Object.entries(params.include)
          .filter(([, value]) => value)
          .map(([key]) => key);
        if (includes.length > 0) {
          queryParams.append('include', includes.join(','));
        }
      }

      const response = await fetch(`/api/lessons?${queryParams.toString()}`);
      const result = await response.json();

      if (result.success) {
        // API returns { success: true, data: { lessons: [...], pagination: {...} } }
        const lessonsData = result.data?.lessons || result.data || [];
        setLessons(Array.isArray(lessonsData) ? lessonsData : []);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¯Ø±ÙˆØ³');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¯Ø±ÙˆØ³');
      console.error('Error fetching lessons:', err);
    } finally {
      setIsLoading(false);
    }
  // 5. Ø¥Ø¶Ø§ÙØ© `params.include` Ø¥Ù„Ù‰ Ù…ØµÙÙˆÙØ© Ø§Ù„Ù€ dependencies
  }, [session, params?.authorId, params?.subjectId, params?.levelId, params?.page, params?.limit, params?.status, JSON.stringify(params?.include)]); 

  useEffect(() => {
    fetchLessons();
  }, [fetchLessons]);

  const createLesson = useCallback(async (lessonData: CreateLessonData) => {
    try {
      const response = await fetch('/api/lessons', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(lessonData),
      });
      const result = await response.json();
      if (result.success) {
        fetchLessons(); // Refetch lessons to show the new one
      }
      return result;
    } catch (err) {
      console.error('Error creating lesson:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³' };
    }
  }, [fetchLessons]);

  return {
    lessons,
    isLoading,
    error,
    createLesson,
  };
}


// ==========================================
// FILE: src/hooks/use-window-size.tsx
// ==========================================

import { useState, useEffect } from 'react';

export function useWindowSize() {
  const [windowSize, setWindowSize] = useState({
    width: typeof window !== 'undefined' ? window.innerWidth : 0,
    height: typeof window !== 'undefined' ? window.innerHeight : 0,
  });

  useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener('resize', handleResize);
    handleResize();

    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return windowSize;
}


// ==========================================
// FILE: src/hooks/use-mobile.tsx
// ==========================================

import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


// ==========================================
// FILE: src/hooks/use-submissions.ts
// ==========================================

import { useState, useEffect, useCallback } from 'react';
import { useSession } from 'next-auth/react';

interface Submission {
  id: number;
  answer: string;
  fileUrl: string | null;
  submittedAt: string;
  aiEvalMode: 'auto' | 'manual';
  aiFeedback: string | null;
  aiScore: number | null;
  teacherNotes: string | null;
  finalScore: number | null;
  gradedAt: string | null;
  exerciseId: number;
  studentId: number;
  gradedById: number | null;
  exercise?: {
    id: number;
    title: string;
    question: string;
    points: number;
    difficulty: string;
    type: string;
    lesson: {
      id: number;
      title: string;
      subject: {
        id: number;
        name: string;
      };
    };
  };
  student?: {
    id: number;
    name: string;
    email: string;
  };
  gradedBy?: {
    id: number;
    name: string;
    email: string;
  };
}

interface UseSubmissionsParams {
  exerciseId?: number;
  studentId?: number;
  gradedById?: number;
  page?: number;
  limit?: number;
}

interface UseSubmissionsReturn {
  submissions: Submission[];
  total: number;
  isLoading: boolean;
  error: string | null;
  refetch: () => void;
  createSubmission: (data: CreateSubmissionData) => Promise<{ success: boolean; data?: Submission; error?: string }>;
  gradeSubmission: (id: number, data: GradeSubmissionData) => Promise<{ success: boolean; data?: Submission; error?: string }>;
}

interface CreateSubmissionData {
  exerciseId: number;
  answer: string;
  fileUrl?: string;
  aiEvalMode: 'auto' | 'manual';
}

interface GradeSubmissionData {
  finalScore: number;
  teacherNotes?: string;
}

export function useSubmissions(params?: UseSubmissionsParams): UseSubmissionsReturn {
  const { data: session } = useSession();
  const [submissions, setSubmissions] = useState<Submission[]>([]);
  const [total, setTotal] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchSubmissions = useCallback(async () => {
    if (!session) return;
    
    setIsLoading(true);
    setError(null);

    try {
      const queryParams = new URLSearchParams();
      if (params?.exerciseId) queryParams.append('exerciseId', params.exerciseId.toString());
      if (params?.studentId) queryParams.append('studentId', params.studentId.toString());
      if (params?.gradedById) queryParams.append('gradedById', params.gradedById.toString());
      if (params?.page) queryParams.append('page', params.page.toString());
      if (params?.limit) queryParams.append('limit', params.limit.toString());

      const response = await fetch(`/api/submissions?${queryParams.toString()}`);
      const result = await response.json();

      if (result.success) {
        setSubmissions(result.data);
        setTotal(result.total || result.data.length);
      } else {
        setError(result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª');
      }
    } catch (err) {
      setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª');
      console.error('Error fetching submissions:', err);
    } finally {
      setIsLoading(false);
    }
  }, [session, params?.exerciseId, params?.studentId, params?.gradedById, params?.page, params?.limit]);

  useEffect(() => {
    fetchSubmissions();
  }, [fetchSubmissions]);

  const createSubmission = async (data: CreateSubmissionData) => {
    try {
      const response = await fetch('/api/submissions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        await fetchSubmissions();
        return { success: true, data: result.data };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©' };
      }
    } catch (err) {
      console.error('Error creating submission:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©' };
    }
  };

  const gradeSubmission = async (id: number, data: GradeSubmissionData) => {
    try {
      const response = await fetch(`/api/submissions/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        await fetchSubmissions();
        return { success: true, data: result.data };
      } else {
        return { success: false, error: result.error || 'ÙØ´Ù„ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©' };
      }
    } catch (err) {
      console.error('Error grading submission:', err);
      return { success: false, error: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©' };
    }
  };

  return {
    submissions,
    total,
    isLoading,
    error,
    refetch: fetchSubmissions,
    createSubmission,
    gradeSubmission,
  };
}


// ==========================================
// FILE: src/app/(main)/layout.tsx
// ==========================================

import { Sidebar, SidebarProvider, SidebarInset } from "@/components/ui/sidebar";
import { SidebarNav } from "@/components/layout/SidebarNav";
import { Header } from "@/components/layout/Header";
import PromotionGuard from "@/components/PromotionGuard";

// Force dynamic rendering for all dashboard pages
export const dynamic = 'force-dynamic';

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <SidebarProvider>
      <Sidebar side="right" collapsible="icon">
        <SidebarNav />
      </Sidebar>
      <SidebarInset>
        <div className="flex h-screen flex-col">
          <Header />
          <main className="flex-1 overflow-auto p-4 md:p-6 lg:p-8">
            <PromotionGuard>{children}</PromotionGuard>
          </main>
        </div>
      </SidebarInset>
    </SidebarProvider>
  );
}


// ==========================================
// FILE: src/app/(main)/test-math/page.tsx
// ==========================================

'use client';

import { useState } from 'react';
import MathContent from '@/components/MathContent';
import { RichTextEditor } from '@/components/editor';

export default function TestMathPage() {
  const [editorContent, setEditorContent] = useState('');

  // Ù…Ø­ØªÙˆÙ‰ ØªØ¬Ø±ÙŠØ¨ÙŠ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ØµÙŠØº Ø±ÙŠØ§Ø¶ÙŠØ©
  const testContent = `
    <h2>Ø£Ù…Ø«Ù„Ø© Ø¹Ù„Ù‰ Ø§Ù„ØµÙŠØº Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©</h2>
    
    <h3>1. Ù…Ø¹Ø§Ø¯Ù„Ø§Øª ÙÙŠ Ø§Ù„Ø³Ø·Ø±</h3>
    <p>Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„ØªØ±Ø¨ÙŠØ¹ÙŠØ©: \\(x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}\\)</p>
    <p>Ù†Ø¸Ø±ÙŠØ© ÙÙŠØ«Ø§ØºÙˆØ±Ø³: \\(a^2 + b^2 = c^2\\)</p>
    <p>Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„ÙŠÙˆÙ†Ø§Ù†ÙŠØ©: \\(\\alpha, \\beta, \\gamma, \\theta, \\pi, \\omega\\)</p>
    
    <h3>2. Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ù…Ø¹Ø±ÙˆØ¶Ø©</h3>
    <p>Ù…Ø¹Ø§Ø¯Ù„Ø© Ø£ÙŠÙ†Ø´ØªØ§ÙŠÙ† Ø§Ù„Ø´Ù‡ÙŠØ±Ø©:</p>
    $$E = mc^2$$
    
    <p>ØµÙŠØºØ© Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹:</p>
    $$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$
    
    <h3>3. Ù…ØµÙÙˆÙØ§Øª</h3>
    <p>Ù…ØµÙÙˆÙØ© 2Ã—2:</p>
    $$\\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}$$
    
    <p>Ù…ØµÙÙˆÙØ© 3Ã—3:</p>
    $$\\begin{bmatrix} a & b & c \\\\ d & e & f \\\\ g & h & i \\end{bmatrix}$$
    
    <p>Ù…Ø­Ø¯Ø¯ (Determinant):</p>
    $$\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix} = ad - bc$$
    
    <h3>4. Ù†Ø¸Ø§Ù… Ù…Ø¹Ø§Ø¯Ù„Ø§Øª</h3>
    $$\\begin{cases} 
    x + y = 5 \\\\ 
    2x - y = 1 
    \\end{cases}$$
    
    <p>Ø§Ù„Ø­Ù„: \\(x = 2\\) Ùˆ \\(y = 3\\)</p>
    
    <h3>5. ØªÙƒØ§Ù…Ù„ ÙˆÙ…Ø´ØªÙ‚Ø§Øª</h3>
    $$\\int_{0}^{\\infty} e^{-x^2} dx = \\frac{\\sqrt{\\pi}}{2}$$
    
    $$\\frac{d}{dx}(x^n) = nx^{n-1}$$
    
    <h3>6. Ù…ØªØ¬Ù‡Ø§Øª</h3>
    <p>Ù…ØªØ¬Ù‡ ÙÙŠ Ø§Ù„ÙØ¶Ø§Ø¡:</p>
    $$\\vec{v} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$$
  `;

  return (
    <div className="container mx-auto p-8 max-w-6xl">
      {/* Ù…Ø­Ø±Ø± Ø§Ù„Ù†ØµÙˆØµ Ù…Ø¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© */}
      <div className="bg-white rounded-lg shadow-md p-6 mb-8">
        <h2 className="text-2xl font-bold mb-2">Ø§Ø®ØªØ¨Ø± Ø§Ù„Ù…Ø­Ø±Ø± Ù…Ø¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©</h2>
        <p className="text-muted-foreground mb-4">
          âœ¨ Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± "Ø±Ù…ÙˆØ² Ø±ÙŠØ§Ø¶ÙŠØ©" Ù„Ø¥Ø¶Ø§ÙØ© ØµÙŠØº Ø¬Ø§Ù‡Ø²Ø© - Ø³ØªØ¸Ù‡Ø± Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© Ø£Ø³ÙÙ„ Ø§Ù„Ù…Ø­Ø±Ø±
        </p>
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
          <h3 className="font-bold text-sm mb-2">ğŸ’¡ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:</h3>
          <ul className="text-sm space-y-1 list-disc list-inside">
            <li>Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² Ù…ÙØ¹Ø±Ù‘Ø¶Ø© Ø¨Ø´ÙƒÙ„ Ø¬Ù…ÙŠÙ„ (Ù„Ø§ Ù…Ø²ÙŠØ¯ Ù…Ù† LaTeX Ø§Ù„Ø®Ø§Ù…!)</li>
            <li>Ù…Ø±Ø¨Ø¹ Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø¨Ø§Ø´Ø±Ø© ÙŠØ¸Ù‡Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©</li>
            <li>ØªØ¨ÙˆÙŠØ¨ Ø¬Ø¯ÙŠØ¯: <strong>Ø§Ù„Ù…ØµÙÙˆÙØ§Øª</strong> (2Ã—2, 3Ã—3, Ù…Ø­Ø¯Ø¯Ø§ØªØŒ Ù†Ø¸Ù… Ù…Ø¹Ø§Ø¯Ù„Ø§Øª)</li>
            <li>Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©: Ù…Ø´ØªÙ‚Ø©ØŒ ØªÙƒØ§Ù…Ù„ØŒ Ù‚Ø§Ù†ÙˆÙ† ÙƒÙˆØ²ÙŠÙ†ØŒ ØµÙŠØºØ© Ø§Ù„Ù…Ø³Ø§ÙØ©</li>
            <li>Ø£ÙƒØ«Ø± Ù…Ù† <strong>60 Ø±Ù…Ø² ÙˆÙ…Ø¹Ø§Ø¯Ù„Ø© Ø¬Ø§Ù‡Ø²Ø©!</strong></li>
          </ul>
        </div>
        <RichTextEditor
          content={editorContent}
          onChange={setEditorContent}
          placeholder="Ø¬Ø±Ù‘Ø¨ ÙƒØªØ§Ø¨Ø© Ù…Ø­ØªÙˆÙ‰ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©..."
        />
      </div>

      {/* Ø£Ù…Ø«Ù„Ø© Ø¬Ø§Ù‡Ø²Ø© */}
      <div className="bg-white rounded-lg shadow-md p-6">
        <h3 className="text-lg font-bold mb-4">Ø£Ù…Ø«Ù„Ø© Ø´Ø§Ù…Ù„Ø© (Ù…Ø¹Ø§Ø¯Ù„Ø§ØªØŒ Ù…ØµÙÙˆÙØ§ØªØŒ Ø±Ù…ÙˆØ²):</h3>
        <MathContent content={testContent} />
      </div>
      
      <div className="mt-8 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6 border border-blue-200">
        <MathContent content={testContent} />
      </div>
      
      <div className="mt-8 bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6 border border-blue-200">
        <h3 className="text-lg font-bold mb-4 flex items-center gap-2">
          ğŸ“š Ø¯Ù„ÙŠÙ„ Ø³Ø±ÙŠØ¹ Ù„Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        </h3>
        
        <div className="grid md:grid-cols-2 gap-4 text-sm">
          <div className="bg-white rounded p-4">
            <h4 className="font-bold mb-2">ğŸ”¢ ØªØ¨ÙˆÙŠØ¨ Ø§Ù„Ù…ØµÙÙˆÙØ§Øª (Ø¬Ø¯ÙŠØ¯!):</h4>
            <ul className="space-y-1 list-disc list-inside">
              <li>Ù…ØµÙÙˆÙØ© 2Ã—2 Ùˆ 3Ã—3</li>
              <li>Ù…ØµÙÙˆÙØ§Øª Ù…Ø¹Ù‚ÙˆÙØ© [ ]</li>
              <li>Ù…Ø­Ø¯Ø¯Ø§Øª | |</li>
              <li>Ù…ØªØ¬Ù‡Ø§Øª Ø¹Ù…ÙˆØ¯ÙŠØ©</li>
              <li>Ù†Ø¸Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª</li>
              <li>Ù…ØµÙÙˆÙØ§Øª Ù…Ø¹ Ù†Ù‚Ø§Ø·</li>
            </ul>
          </div>
          
          <div className="bg-white rounded p-4">
            <h4 className="font-bold mb-2">â• Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©:</h4>
            <ul className="space-y-1 list-disc list-inside">
              <li>Ù‚Ø§Ù†ÙˆÙ† ÙƒÙˆØ²ÙŠÙ†</li>
              <li>ØµÙŠØºØ© Ø§Ù„Ù…Ø³Ø§ÙØ©</li>
              <li>Ø§Ù„Ù…Ø´ØªÙ‚Ø§Øª</li>
              <li>Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø®Ø·ÙŠØ©</li>
              <li>Ø§Ù„ØªÙƒØ§Ù…Ù„</li>
            </ul>
          </div>
          
          <div className="bg-white rounded p-4">
            <h4 className="font-bold mb-2">ğŸ‘ï¸ Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©:</h4>
            <p>ÙŠØ¸Ù‡Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø£Ø³ÙÙ„ Ø§Ù„Ù…Ø­Ø±Ø± Ù„Ø¹Ø±Ø¶ ÙƒÙŠÙ Ø³ØªØ¨Ø¯Ùˆ Ø§Ù„ØµÙŠØº Ù„Ù„Ø·Ø§Ù„Ø¨ - Ù„Ø§ Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªØ®Ù…ÙŠÙ†!</p>
          </div>
          
          <div className="bg-white rounded p-4">
            <h4 className="font-bold mb-2">âœ¨ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù…ÙØ¹Ø±Ù‘Ø¶Ø©:</h4>
            <p>Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ù…ÙˆØ² ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© ØªØ¸Ù‡Ø± Ø¨Ø´ÙƒÙ„Ù‡Ø§ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø§Ù„Ø¬Ù…ÙŠÙ„ - Ø³Ù‡Ù„ Ø¬Ø¯Ø§Ù‹ Ù„Ù„Ø£Ø³ØªØ§Ø°!</p>
          </div>
        </div>
        
        <div className="mt-4 bg-green-100 border border-green-300 rounded p-3 text-sm">
          <strong>ğŸ’¡ Ù†ØµÙŠØ­Ø©:</strong> Ø¬Ø±Ù‘Ø¨ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ ØªØ¨ÙˆÙŠØ¨ "Ù…ØµÙÙˆÙØ§Øª" Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø§Ù„Ø±Ø§Ø¦Ø¹Ø©!
        </div>
      </div>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/messages/page_old.tsx
// ==========================================

'use client';

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { cn } from "@/lib/utils";
import { formatDistanceToNow } from "date-fns";
import { ar } from "date-fns/locale";
import { Send, Loader2, MessageSquare, Inbox } from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { useSearchParams } from "next/navigation";
import { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import { useToast } from "@/hooks/use-toast";

type Message = {
  id: number;
  senderId: string;
  recipientId: string;
  subject: string;
  content: string;
  isRead: boolean;
  createdAt: string;
  sender: {
    id: string;
    firstName: string;
    lastName: string;
    image: string | null;
  };
  recipient: {
    id: string;
    firstName: string;
    lastName: string;
    image: string | null;
  };
};

type Partner = {
  id: string;
  name: string;
  image: string | null;
  lastMessage: string;
  lastMessageTime: string;
  unreadCount: number;
};

export default function MessagesPage() {
  const searchParams = useSearchParams();
  const { data: session } = useSession();
  const { toast } = useToast();
  const scrollRef = useRef<HTMLDivElement>(null);
  
  const recipientIdFromQuery = searchParams.get('recipient');
  const currentUserId = session?.user?.id;

  const [messages, setMessages] = useState<Message[]>([]);
  const [partners, setPartners] = useState<Partner[]>([]);
  const [selectedPartnerId, setSelectedPartnerId] = useState<string | null>(null);
  const [messageText, setMessageText] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (currentUserId) {
      fetchMessages();
    }
  }, [currentUserId]);

  useEffect(() => {
    if (recipientIdFromQuery && messages.length > 0) {
      setSelectedPartnerId(recipientIdFromQuery);
    }
  }, [recipientIdFromQuery, messages]);

  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [selectedConversation]);
  }, [recipientIdFromQuery, allPartners.length, selectedPartnerId]);

  const selectedPartner = Array.isArray(users) ? users.find(u => u.id === selectedPartnerId) : undefined;
  
  const conversationMessages = Array.isArray(messages) ? messages.filter(m => {
    return (
      (m.senderId === currentUserId && m.recipientId === selectedPartnerId) ||
      (m.senderId === selectedPartnerId && m.recipientId === currentUserId)
    );
  }).sort((a, b) => new Date(a.sentAt).getTime() - new Date(b.sentAt).getTime()) : [];

  // Mark unread messages as read
  useEffect(() => {
    conversationMessages
      .filter(m => m.recipientId === currentUserId && !m.isRead)
      .forEach(m => markAsRead(m.id));
  }, [conversationMessages, currentUserId]);

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!messageText.trim() || !selectedPartnerId) return;

    setIsSending(true);
    const result = await sendMessage({
      recipientId: selectedPartnerId,
      subject: 'Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©',
      body: messageText,
    });

    if (result.success) {
      setMessageText('');
    } else {
      toast({
        title: 'Ø®Ø·Ø£',
        description: result.error || 'ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©',
        variant: 'destructive',
      });
    }
    setIsSending(false);
  };

  const roleName = (role?: string) => {
    if (!role) return '';
    const roles: Record<string, string> = {
      teacher: 'Ù…Ø¹Ù„Ù…',
      student: 'Ø·Ø§Ù„Ø¨',
      parent: 'ÙˆÙ„ÙŠ Ø£Ù…Ø±',
      directeur: 'Ù…Ø¯ÙŠØ±',
      supervisor_specific: 'Ù…Ø´Ø±Ù Ù…Ø§Ø¯Ø©',
    };
    return roles[role] || 'Ù…Ø³ØªØ®Ø¯Ù…';
  };

  if (messagesLoading) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-5rem)]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!currentUserId) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-5rem)]">
        <p className="text-muted-foreground">Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</p>
      </div>
    );
  }

  if (allPartners.length === 0) {
    return (
      <div className="flex flex-col gap-8 items-center justify-center h-[calc(100vh-5rem)]">
        <div className="grid gap-1 text-center">
          <h1 className="text-3xl font-bold tracking-tight">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„</h1>
          <p className="text-muted-foreground">
            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ Ø£ÙŠ Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø­Ø§Ù„ÙŠØ§Ù‹.
          </p>
        </div>
      </div>
    );
  }


  return (
    <div className="h-[calc(100vh-5rem)] flex flex-col">
        <div className="flex items-center px-4 py-3 border-b">
            <h1 className="text-xl font-bold">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„</h1>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-[280px_1fr] lg:grid-cols-[320px_1fr] h-full overflow-hidden">
            <div className="border-l flex flex-col">
                <div className="p-4">
                     <Input placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„..."/>
                </div>
                <Separator />
                <ScrollArea className="flex-1">
                    <div className="flex flex-col gap-0 p-2">
                        {allPartners.map((partner) => {
                            const partnerMessages = messages.filter(m =>
                              m.senderId === partner!.id || m.recipientId === partner!.id
                            );
                            const lastMessage = partnerMessages[0];
                            const unreadCount = partnerMessages.filter(
                              m => m.recipientId === currentUserId && !m.isRead
                            ).length;
                            
                            return (
                                <button
                                    key={partner!.id}
                                    onClick={() => setSelectedPartnerId(partner!.id)}
                                    className={cn(
                                        "flex flex-col items-start gap-2 rounded-lg border border-transparent p-3 text-left text-sm transition-all hover:bg-accent",
                                        partner!.id === selectedPartnerId && "bg-accent border-border"
                                    )}
                                >
                                    <div className="flex w-full items-center gap-3">
                                        <Avatar className="h-10 w-10">
                                            <AvatarImage src={partner!.image || undefined} alt={partner!.name} />
                                            <AvatarFallback>{partner!.name.charAt(0)}</AvatarFallback>
                                        </Avatar>
                                        <div className="flex-1 truncate">
                                            <div className="font-semibold">{partner!.name}</div>
                                            {lastMessage && (
                                              <div className="text-xs text-muted-foreground truncate">
                                                {lastMessage.body}
                                              </div>
                                            )}
                                        </div>
                                        <div className="flex flex-col items-end gap-1">
                                            {lastMessage && (
                                                <div className="text-xs text-muted-foreground">
                                                    {formatDistanceToNow(new Date(lastMessage.sentAt), { 
                                                      addSuffix: true, 
                                                      locale: ar 
                                                    })}
                                                </div>
                                            )}
                                            {unreadCount > 0 && (
                                                <div className="bg-primary text-primary-foreground text-xs rounded-full h-5 w-5 flex items-center justify-center">
                                                    {unreadCount}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </button>
                            );
                        })}
                    </div>
                </ScrollArea>
            </div>

            {selectedPartner ? (
                <div className="flex flex-col h-full">
                    <div className="flex items-center gap-4 p-4 border-b">
                        <Avatar>
                            <AvatarImage src={selectedPartner.image || undefined} alt={selectedPartner.name} />
                            <AvatarFallback>{selectedPartner.name.charAt(0)}</AvatarFallback>
                        </Avatar>
                        <div>
                            <div className="font-semibold">{selectedPartner.name}</div>
                            <div className="text-sm text-muted-foreground">
                              {roleName(selectedPartner.role)}
                            </div>
                        </div>
                    </div>
                    <ScrollArea className="flex-1 p-4">
                        <div className="space-y-6">
                            {conversationMessages.map(message => {
                                const isMe = message.senderId === currentUserId;
                                const author = isMe 
                                  ? users.find(u => u.id === currentUserId) 
                                  : selectedPartner;
                                return (
                                    <div 
                                      key={message.id} 
                                      className={cn(
                                        "flex items-end gap-3", 
                                        isMe ? "justify-end" : "justify-start"
                                      )}
                                    >
                                        {!isMe && 
                                            <Avatar className="h-9 w-9">
                                                <AvatarImage src={author?.image || undefined} />
                                                <AvatarFallback>
                                                  {author?.name.charAt(0)}
                                                </AvatarFallback>
                                            </Avatar>
                                        }
                                        <div className={cn(
                                          "max-w-lg rounded-lg p-3", 
                                          isMe 
                                            ? "bg-primary text-primary-foreground" 
                                            : "bg-muted"
                                        )}>
                                            <p className="leading-relaxed">{message.body}</p>
                                            <p className={cn(
                                              "text-xs mt-2 text-right", 
                                              isMe 
                                                ? "text-primary-foreground/70" 
                                                : "text-muted-foreground"
                                            )}>
                                                {formatDistanceToNow(
                                                  new Date(message.sentAt), 
                                                  { addSuffix: true, locale: ar }
                                                )}
                                            </p>
                                        </div>
                                        {isMe && 
                                            <Avatar className="h-9 w-9">
                                                <AvatarImage src={author?.image || undefined} />
                                                <AvatarFallback>
                                                  {author?.name.charAt(0)}
                                                </AvatarFallback>
                                            </Avatar>
                                        }
                                    </div>
                                )
                            })}
                            {conversationMessages.length === 0 && (
                                <div className="text-center text-muted-foreground py-8">
                                    <p>Ø§Ø¨Ø¯Ø£ Ù…Ø­Ø§Ø¯Ø«Ø© Ù…Ø¹ {selectedPartner.name}.</p>
                                </div>
                            )}
                        </div>
                    </ScrollArea>
                    <div className="p-4 border-t bg-background">
                        <form onSubmit={handleSendMessage}>
                            <div className="relative">
                                <Textarea 
                                  placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ..." 
                                  className="pr-16" 
                                  rows={1}
                                  value={messageText}
                                  onChange={(e) => setMessageText(e.target.value)}
                                  disabled={isSending}
                                />
                                <Button 
                                  type="submit" 
                                  size="icon" 
                                  className="absolute left-3 top-1/2 -translate-y-1/2"
                                  disabled={isSending || !messageText.trim()}
                                >
                                    {isSending ? (
                                      <Loader2 className="h-5 w-5 animate-spin" />
                                    ) : (
                                      <Send className="h-5 w-5" />
                                    )}
                                    <span className="sr-only">Ø¥Ø±Ø³Ø§Ù„</span>
                                </Button>
                            </div>
                        </form>
                    </div>
                </div>
            ) : (
                <div className="flex flex-col items-center justify-center h-full text-center text-muted-foreground">
                    <p>Ø§Ø®ØªØ± Ù…Ø­Ø§Ø¯Ø«Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„.</p>
                </div>
            )}
        </div>
    </div>
  );
}

    

// ==========================================
// FILE: src/app/(main)/messages/page.tsx
// ==========================================

'use client';

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { cn } from "@/lib/utils";
import { formatDistanceToNow } from "date-fns";
import { ar } from "date-fns/locale";
import { Send, Loader2, Inbox, MessageSquare } from "lucide-react";
import { Textarea } from "@/components/ui/textarea";
import { useSearchParams } from "next/navigation";
import { useState, useEffect, useRef } from "react";
import { useSession } from "next-auth/react";
import { useToast } from "@/hooks/use-toast";

type Message = {
  id: number;
  senderId: string;
  recipientId: string;
  subject: string;
  content: string;
  isRead: boolean;
  createdAt: string;
  sender: {
    id: string;
    firstName: string;
    lastName: string;
    image: string | null;
  };
  recipient: {
    id: string;
    firstName: string;
    lastName: string;
    image: string | null;
  };
};

export default function MessagesPage() {
  const searchParams = useSearchParams();
  const { data: session } = useSession();
  const { toast } = useToast();
  const scrollRef = useRef<HTMLDivElement>(null);
  
  const recipientIdFromQuery = searchParams.get('recipient');
  const currentUserId = session?.user?.id;

  const [messages, setMessages] = useState<Message[]>([]);
  const [selectedPartnerId, setSelectedPartnerId] = useState<string | null>(null);
  const [messageText, setMessageText] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  const fetchMessages = async () => {
    try {
      setIsLoading(true);
      const response = await fetch('/api/messages');
      const result = await response.json();
      if (result.success) {
        setMessages(result.data.messages || []);
      }
    } catch (error) {
      console.error('Error fetching messages:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // Get unique partners
  const partners = Array.from(
    new Map(
      messages.map((m) => {
        const partnerId = m.senderId === currentUserId ? m.recipientId : m.senderId;
        const partner = m.senderId === currentUserId ? m.recipient : m.sender;
        return [partnerId, partner];
      })
    ).values()
  ).map((partner) => ({
    id: partner.id,
    name: `${partner.firstName} ${partner.lastName}`,
    image: partner.image,
  }));

  const selectedPartner = partners.find((p) => p.id === selectedPartnerId);

  const selectedConversation = messages
    .filter(
      (m) =>
        (m.senderId === currentUserId && m.recipientId === selectedPartnerId) ||
        (m.senderId === selectedPartnerId && m.recipientId === currentUserId)
    )
    .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());

  // Mark unread messages as read when viewing conversation
  useEffect(() => {
    const markMessagesAsRead = async () => {
      const unreadMessages = selectedConversation.filter(
        (m) => m.recipientId === currentUserId && !m.isRead
      );
      
      if (unreadMessages.length > 0) {
        try {
          await Promise.all(
            unreadMessages.map((m) =>
              fetch(`/api/messages/${m.id}/read`, { method: 'POST' })
            )
          );
          // Update local state immediately
          setMessages(prevMessages =>
            prevMessages.map(msg =>
              unreadMessages.find(um => um.id === msg.id)
                ? { ...msg, isRead: true }
                : msg
            )
          );
        } catch (error) {
          console.error('Error marking messages as read:', error);
        }
      }
    };

    if (selectedPartnerId && selectedConversation.length > 0) {
      markMessagesAsRead();
    }
  }, [selectedPartnerId, selectedConversation.length]);

  useEffect(() => {
    if (currentUserId) {
      fetchMessages();
    }
  }, [currentUserId]);

  useEffect(() => {
    if (recipientIdFromQuery) {
      setSelectedPartnerId(recipientIdFromQuery);
    } else if (partners.length > 0 && !selectedPartnerId) {
      setSelectedPartnerId(partners[0].id);
    }
  }, [recipientIdFromQuery, messages.length]);

  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [selectedConversation.length]);

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!messageText.trim() || !selectedPartnerId) return;

    setIsSending(true);
    try {
      const response = await fetch('/api/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          recipientId: selectedPartnerId,
          subject: 'Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©',
          content: messageText,
        }),
      });

      const result = await response.json();

      if (result.success) {
        setMessageText('');
        await fetchMessages(); // Refresh messages
      } else {
        throw new Error(result.error);
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©',
        variant: 'destructive',
      });
    } finally {
      setIsSending(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-5rem)]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!currentUserId) {
    return (
      <div className="flex items-center justify-center h-[calc(100vh-5rem)]">
        <p className="text-muted-foreground">Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</p>
      </div>
    );
  }

  if (partners.length === 0) {
    return (
      <div className="flex flex-col gap-8 items-center justify-center h-[calc(100vh-5rem)]">
        <Inbox className="h-16 w-16 text-muted-foreground" />
        <div className="grid gap-1 text-center">
          <h1 className="text-2xl font-bold tracking-tight">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ø¦Ù„</h1>
          <p className="text-muted-foreground">
            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù„Ø¯ÙŠÙƒ Ø£ÙŠ Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø­Ø§Ù„ÙŠØ§Ù‹
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-[calc(100vh-5rem)] flex flex-col overflow-hidden">
      <div className="flex items-center justify-between px-4 py-3 border-b flex-shrink-0">
        <h1 className="text-xl font-bold">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„</h1>
        {session?.user?.role === 'directeur' && (
          <Button 
            variant="default" 
            size="sm"
            onClick={() => {
              window.location.href = '/dashboard/directeur/broadcast';
            }}
          >
            <MessageSquare className="ml-2 h-4 w-4" />
            Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ©
          </Button>
        )}
      </div>
      <div className="grid grid-cols-1 md:grid-cols-[280px_1fr] lg:grid-cols-[320px_1fr] flex-1 min-h-0 overflow-hidden">
        {/* Partners List */}
        <div className="border-l flex flex-col bg-muted/30">
          <div className="p-3">
            <Input placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„..." className="bg-background" />
          </div>
          <Separator />
          <ScrollArea className="flex-1">
            <div className="flex flex-col gap-0 p-2">
              {partners.map((partner) => {
                const partnerMessages = messages.filter(
                  (m) => m.senderId === partner.id || m.recipientId === partner.id
                );
                const lastMessage = partnerMessages[partnerMessages.length - 1];
                const unreadCount = partnerMessages.filter(
                  (m) => m.recipientId === currentUserId && !m.isRead
                ).length;

                return (
                  <button
                    key={partner.id}
                    onClick={() => setSelectedPartnerId(partner.id)}
                    className={cn(
                      "flex flex-col items-start gap-2 rounded-lg border border-transparent p-3 text-right transition-all hover:bg-accent",
                      partner.id === selectedPartnerId && "bg-accent border-border"
                    )}
                  >
                    <div className="flex w-full items-center gap-3">
                      <Avatar className="h-10 w-10">
                        <AvatarImage src={partner.image || undefined} alt={partner.name} />
                        <AvatarFallback>{partner.name.charAt(0)}</AvatarFallback>
                      </Avatar>
                      <div className="flex-1 truncate text-right">
                        <div className="font-semibold">{partner.name}</div>
                        {lastMessage && (
                          <div className="text-xs text-muted-foreground truncate">
                            {lastMessage.content}
                          </div>
                        )}
                      </div>
                      <div className="flex flex-col items-end gap-1">
                        {lastMessage && (
                          <div className="text-xs text-muted-foreground whitespace-nowrap">
                            {formatDistanceToNow(new Date(lastMessage.createdAt), {
                              addSuffix: true,
                              locale: ar,
                            })}
                          </div>
                        )}
                        {unreadCount > 0 && (
                          <div className="bg-destructive text-destructive-foreground text-xs rounded-full h-5 min-w-5 flex items-center justify-center px-1.5">
                            {unreadCount}
                          </div>
                        )}
                      </div>
                    </div>
                  </button>
                );
              })}
            </div>
          </ScrollArea>
        </div>

        {/* Conversation */}
        {selectedPartner ? (
          <div className="flex flex-col h-full overflow-hidden">
            <div className="flex items-center gap-4 p-4 border-b bg-muted/30">
              <Avatar className="h-10 w-10">
                <AvatarImage src={selectedPartner.image || undefined} alt={selectedPartner.name} />
                <AvatarFallback>{selectedPartner.name.charAt(0)}</AvatarFallback>
              </Avatar>
              <div>
                <div className="font-semibold">{selectedPartner.name}</div>
              </div>
            </div>
            <div className="flex-1 overflow-y-auto p-4" ref={scrollRef}>
              <div className="space-y-4 min-h-full">
                {selectedConversation.map((message) => {
                  const isMe = message.senderId === currentUserId;
                  return (
                    <div
                      key={message.id}
                      className={cn(
                        "flex items-end gap-2",
                        isMe ? "justify-end" : "justify-start"
                      )}
                    >
                      {!isMe && (
                        <Avatar className="h-8 w-8 flex-shrink-0">
                          <AvatarImage src={selectedPartner.image || undefined} />
                          <AvatarFallback>{selectedPartner.name.charAt(0)}</AvatarFallback>
                        </Avatar>
                      )}
                      <div
                        className={cn(
                          "max-w-[70%] rounded-lg p-3",
                          isMe
                            ? "bg-primary text-primary-foreground"
                            : "bg-muted"
                        )}
                      >
                        <p className="text-sm leading-relaxed">{message.content}</p>
                        <p
                          className={cn(
                            "text-xs mt-1",
                            isMe
                              ? "text-primary-foreground/70"
                              : "text-muted-foreground"
                          )}
                        >
                          {formatDistanceToNow(new Date(message.createdAt), {
                            addSuffix: true,
                            locale: ar,
                          })}
                        </p>
                      </div>
                      {isMe && (
                        <Avatar className="h-8 w-8 flex-shrink-0">
                          <AvatarImage src={session?.user?.image || undefined} />
                          <AvatarFallback>{session?.user?.name?.charAt(0)}</AvatarFallback>
                        </Avatar>
                      )}
                    </div>
                  );
                })}
                {selectedConversation.length === 0 && (
                  <div className="text-center text-muted-foreground py-12">
                    <p>Ø§Ø¨Ø¯Ø£ Ù…Ø­Ø§Ø¯Ø«Ø© Ù…Ø¹ {selectedPartner.name}</p>
                  </div>
                )}
              </div>
            </div>
            <div className="p-4 border-t bg-background">
              <form onSubmit={handleSendMessage} className="flex gap-2 items-end">
                <Textarea
                  placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ..."
                  className="resize-none flex-1"
                  rows={2}
                  value={messageText}
                  onChange={(e) => setMessageText(e.target.value)}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                      e.preventDefault();
                      handleSendMessage(e);
                    }
                  }}
                />
                <Button type="submit" size="icon" className="h-10 w-10" disabled={isSending || !messageText.trim()}>
                  {isSending ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <Send className="h-4 w-4" />
                  )}
                </Button>
              </form>
            </div>
          </div>
        ) : (
          <div className="flex items-center justify-center h-full">
            <div className="text-center text-muted-foreground">
              <MessageSquare className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p>Ø§Ø®ØªØ± Ù…Ø­Ø§Ø¯Ø«Ø© Ù„Ù„Ø¨Ø¯Ø¡</p>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/logs/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { 
  Table, 
  TableBody, 
  TableCell, 
  TableHead, 
  TableHeader, 
  TableRow 
} from '@/components/ui/table';
import { 
  FileText, 
  RefreshCw, 
  Search, 
  Filter,
  CheckCircle2,
  AlertTriangle,
  XCircle,
  Info,
  Bug
} from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { formatDistanceToNow } from 'date-fns';
import { ar } from 'date-fns/locale';

interface Log {
  id: string;
  level: string;
  category: string;
  action: string;
  userId: string | null;
  targetId: string | null;
  details: string | null;
  timestamp: string;
  user: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
  } | null;
}

const LOG_LEVELS = ['INFO', 'SUCCESS', 'WARNING', 'ERROR', 'DEBUG'];
const LOG_CATEGORIES = [
  'AUTH', 'USER', 'LESSON', 'EXERCISE', 'SUBMISSION',
  'MESSAGE', 'NOTIFICATION', 'BACKUP', 'SYSTEM', 'AI'
];

const levelConfig = {
  SUCCESS: { color: 'default', icon: CheckCircle2, label: 'Ù†Ø¬Ø§Ø­' },
  INFO: { color: 'secondary', icon: Info, label: 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª' },
  WARNING: { color: 'warning', icon: AlertTriangle, label: 'ØªØ­Ø°ÙŠØ±' },
  ERROR: { color: 'destructive', icon: XCircle, label: 'Ø®Ø·Ø£' },
  DEBUG: { color: 'outline', icon: Bug, label: 'ØªØµØ­ÙŠØ­' },
};

const categoryLabels: Record<string, string> = {
  AUTH: 'Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©',
  USER: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†',
  LESSON: 'Ø§Ù„Ø¯Ø±ÙˆØ³',
  EXERCISE: 'Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†',
  SUBMISSION: 'Ø§Ù„ØªØ³Ù„ÙŠÙ…Ø§Øª',
  MESSAGE: 'Ø§Ù„Ø±Ø³Ø§Ø¦Ù„',
  NOTIFICATION: 'Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª',
  BACKUP: 'Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ',
  SYSTEM: 'Ø§Ù„Ù†Ø¸Ø§Ù…',
  AI: 'Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ'
};

export default function LogsPage() {
  const [logs, setLogs] = useState<Log[]>([]);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(1);
  const [loading, setLoading] = useState(false);
  const [filters, setFilters] = useState({
    level: '',
    category: '',
    search: ''
  });
  const { toast } = useToast();

  useEffect(() => {
    fetchLogs();
  }, [page, filters]);

  const fetchLogs = async () => {
    try {
      setLoading(true);
      const params = new URLSearchParams({
        limit: '50',
        offset: ((page - 1) * 50).toString(),
      });

      if (filters.level) params.append('level', filters.level);
      if (filters.category) params.append('category', filters.category);

      const response = await fetch(`/api/logs?${params}`);
      if (response.ok) {
        const data = await response.json();
        setLogs(data.logs);
        setTotal(data.total);
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¬Ù„Ø§Øª',
        variant: 'destructive'
      });
    } finally {
      setLoading(false);
    }
  };

  const getLevelIcon = (level: string) => {
    const config = levelConfig[level as keyof typeof levelConfig];
    const Icon = config?.icon || Info;
    return <Icon className="h-4 w-4" />;
  };

  const getLevelBadge = (level: string) => {
    const config = levelConfig[level as keyof typeof levelConfig];
    return (
      <Badge variant={config?.color as any || 'default'} className="gap-1">
        {getLevelIcon(level)}
        {config?.label || level}
      </Badge>
    );
  };

  const parseDetails = (details: string | null) => {
    if (!details) return null;
    try {
      return JSON.parse(details);
    } catch {
      return details;
    }
  };

  return (
    <div className="container mx-auto p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold flex items-center gap-2">
            <FileText className="h-8 w-8" />
            Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…
          </h1>
          <p className="text-muted-foreground mt-2">
            Ù…Ø±Ø§Ù‚Ø¨Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù†Ø´Ø·Ø© ÙˆØ§Ù„Ø£Ø­Ø¯Ø§Ø« ÙÙŠ Ø§Ù„Ù…Ù†ØµØ©
          </p>
        </div>
        <Button variant="outline" onClick={fetchLogs} disabled={loading}>
          <RefreshCw className={`h-4 w-4 ml-2 ${loading ? 'animate-spin' : ''}`} />
          ØªØ­Ø¯ÙŠØ«
        </Button>
      </div>

      {/* Filters */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Filter className="h-5 w-5" />
            Ø§Ù„ÙÙ„Ø§ØªØ±
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
              <label className="text-sm font-medium mb-2 block">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</label>
              <Select 
                value={filters.level} 
                onValueChange={(value) => {
                  setFilters({ ...filters, level: value });
                  setPage(1);
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</SelectItem>
                  {LOG_LEVELS.map(level => (
                    <SelectItem key={level} value={level}>
                      {levelConfig[level as keyof typeof levelConfig]?.label || level}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div>
              <label className="text-sm font-medium mb-2 block">Ø§Ù„ÙØ¦Ø©</label>
              <Select 
                value={filters.category} 
                onValueChange={(value) => {
                  setFilters({ ...filters, category: value });
                  setPage(1);
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ¦Ø§Øª" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="">Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙØ¦Ø§Øª</SelectItem>
                  {LOG_CATEGORIES.map(category => (
                    <SelectItem key={category} value={category}>
                      {categoryLabels[category] || category}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div>
              <label className="text-sm font-medium mb-2 block">Ø¨Ø­Ø«</label>
              <div className="relative">
                <Search className="absolute right-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª..."
                  value={filters.search}
                  onChange={(e) => setFilters({ ...filters, search: e.target.value })}
                  className="pr-10"
                />
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Logs Table */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div>
              <CardTitle>Ø§Ù„Ø³Ø¬Ù„Ø§Øª</CardTitle>
              <CardDescription>
                Ø¥Ø¬Ù…Ø§Ù„ÙŠ {total} Ø³Ø¬Ù„ - Ø§Ù„ØµÙØ­Ø© {page} Ù…Ù† {Math.ceil(total / 50)}
              </CardDescription>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="text-center py-8 text-muted-foreground">
              Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...
            </div>
          ) : logs.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <FileText className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø³Ø¬Ù„Ø§Øª</p>
            </div>
          ) : (
            <>
              <div className="overflow-x-auto">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-[140px]">Ø§Ù„ÙˆÙ‚Øª</TableHead>
                      <TableHead className="w-[120px]">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</TableHead>
                      <TableHead className="w-[140px]">Ø§Ù„ÙØ¦Ø©</TableHead>
                      <TableHead>Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡</TableHead>
                      <TableHead>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</TableHead>
                      <TableHead className="w-[100px]">Ø§Ù„ØªÙØ§ØµÙŠÙ„</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {logs
                      .filter(log => 
                        !filters.search || 
                        log.action.toLowerCase().includes(filters.search.toLowerCase())
                      )
                      .map((log) => {
                        const details = parseDetails(log.details);
                        
                        return (
                          <TableRow key={log.id}>
                            <TableCell className="text-sm text-muted-foreground">
                              {formatDistanceToNow(new Date(log.timestamp), {
                                addSuffix: true,
                                locale: ar
                              })}
                            </TableCell>
                            <TableCell>
                              {getLevelBadge(log.level)}
                            </TableCell>
                            <TableCell>
                              <Badge variant="outline">
                                {categoryLabels[log.category] || log.category}
                              </Badge>
                            </TableCell>
                            <TableCell className="font-medium">
                              {log.action}
                            </TableCell>
                            <TableCell>
                              {log.user ? (
                                <div className="text-sm">
                                  <div className="font-medium">
                                    {log.user.firstName} {log.user.lastName}
                                  </div>
                                  <div className="text-muted-foreground">
                                    {log.user.email}
                                  </div>
                                </div>
                              ) : (
                                <span className="text-muted-foreground">Ø§Ù„Ù†Ø¸Ø§Ù…</span>
                              )}
                            </TableCell>
                            <TableCell>
                              {details && (
                                <details className="text-xs">
                                  <summary className="cursor-pointer text-primary">
                                    Ø¹Ø±Ø¶
                                  </summary>
                                  <pre className="mt-2 p-2 bg-muted rounded text-xs overflow-x-auto">
                                    {JSON.stringify(details, null, 2)}
                                  </pre>
                                </details>
                              )}
                            </TableCell>
                          </TableRow>
                        );
                      })}
                  </TableBody>
                </Table>
              </div>

              {/* Pagination */}
              <div className="flex items-center justify-between mt-4">
                <Button
                  variant="outline"
                  onClick={() => setPage(p => Math.max(1, p - 1))}
                  disabled={page === 1 || loading}
                >
                  Ø§Ù„Ø³Ø§Ø¨Ù‚
                </Button>
                <span className="text-sm text-muted-foreground">
                  Ø§Ù„ØµÙØ­Ø© {page} Ù…Ù† {Math.ceil(total / 50)}
                </span>
                <Button
                  variant="outline"
                  onClick={() => setPage(p => p + 1)}
                  disabled={page >= Math.ceil(total / 50) || loading}
                >
                  Ø§Ù„ØªØ§Ù„ÙŠ
                </Button>
              </div>
            </>
          )}
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/_components/DirecteurDashboard.tsx
// ==========================================


'use client';

import { useState, useEffect } from "react";
import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Users, BookCopy, BarChart3, Database, Settings, Loader2 } from "lucide-react";
import Link from "next/link";
import { useSession } from "next-auth/react";

interface DirecteurStats {
    totalUsers: number;
    students: number;
    teachers: number;
    parents: number;
    lessons: number;
    subjects: number;
}

export default function DirecteurDashboard() {
    const { data: session } = useSession();
    const [stats, setStats] = useState<DirecteurStats>({
        totalUsers: 0,
        students: 0,
        teachers: 0,
        parents: 0,
        lessons: 0,
        subjects: 0,
    });
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchStats = async () => {
            try {
                const response = await fetch('/api/directeur/stats');
                const result = await response.json();
                
                if (result.success) {
                    setStats(result.data);
                }
            } catch (error) {
                console.error('Error fetching stats:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchStats();
    }, []);

    if (loading) {
        return (
            <div className="flex items-center justify-center min-h-[400px]">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
        );
    }

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">
                        Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ {session?.user?.name}!
                    </h1>
                    <p className="text-muted-foreground">
                        Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©.
                    </p>
                </div>
            </div>

            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5">
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.totalUsers}</div>
                        <p className="text-xs text-muted-foreground">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¯ÙˆØ§Ø±</p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ù…Ø¹Ù„Ù…ÙˆÙ† ÙˆØ§Ù„Ù…Ø´Ø±ÙÙˆÙ†</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.teachers}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ø§Ù‚Ù… Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ</p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø·Ù„Ø§Ø¨</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.students}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ†</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø¯Ø±ÙˆØ³</CardTitle>
                        <BookCopy className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.lessons}</div>
                         <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…Ù†Ø´Ø£Ø©</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</CardTitle>
                        <BarChart3 className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.subjects}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù…ØªØ§Ø­Ø©</p>
                    </CardContent>
                </Card>
            </div>

            <div className="grid gap-6">
                 <Card>
                    <CardHeader>
                        <CardTitle>Ø±ÙˆØ§Ø¨Ø· Ø³Ø±ÙŠØ¹Ø©</CardTitle>
                        <CardDescription>ÙˆØµÙˆÙ„ Ø³Ø±ÙŠØ¹ Ù„Ø£Ù‚Ø³Ø§Ù… Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.</CardDescription>
                    </CardHeader>
                    <CardContent className="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <Button variant="secondary" className="justify-start w-full" asChild>
                            <Link href="/dashboard/directeur/users"><Users className="ml-2"/>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</Link>
                        </Button>
                        <Button variant="secondary" className="justify-start w-full" asChild>
                            <Link href="/dashboard/directeur/content"><BookCopy className="ml-2"/>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰</Link>
                        </Button>
                        <Button variant="secondary" className="justify-start w-full" asChild>
                            <Link href="/dashboard/directeur/database"><Database className="ml-2"/>Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</Link>
                        </Button>
                         <Button variant="secondary" className="justify-start w-full" asChild>
                            <Link href="/dashboard/directeur/settings"><Settings className="ml-2"/>Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</Link>
                        </Button>
                    </CardContent>
                </Card>
            </div>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/content/_components/AddEditStageDialog.tsx
// ==========================================

'use client';

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import type { Stage } from "@/lib/types";
import { useState, useEffect } from "react";

interface AddEditStageDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (stage: Omit<Stage, 'id'> | Stage) => void;
  stageToEdit?: Stage | null;
}

export default function AddEditStageDialog({
  isOpen,
  onClose,
  onSave,
  stageToEdit,
}: AddEditStageDialogProps) {
  const [name, setName] = useState("");
  const [order, setOrder] = useState(0);

  useEffect(() => {
    if (stageToEdit) {
      setName(stageToEdit.name);
      setOrder(stageToEdit.order);
    } else {
      setName("");
      setOrder(0);
    }
  }, [stageToEdit, isOpen]);

  const handleSave = () => {
    if (name && order > 0) {
      if (stageToEdit) {
        onSave({ ...stageToEdit, name, order });
      } else {
        onSave({ name, order });
      }
      onClose();
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{stageToEdit ? 'ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø±Ø­Ù„Ø©' : 'Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø­Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©'}</DialogTitle>
          <DialogDescription>
            {stageToEdit ? 'Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø±Ø­Ù„Ø©.' : 'Ø£Ø¯Ø®Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©.'}
          </DialogDescription>
        </DialogHeader>
        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label htmlFor="stage-name">Ø§Ø³Ù… Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
            <Input
              id="stage-name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Ù…Ø«Ø§Ù„: Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ… Ø§Ù„Ø¥Ø¨ØªØ¯Ø§Ø¦ÙŠ"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="stage-order">Ø§Ù„ØªØ±ØªÙŠØ¨</Label>
            <Input
              id="stage-order"
              type="number"
              value={order}
              onChange={(e) => setOrder(Number(e.target.value))}
              placeholder="Ù…Ø«Ø§Ù„: 1"
            />
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Ø¥Ù„ØºØ§Ø¡</Button>
          <Button onClick={handleSave}>Ø­ÙØ¸</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/content/_components/DeleteConfirmationDialog.tsx
// ==========================================

'use client';

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";

interface DeleteConfirmationDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  itemName: string;
  itemType: string;
}

export default function DeleteConfirmationDialog({
  isOpen,
  onClose,
  onConfirm,
  itemName,
  itemType
}: DeleteConfirmationDialogProps) {
  return (
    <AlertDialog open={isOpen} onOpenChange={onClose}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ ØªÙ…Ø§Ù…Ø§Ù‹ØŸ</AlertDialogTitle>
          <AlertDialogDescription>
            Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡. Ø³ÙŠØªÙ… Ø­Ø°Ù {itemType} "{itemName}" Ø¨Ø´ÙƒÙ„ Ù†Ù‡Ø§Ø¦ÙŠ.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel>Ø¥Ù„ØºØ§Ø¡</AlertDialogCancel>
          <AlertDialogAction onClick={onConfirm} asChild>
            <Button variant="destructive">Ù†Ø¹Ù…ØŒ Ù‚Ù… Ø¨Ø§Ù„Ø­Ø°Ù</Button>
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/content/_components/AddEditSubjectDialog.tsx
// ==========================================


'use client';

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import type { Subject, Stage, Level } from "@/lib/types";
import { useState, useEffect } from "react";
import { Textarea } from "@/components/ui/textarea";

interface AddEditSubjectDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (data: any) => void;
  subjectToEdit?: Subject | null;
  stages: Stage[];
  levels: Level[];
}

export default function AddEditSubjectDialog({
  isOpen,
  onClose,
  onSave,
  subjectToEdit,
  stages,
  levels,
}: AddEditSubjectDialogProps) {
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [stageId, setStageId] = useState<string | undefined>(undefined);
  const [selectedLevelIds, setSelectedLevelIds] = useState<string[]>([]);

  // Filter levels by selected stage (stageId in camelCase from API)
  const filteredLevels = Array.isArray(levels) ? levels.filter(l => l && l.id && String(l.stageId) === stageId) : [];

  useEffect(() => {
    if (subjectToEdit) {
      setName(subjectToEdit.name);
      setDescription(subjectToEdit.description);
      // Support both camelCase and snake_case
      const subjectStageId = subjectToEdit.stageId || (subjectToEdit as any).stage_id;
      setStageId(subjectStageId ? String(subjectStageId) : undefined);

      // Populate selected levels for edit mode
      let initialLevels: string[] = [];
      if (subjectToEdit.levels && Array.isArray(subjectToEdit.levels)) {
        initialLevels = subjectToEdit.levels.map((l: any) => String(l.id));
      } else if (subjectToEdit.levelIds && Array.isArray(subjectToEdit.levelIds)) {
        initialLevels = subjectToEdit.levelIds.map(String);
      } else {
        const subjectLevelId = subjectToEdit.levelId || (subjectToEdit as any).level_id;
        if (subjectLevelId) initialLevels.push(String(subjectLevelId));
      }
      setSelectedLevelIds(initialLevels);
    } else {
      setName("");
      setDescription("");
      setStageId(undefined);
      setSelectedLevelIds([]);
    }
  }, [subjectToEdit, isOpen]);

  const handleSave = () => {
    const subjectData = {
      name,
      description,
      stageId: stageId ? Number(stageId) : undefined,
      levelIds: selectedLevelIds.map(Number),
    };
    if (name) {
      let payload;
      if (subjectToEdit) {
        payload = {
          id: subjectToEdit.id,
          ...subjectData,
        };
      } else {
        payload = subjectData;
      }
      onSave(payload);
      onClose();
    }
  };

  const toggleLevel = (id: string) => {
    setSelectedLevelIds(prev =>
      prev.includes(id)
        ? prev.filter(item => item !== id)
        : [...prev, id]
    );
  };

  const toggleAllLevels = () => {
    if (selectedLevelIds.length === filteredLevels.length) {
      setSelectedLevelIds([]);
    } else {
      setSelectedLevelIds(filteredLevels.map(l => String(l.id)));
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{subjectToEdit ? 'ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø§Ø¯Ø©' : 'Ø¥Ø¶Ø§ÙØ© Ù…Ø§Ø¯Ø© Ø¬Ø¯ÙŠØ¯Ø©'}</DialogTitle>
          <DialogDescription>
            {subjectToEdit ? 'Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø§Ø¯Ø©.' : 'Ø£Ø¯Ø®Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø§Ø¯Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©.'}
          </DialogDescription>
        </DialogHeader>
        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label htmlFor="subject-name">Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
            <Input
              id="subject-name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Ù…Ø«Ø§Ù„: Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª"
            />
          </div>
           <div className="space-y-2">
            <Label htmlFor="subject-description">ÙˆØµÙ Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
            <Textarea
              id="subject-description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Ù…Ø«Ø§Ù„: Ù…Ø§Ø¯Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©"
            />
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
                <Label htmlFor="stage-select">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                <Select value={stageId} onValueChange={(val) => { setStageId(val); setSelectedLevelIds([]); }}>
                    <SelectTrigger id="stage-select">
                        <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                        {Array.isArray(stages) && stages.filter(s => s && s.id).map(stage => (
                            <SelectItem key={stage.id} value={String(stage.id)}>{stage.name}</SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>
             <div className="space-y-2">
                <Label htmlFor="level-select">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</Label>
                  <div className="border rounded-md p-3 max-h-[150px] overflow-y-auto space-y-2 bg-white">
                    <div className="flex items-center gap-2">
                      <input
                        type="checkbox"
                        id="select-all"
                        checked={filteredLevels.length > 0 && selectedLevelIds.length === filteredLevels.length}
                        onChange={toggleAllLevels}
                        disabled={!stageId || filteredLevels.length === 0}
                        className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary cursor-pointer"
                      />
                      <label htmlFor="select-all" className="text-sm font-medium leading-none cursor-pointer">
                        ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙƒÙ„
                      </label>
                    </div>
                    <div className="h-px bg-gray-200 my-2" />
                    {filteredLevels.length === 0 ? (
                      <p className="text-sm text-muted-foreground text-center py-2">Ø§Ø®ØªØ± Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹</p>
                    ) : (
                      filteredLevels.map((level) => (
                        <div key={level.id} className="flex items-center gap-2">
                          <input
                            type="checkbox"
                            id={`level-${level.id}`}
                            checked={selectedLevelIds.includes(String(level.id))}
                            onChange={() => toggleLevel(String(level.id))}
                            className="h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary cursor-pointer"
                          />
                          <label
                            htmlFor={`level-${level.id}`}
                            className="text-sm leading-none cursor-pointer"
                          >
                            {level.name}
                          </label>
                        </div>
                      ))
                    )}
                  </div>
            </div>
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Ø¥Ù„ØºØ§Ø¡</Button>
          <Button onClick={handleSave}>Ø­ÙØ¸</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/content/_components/AddEditLevelDialog.tsx
// ==========================================

'use client';

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import type { Level } from "@/lib/types";
import { useState, useEffect } from "react";

interface AddEditLevelDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (level: Omit<Level, 'id' | 'stage_id'> | Level) => void;
  levelToEdit?: Level | null;
}

export default function AddEditLevelDialog({
  isOpen,
  onClose,
  onSave,
  levelToEdit,
}: AddEditLevelDialogProps) {
  const [name, setName] = useState("");
  const [order, setOrder] = useState(0);

  useEffect(() => {
    if (levelToEdit) {
      setName(levelToEdit.name);
      setOrder(levelToEdit.order);
    } else {
      setName("");
      setOrder(0);
    }
  }, [levelToEdit, isOpen]);

  const handleSave = () => {
    if (name && order > 0) {
      if (levelToEdit) {
        onSave({ ...levelToEdit, name, order });
      } else {
        onSave({ name, order });
      }
      onClose();
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{levelToEdit ? 'ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰' : 'Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯'}</DialogTitle>
          <DialogDescription>
            {levelToEdit ? 'Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰.' : 'Ø£Ø¯Ø®Ù„ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¬Ø¯ÙŠØ¯.'}
          </DialogDescription>
        </DialogHeader>
        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label htmlFor="level-name">Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªÙˆÙ‰</Label>
            <Input
              id="level-name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              placeholder="Ù…Ø«Ø§Ù„: Ø§Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="level-order">Ø§Ù„ØªØ±ØªÙŠØ¨</Label>
            <Input
              id="level-order"
              type="number"
              value={order}
              onChange={(e) => setOrder(Number(e.target.value))}
              placeholder="Ù…Ø«Ø§Ù„: 1"
            />
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>Ø¥Ù„ØºØ§Ø¡</Button>
          <Button onClick={handleSave}>Ø­ÙØ¸</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/content/page.tsx
// ==========================================


'use client';

import { useState, useMemo } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from "@/components/ui/tabs";
import {
    Accordion,
    AccordionContent,
    AccordionItem,
    AccordionTrigger,
} from "@/components/ui/accordion"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

import { BookCopy, PlusCircle, FilePenLine, Trash2, GraduationCap, Layers, Loader2 } from "lucide-react";
import type { Subject } from "@/lib/types";
import { useStages, useLevels, useSubjects } from "@/hooks";
import { useToast } from "@/hooks/use-toast";

import AddEditStageDialog from "./_components/AddEditStageDialog";
import AddEditLevelDialog from "./_components/AddEditLevelDialog";
import AddEditSubjectDialog from "./_components/AddEditSubjectDialog";
import DeleteConfirmationDialog from "./_components/DeleteConfirmationDialog";

export default function ContentManagementPage() {
    const { toast } = useToast();
    
    const { stages, isLoading: stagesLoading, createStage, updateStage, deleteStage } = useStages();
    const { levels, isLoading: levelsLoading, createLevel, updateLevel, deleteLevel } = useLevels();
    const { subjects, isLoading: subjectsLoading, createSubject, updateSubject, deleteSubject } = useSubjects();
    
    // Memoize accordion default value
    const defaultAccordionValue = useMemo(() => {
        if (!Array.isArray(stages) || stages.length === 0) return [];
        return stages
            .filter(s => s && typeof s.id !== 'undefined')
            .map(s => `stage-${s.id}`);
    }, [stages]);

    const [isStageDialogOpen, setStageDialogOpen] = useState(false);
    const [stageToEdit, setStageToEdit] = useState<Stage | null>(null);

    const [isLevelDialogOpen, setLevelDialogOpen] = useState(false);
    const [levelToEdit, setLevelToEdit] = useState<Level | null>(null);
    const [currentStageId, setCurrentStageId] = useState<number | null>(null);
    
    const [isSubjectDialogOpen, setSubjectDialogOpen] = useState(false);
    const [subjectToEdit, setSubjectToEdit] = useState<Subject | null>(null);

    const [itemToDelete, setItemToDelete] = useState<{ id: number | number[]; name: string; type: 'stage' | 'level' | 'subject' } | null>(null);


    const handleOpenAddStage = () => {
        setStageToEdit(null);
        setStageDialogOpen(true);
    };

    const handleOpenEditStage = (stage: any) => {
        // Convert displayOrder to order for dialog
        setStageToEdit({ ...stage, order: stage.displayOrder });
        setStageDialogOpen(true);
    };

    const handleSaveStage = async (stageData: any) => {
        if ('id' in stageData) {
            const result = await updateStage({
                id: stageData.id,
                name: stageData.name,
                displayOrder: stageData.order
            });
            if (result.success) {
                toast({ title: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­" });
            } else {
                toast({ title: "ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø±Ø­Ù„Ø©", variant: "destructive" });
            }
        } else {
            const result = await createStage({
                name: stageData.name,
                displayOrder: stageData.order
            });
            if (result.success) {
                toast({ title: "ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­" });
            } else {
                toast({ title: "ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø±Ø­Ù„Ø©", variant: "destructive" });
            }
        }
    };

    const handleOpenAddLevel = (stageId: number) => {
        setLevelToEdit(null);
        setCurrentStageId(stageId);
        setLevelDialogOpen(true);
    };

    const handleOpenEditLevel = (level: any) => {
        // Convert displayOrder to order and stageId to stage_id for dialog
        setLevelToEdit({ ...level, order: level.displayOrder, stage_id: level.stageId });
        setCurrentStageId(level.stageId);
        setLevelDialogOpen(true);
    }
    
    const handleSaveLevel = async (levelData: any) => {
        if ('id' in levelData) {
            const result = await updateLevel({
                id: levelData.id,
                name: levelData.name,
                stageId: levelData.stageId || currentStageId!,
                displayOrder: levelData.order
            });
            if (result.success) {
                toast({ title: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¨Ù†Ø¬Ø§Ø­" });
            } else {
                toast({ title: "ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªÙˆÙ‰", variant: "destructive" });
            }
        } else {
            if (currentStageId) {
                const result = await createLevel({
                    name: levelData.name,
                    stageId: currentStageId,
                    displayOrder: levelData.order
                });
                if (result.success) {
                    toast({ title: "ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¨Ù†Ø¬Ø§Ø­" });
                } else {
                    toast({ title: "ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªÙˆÙ‰", variant: "destructive" });
                }
            }
        }
    };
    
    const handleOpenAddSubject = () => {
        setSubjectToEdit(null);
        setSubjectDialogOpen(true);
    };

    const handleOpenEditSubject = (subject: Subject) => {
        setSubjectToEdit(subject);
        setSubjectDialogOpen(true);
    };

    const handleSaveSubject = async (subjectData: any) => {
        if ('id' in subjectData) {
            const result = await updateSubject(subjectData);
            if (result.success) {
                toast({ title: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­" });
            } else {
                toast({ title: "ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø§Ø¯Ø©", variant: "destructive" });
            }
        } else {
            const result = await createSubject(subjectData);
            if (result.success) {
                toast({ title: "ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­" });
            } else {
                toast({ title: "ÙØ´Ù„ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø§Ø¯Ø©", variant: "destructive" });
            }
        }
    };

    const handleDeleteClick = (item: { id: number | number[]; name: string; type: 'stage' | 'level' | 'subject' }) => {
        setItemToDelete(item);
    };
    
    const handleConfirmDelete = async () => {
        if (itemToDelete) {
            switch (itemToDelete.type) {
                case 'stage':
                    const stageResult = await deleteStage(itemToDelete.id as number);
                    if (stageResult.success) {
                        toast({ title: "ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­" });
                    } else {
                        toast({ title: "ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø±Ø­Ù„Ø©", variant: "destructive" });
                    }
                    break;
                case 'level':
                    const levelResult = await deleteLevel(itemToDelete.id as number);
                    if (levelResult.success) {
                        toast({ title: "ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¨Ù†Ø¬Ø§Ø­" });
                    } else {
                        toast({ title: "ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆÙ‰", variant: "destructive" });
                    }
                    break;
                case 'subject':
                    if (Array.isArray(itemToDelete.id)) {
                        // Bulk delete for grouped subjects
                        let successCount = 0;
                        for (const id of itemToDelete.id) {
                            const res = await deleteSubject(id);
                            if (res.success) successCount++;
                        }
                        if (successCount > 0) toast({ title: `ØªÙ… Ø­Ø°Ù ${successCount} Ù…Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­` });
                        else toast({ title: "ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…ÙˆØ§Ø¯", variant: "destructive" });
                    } else {
                        const subjectResult = await deleteSubject(itemToDelete.id as number);
                        if (subjectResult.success) {
                            toast({ title: "ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­" });
                        } else {
                            toast({ title: "ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø§Ø¯Ø©", variant: "destructive" });
                        }
                    }
                    break;
            }
            setItemToDelete(null);
        }
    };

    // Group subjects by name and stage
    const groupedSubjects = useMemo(() => {
        if (!Array.isArray(subjects)) return [];
        const groups: Record<string, any> = {};
        
        subjects.forEach(subject => {
            const stageId = subject.stageId || subject.stage_id;
            const key = `${subject.name}-${stageId}`;
            
            if (!groups[key]) {
                groups[key] = {
                    ...subject,
                    _levels: [],
                    _ids: []
                };
            }
            
            if (subject.levels && Array.isArray(subject.levels)) {
                subject.levels.forEach((lvl: any) => {
                    if (!groups[key]._levels.some((l: any) => l.id === lvl.id)) {
                        groups[key]._levels.push(lvl);
                    }
                });
            }
            groups[key]._ids.push(subject.id);
        });
        
        return Object.values(groups);
    }, [subjects]);

    // Show loading state
    if (stagesLoading || levelsLoading || subjectsLoading) {
        return (
            <div className="flex items-center justify-center h-96">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
        );
    }

    // Ensure data is loaded
    if (!stages || !levels || !subjects) {
        return (
            <div className="flex items-center justify-center h-96">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
        );
    }

    return (
        <div className="flex flex-col gap-8">
            <AddEditStageDialog
                isOpen={isStageDialogOpen}
                onClose={() => setStageDialogOpen(false)}
                onSave={handleSaveStage}
                stageToEdit={stageToEdit}
            />
            <AddEditLevelDialog
                isOpen={isLevelDialogOpen}
                onClose={() => setLevelDialogOpen(false)}
                onSave={handleSaveLevel}
                levelToEdit={levelToEdit}
            />
             <AddEditSubjectDialog
                isOpen={isSubjectDialogOpen}
                onClose={() => setSubjectDialogOpen(false)}
                onSave={handleSaveSubject}
                subjectToEdit={subjectToEdit}
                stages={stages}
                levels={levels}
            />
            {itemToDelete && (
                <DeleteConfirmationDialog
                    isOpen={!!itemToDelete}
                    onClose={() => setItemToDelete(null)}
                    onConfirm={handleConfirmDelete}
                    itemName={itemToDelete.name}
                    itemType={
                        itemToDelete.type === 'stage' ? 'Ø§Ù„Ù…Ø±Ø­Ù„Ø©' :
                        itemToDelete.type === 'level' ? 'Ø§Ù„Ù…Ø³ØªÙˆÙ‰' : 'Ø§Ù„Ù…Ø§Ø¯Ø©'
                    }
                />
            )}

            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰</h1>
                    <p className="text-muted-foreground">
                        Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØ§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª ÙˆØ§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© Ù„Ù„Ù…Ù†ØµØ©.
                    </p>
                </div>
            </div>

            <Tabs defaultValue="stages">
                <TabsList className="grid w-full grid-cols-2">
                    <TabsTrigger value="stages">Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØ§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</TabsTrigger>
                    <TabsTrigger value="subjects">Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</TabsTrigger>
                </TabsList>

                <TabsContent value="stages">
                    <Card>
                        <CardHeader>
                            <CardTitle>Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ ÙˆØ§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</CardTitle>
                            <CardDescription>
                                Ø¹Ø±Ø¶ ÙˆØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ© ÙˆØ§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø© Ø¨Ù‡Ø§.
                            </CardDescription>
                        </CardHeader>
                        <CardContent>
                            <Accordion type="multiple" defaultValue={defaultAccordionValue} className="w-full">
                                {Array.isArray(stages) && stages.filter(s => s && s.id).sort((a,b) => a.displayOrder - b.displayOrder).map(stage => {
                                    const stageLevels = Array.isArray(levels) ? levels.filter(l => l && l.stageId === stage.id).sort((a,b) => a.displayOrder - b.displayOrder) : [];
                                    return (
                                        <AccordionItem key={stage.id} value={`stage-${stage.id}`}>
                                            <div className="flex items-center gap-4 justify-between w-full">
                                                <AccordionTrigger className="text-lg font-semibold hover:no-underline flex-1">
                                                    <div className="flex items-center gap-2">
                                                        <GraduationCap className="h-5 w-5 text-primary"/>
                                                        {stage.name}
                                                    </div>
                                                </AccordionTrigger>
                                                <div className="flex items-center gap-2">
                                                    <Button variant="ghost" size="icon" title="ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø±Ø­Ù„Ø©" onClick={() => handleOpenEditStage(stage)}>
                                                        <FilePenLine className="h-4 w-4"/>
                                                    </Button>
                                                    <Button variant="ghost" size="icon" title="Ø­Ø°Ù Ø§Ù„Ù…Ø±Ø­Ù„Ø©" className="text-destructive hover:text-destructive" onClick={() => handleDeleteClick({ id: stage.id, name: stage.name, type: 'stage' })}>
                                                        <Trash2 className="h-4 w-4"/>
                                                    </Button>
                                                </div>
                                            </div>
                                            <AccordionContent>
                                                <div className="space-y-3 pl-8">
                                                    {stageLevels.map(level => (
                                                         <div key={level.id} className="flex items-center justify-between p-3 rounded-md bg-muted/50">
                                                            <div className="flex items-center gap-3">
                                                                <Layers className="h-4 w-4 text-muted-foreground" />
                                                                <span className="font-medium">{level.name}</span>
                                                            </div>
                                                            <div className="flex items-center gap-2">
                                                                <Button variant="ghost" size="icon" title="ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰" onClick={() => handleOpenEditLevel(level)}>
                                                                    <FilePenLine className="h-4 w-4"/>
                                                                </Button>
                                                                 <Button variant="ghost" size="icon" title="Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆÙ‰" className="text-destructive hover:text-destructive" onClick={() => handleDeleteClick({ id: level.id, name: level.name, type: 'level' })}>
                                                                    <Trash2 className="h-4 w-4"/>
                                                                </Button>
                                                            </div>
                                                        </div>
                                                    ))}
                                                    {stageLevels.length === 0 && <p className="text-muted-foreground text-center py-4">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³ØªÙˆÙŠØ§Øª ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©.</p>}
                                                     <Button variant="outline" size="sm" className="mt-4" onClick={() => handleOpenAddLevel(stage.id)}>
                                                        <PlusCircle className="ml-2 h-4 w-4" />
                                                        Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙˆÙ‰ Ø¬Ø¯ÙŠØ¯
                                                    </Button>
                                                </div>
                                            </AccordionContent>
                                        </AccordionItem>
                                    )
                                })}
                            </Accordion>
                            <Button variant="secondary" className="mt-6" onClick={handleOpenAddStage}>
                                <PlusCircle className="ml-2 h-4 w-4" />
                                Ø¥Ø¶Ø§ÙØ© Ù…Ø±Ø­Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©
                            </Button>
                        </CardContent>
                    </Card>
                </TabsContent>

                <TabsContent value="subjects">
                     <Card>
                         <CardHeader>
                            <div className="flex justify-between items-center">
                                <div>
                                    <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</CardTitle>
                                    <CardDescription>
                                        Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø³Ø¬Ù„Ø© ÙÙŠ Ø§Ù„Ù…Ù†ØµØ©.
                                    </CardDescription>
                                </div>
                                <Button onClick={handleOpenAddSubject}><PlusCircle className="ml-2 h-4 w-4"/> Ø¥Ø¶Ø§ÙØ© Ù…Ø§Ø¯Ø© Ø¬Ø¯ÙŠØ¯Ø©</Button>
                            </div>
                        </CardHeader>
                        <CardContent>
                           <Table>
                                <TableHeader>
                                    <TableRow>
                                        <TableHead>Ø§Ù„Ù…Ø§Ø¯Ø©</TableHead>
                                        <TableHead>Ø§Ù„Ù…Ø±Ø­Ù„Ø©</TableHead>
                                        <TableHead>Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</TableHead>
                                        <TableHead>Ø§Ù„ÙˆØµÙ</TableHead>
                                        <TableHead className="text-center">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</TableHead>
                                    </TableRow>
                                </TableHeader>
                                <TableBody>
                                    {groupedSubjects.map(subject => (
                                        <TableRow key={subject.id}>
                                            <TableCell className="font-medium">{subject.name}</TableCell>
                                            <TableCell>{subject.stage?.name}</TableCell>
                                            <TableCell>
                                                <div className="flex flex-wrap gap-1">
                                                    {subject._levels.sort((a: any, b: any) => a.displayOrder - b.displayOrder).map((l: any) => (
                                                        <span key={l.id} className="inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80">
                                                            {l.name}
                                                        </span>
                                                    ))}
                                                </div>
                                            </TableCell>
                                            <TableCell>{subject.description}</TableCell>
                                            <TableCell className="text-center">
                                                <div className="flex justify-center gap-2">
                                                    <Button variant="ghost" size="icon" title="ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø§Ø¯Ø©" onClick={() => handleOpenEditSubject(subject)}>
                                                        <FilePenLine className="h-4 w-4" />
                                                    </Button>
                                                    <Button variant="ghost" size="icon" title="Ø­Ø°Ù Ø§Ù„Ù…Ø§Ø¯Ø©" className="text-destructive hover:text-destructive" onClick={() => handleDeleteClick({ id: subject._ids, name: subject.name, type: 'subject' })}>
                                                        <Trash2 className="h-4 w-4" />
                                                    </Button>
                                                </div>
                                            </TableCell>
                                        </TableRow>
                                    ))}
                                     {subjects.length === 0 && (
                                        <TableRow>
                                            <TableCell colSpan={3} className="text-center h-24">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¯ Ø¯Ø±Ø§Ø³ÙŠØ©.</TableCell>
                                        </TableRow>
                                    )}
                                </TableBody>
                           </Table>
                        </CardContent>
                    </Card>
                </TabsContent>
            </Tabs>

        </div>
    )
}

// ==========================================
// FILE: src/app/(main)/dashboard/directeur/page.tsx
// ==========================================

'use client';

import DirecteurDashboard from "./_components/DirecteurDashboard";

export const dynamic = 'force-dynamic';

export default function DirecteurDashboardPage() {
    return <DirecteurDashboard />
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/broadcast/page.tsx
// ==========================================

'use client';

import { useState } from "react";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";
import { Loader2, Send, ArrowRight } from "lucide-react";
import { useUsers } from "@/hooks";
import { Checkbox } from "@/components/ui/checkbox";

export default function BroadcastMessagePage() {
  const { data: session } = useSession();
  const router = useRouter();
  const { toast } = useToast();
  const [subject, setSubject] = useState('');
  const [content, setContent] = useState('');
  const [recipientType, setRecipientType] = useState<'all' | 'role' | 'specific'>('role');
  const [selectedRole, setSelectedRole] = useState('student');
  const [selectedUserIds, setSelectedUserIds] = useState<string[]>([]);
  const [isSending, setIsSending] = useState(false);

  const { users } = useUsers();

  // Redirect if not directeur
  if (session?.user?.role !== 'directeur') {
    router.push('/messages');
    return null;
  }

  const handleUserToggle = (userId: string) => {
    setSelectedUserIds(prev =>
      prev.includes(userId)
        ? prev.filter(id => id !== userId)
        : [...prev, userId]
    );
  };

  const handleSend = async () => {
    if (!subject.trim() || !content.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ ÙˆØ§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ø·Ù„ÙˆØ¨Ø§Ù†',
        variant: 'destructive',
      });
      return;
    }

    if (recipientType === 'specific' && selectedUserIds.length === 0) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ¬Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ø­Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„',
        variant: 'destructive',
      });
      return;
    }

    setIsSending(true);
    try {
      const response = await fetch('/api/messages/broadcast', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          subject,
          content,
          recipientRole: recipientType === 'role' ? selectedRole : recipientType === 'all' ? 'all' : undefined,
          recipientIds: recipientType === 'specific' ? selectedUserIds : undefined,
        }),
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: 'Ù†Ø¬Ø­ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„',
          description: result.message || 'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨Ù†Ø¬Ø§Ø­',
        });
        router.push('/messages');
      } else {
        throw new Error(result.error);
      }
    } catch (error: any) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„',
        variant: 'destructive',
      });
    } finally {
      setIsSending(false);
    }
  };

  return (
    <div className="flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <div className="grid gap-1">
          <h1 className="text-3xl font-bold tracking-tight">Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ©</h1>
          <p className="text-muted-foreground">
            Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø£Ùˆ Ù„Ù„Ø¬Ù…ÙŠØ¹
          </p>
        </div>
        <Button variant="outline" onClick={() => router.push('/messages')}>
          <ArrowRight className="ml-2 h-4 w-4" />
          Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø³Ø§Ø¦Ù„
        </Button>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©</CardTitle>
          <CardDescription>Ø§Ù…Ù„Ø£ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙˆØ­Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªÙ„Ù…ÙŠÙ†</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-2">
            <Label htmlFor="subject">Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹</Label>
            <Input
              id="subject"
              placeholder="Ù…ÙˆØ¶ÙˆØ¹ Ø§Ù„Ø±Ø³Ø§Ù„Ø©"
              value={subject}
              onChange={(e) => setSubject(e.target.value)}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="content">Ø§Ù„Ù…Ø­ØªÙˆÙ‰</Label>
            <Textarea
              id="content"
              placeholder="Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø©..."
              rows={6}
              value={content}
              onChange={(e) => setContent(e.target.value)}
            />
          </div>

          <div className="space-y-4">
            <Label>Ø§Ù„Ù…Ø³ØªÙ„Ù…ÙˆÙ†</Label>
            <Select
              value={recipientType}
              onValueChange={(value: any) => setRecipientType(value)}
            >
              <SelectTrigger>
                <SelectValue placeholder="Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø³ØªÙ„Ù…ÙŠÙ†" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</SelectItem>
                <SelectItem value="role">Ù…Ø³ØªØ®Ø¯Ù…Ùˆ Ø¯ÙˆØ± Ù…Ø¹ÙŠÙ†</SelectItem>
                <SelectItem value="specific">Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ù…Ø­Ø¯Ø¯ÙˆÙ†</SelectItem>
              </SelectContent>
            </Select>

            {recipientType === 'role' && (
              <Select
                value={selectedRole}
                onValueChange={setSelectedRole}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ø¯ÙˆØ±" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="student">Ø§Ù„Ø·Ù„Ø§Ø¨</SelectItem>
                  <SelectItem value="teacher">Ø§Ù„Ù…Ø¹Ù„Ù…ÙˆÙ†</SelectItem>
                  <SelectItem value="parent">Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±</SelectItem>
                  <SelectItem value="supervisor_specific">Ù…Ø´Ø±ÙÙˆ Ø§Ù„Ù…ÙˆØ§Ø¯</SelectItem>
                  <SelectItem value="supervisor_general">Ø§Ù„Ù…Ø´Ø±ÙÙˆÙ† Ø§Ù„Ø¹Ø§Ù…ÙˆÙ†</SelectItem>
                </SelectContent>
              </Select>
            )}

            {recipientType === 'specific' && (
              <Card>
                <CardHeader>
                  <CardTitle className="text-base">Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</CardTitle>
                </CardHeader>
                <CardContent className="max-h-64 overflow-y-auto space-y-2">
                  {users.map((user) => (
                    <div key={user.id} className="flex items-center space-x-2 space-x-reverse">
                      <Checkbox
                        id={user.id}
                        checked={selectedUserIds.includes(user.id)}
                        onCheckedChange={() => handleUserToggle(user.id)}
                      />
                      <label
                        htmlFor={user.id}
                        className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 cursor-pointer"
                      >
                        {user.name} ({user.email})
                      </label>
                    </div>
                  ))}
                </CardContent>
              </Card>
            )}
          </div>

          <Button
            onClick={handleSend}
            disabled={isSending}
            className="w-full"
            size="lg"
          >
            {isSending ? (
              <>
                <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...
              </>
            ) : (
              <>
                <Send className="ml-2 h-4 w-4" />
                Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
              </>
            )}
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/database/page.tsx
// ==========================================


'use client';

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Loader2, Search, Download } from "lucide-react";

type TableName = 'users' | 'lessons' | 'subjects' | 'exercises' | 'submissions' | 'stages' | 'levels' | 'messages';

const tableTranslations: Record<TableName, string> = {
    users: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ†',
    lessons: 'Ø§Ù„Ø¯Ø±ÙˆØ³',
    subjects: 'Ø§Ù„Ù…ÙˆØ§Ø¯',
    exercises: 'Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†',
    submissions: 'Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª',
    stages: 'Ø§Ù„Ù…Ø±Ø§Ø­Ù„',
    levels: 'Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª',
    messages: 'Ø§Ù„Ø±Ø³Ø§Ø¦Ù„',
};

const apiEndpoints: Record<TableName, string> = {
    users: '/api/users',
    lessons: '/api/lessons',
    subjects: '/api/subjects',
    exercises: '/api/exercises',
    submissions: '/api/submissions',
    stages: '/api/stages',
    levels: '/api/levels',
    messages: '/api/messages',
};

export default function DatabasePage() {
    const [selectedTable, setSelectedTable] = useState<TableName>('users');
    const [searchTerm, setSearchTerm] = useState('');
    const [tableData, setTableData] = useState<any[]>([]);
    const [loading, setLoading] = useState(false);
    const [tableCounts, setTableCounts] = useState<Record<TableName, number>>({
        users: 0,
        lessons: 0,
        subjects: 0,
        exercises: 0,
        submissions: 0,
        stages: 0,
        levels: 0,
        messages: 0,
    });

    // Fetch counts for all tables
    useEffect(() => {
        const fetchCounts = async () => {
            try {
                // Ø§Ø³ØªØ®Ø¯Ø§Ù… API Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
                const res = await fetch('/api/database/inspect');
                if (res.ok) {
                    const result = await res.json();
                    if (result.success && result.data) {
                        setTableCounts({
                            users: result.data.users || 0,
                            lessons: result.data.lessons || 0,
                            subjects: result.data.subjects || 0,
                            exercises: result.data.exercises || 0,
                            submissions: result.data.submissions || 0,
                            stages: result.data.stages || 0,
                            levels: result.data.levels || 0,
                            messages: result.data.messages || 0,
                        });
                    }
                }
            } catch (error) {
                console.error('Error fetching database stats:', error);
            }
        };
        fetchCounts();
    }, []);

    // Fetch data for selected table
    useEffect(() => {
        const fetchTableData = async () => {
            setLoading(true);
            try {
                const res = await fetch(apiEndpoints[selectedTable]);
                if (res.ok) {
                    const result = await res.json();
                    
                    // Handle different API response formats
                    let parsedData: any[] = [];
                    
                    if (Array.isArray(result)) {
                        parsedData = result;
                    } else if (result.success && result.data) {
                        // Check nested structures
                        if (Array.isArray(result.data)) {
                            parsedData = result.data;
                        } else if (result.data.data && Array.isArray(result.data.data)) {
                            parsedData = result.data.data;
                        } else if (result.data.stages) {
                            parsedData = result.data.stages;
                        } else if (result.data.levels) {
                            parsedData = result.data.levels;
                        } else if (result.data.subjects) {
                            parsedData = result.data.subjects;
                        } else if (result.data.messages) {
                            parsedData = result.data.messages;
                        }
                    } else if (result.data) {
                        if (Array.isArray(result.data)) {
                            parsedData = result.data;
                        } else if (result.data.stages) {
                            parsedData = result.data.stages;
                        } else if (result.data.levels) {
                            parsedData = result.data.levels;
                        } else if (result.data.subjects) {
                            parsedData = result.data.subjects;
                        }
                    }
                    
                    setTableData(parsedData);
                } else {
                    setTableData([]);
                }
            } catch (error) {
                console.error(`Error fetching ${selectedTable}:`, error);
                setTableData([]);
            } finally {
                setLoading(false);
            }
        };
        fetchTableData();
    }, [selectedTable]);
    
    const filteredData = tableData.filter(row => {
        if (!searchTerm) return true;
        return Object.values(row).some(value => 
            String(value).toLowerCase().includes(searchTerm.toLowerCase())
        );
    });

    const headers = tableData.length > 0 ? Object.keys(tableData[0]) : [];

    const renderCell = (value: any) => {
        if (typeof value === 'boolean') {
            return value ? 'Ù†Ø¹Ù…' : 'Ù„Ø§';
        }
        if (typeof value === 'object' && value !== null) {
            return JSON.stringify(value);
        }
        const strValue = String(value);
        return strValue.length > 50 ? `${strValue.substring(0, 50)}...` : strValue;
    };

    const exportToCSV = () => {
        if (filteredData.length === 0) return;

        // Create CSV header
        const csvHeaders = headers.join(',');
        
        // Create CSV rows
        const csvRows = filteredData.map(row => {
            return headers.map(header => {
                let value = row[header];
                
                // Handle different data types
                if (value === null || value === undefined) {
                    return '';
                }
                if (typeof value === 'boolean') {
                    return value ? 'Ù†Ø¹Ù…' : 'Ù„Ø§';
                }
                if (typeof value === 'object') {
                    value = JSON.stringify(value);
                }
                
                // Convert to string and escape quotes
                const stringValue = String(value).replace(/"/g, '""');
                
                // Wrap in quotes if contains comma, newline, or quote
                if (stringValue.includes(',') || stringValue.includes('\n') || stringValue.includes('"')) {
                    return `"${stringValue}"`;
                }
                
                return stringValue;
            }).join(',');
        }).join('\n');

        // Combine header and rows
        const csvContent = '\ufeff' + csvHeaders + '\n' + csvRows; // \ufeff is BOM for UTF-8
        
        // Create blob and download
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        link.setAttribute('href', url);
        link.setAttribute('download', `${tableTranslations[selectedTable]}_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">ÙØ­Øµ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</h1>
                    <p className="text-muted-foreground">
                        Ø¹Ø±Ø¶ Ù…Ø¨Ø§Ø´Ø± Ù„Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ Ø§Ù„Ù…Ù†ØµØ©.
                    </p>
                </div>
            </div>

            <Card>
                <CardHeader>
                    <CardTitle>Ù…Ø³ØªØ¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„</CardTitle>
                    <CardDescription>Ø§Ø®ØªØ± Ø¬Ø¯ÙˆÙ„Ø§Ù‹ Ù„Ø¹Ø±Ø¶ Ù…Ø­ØªÙˆÙŠØ§ØªÙ‡.</CardDescription>
                </CardHeader>
                <CardContent className="space-y-6">
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div className="md:col-span-1">
                            <Select 
                                value={selectedTable} 
                                onValueChange={(value) => setSelectedTable(value as TableName)}
                            >
                                <SelectTrigger>
                                    <SelectValue placeholder="Ø§Ø®ØªØ± Ø¬Ø¯ÙˆÙ„" />
                                </SelectTrigger>
                                <SelectContent>
                                    {(Object.keys(apiEndpoints) as TableName[]).map(tableName => (
                                        <SelectItem key={tableName} value={tableName}>
                                            {tableTranslations[tableName]} ({tableCounts[tableName]})
                                        </SelectItem>
                                    ))}
                                </SelectContent>
                            </Select>
                        </div>
                        <div className="md:col-span-2 flex gap-2">
                             <div className="relative w-full">
                                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                                <Input 
                                    placeholder={`Ø§Ø¨Ø­Ø« ÙÙŠ Ø¬Ø¯ÙˆÙ„ ${tableTranslations[selectedTable]}...`}
                                    className="pl-10" 
                                    value={searchTerm}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                />
                            </div>
                            <Button 
                                variant="outline"
                                onClick={exportToCSV}
                                disabled={filteredData.length === 0}
                            >
                                <Download className="ml-2 h-4 w-4" />
                                <span>ØªØµØ¯ÙŠØ± CSV</span>
                            </Button>
                        </div>
                    </div>

                    <p className="text-sm text-muted-foreground">
                        Ø¹Ø±Ø¶ {filteredData.length} Ù…Ù† Ø£ØµÙ„ {tableData.length} Ø³Ø¬Ù„ ÙÙŠ Ø¬Ø¯ÙˆÙ„ "{tableTranslations[selectedTable]}".
                    </p>
                    
                    <div className="border rounded-md">
                        {loading ? (
                            <div className="flex items-center justify-center h-64">
                                <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
                            </div>
                        ) : (
                            <Table>
                                <TableHeader>
                                    <TableRow>
                                        {headers.map(header => (
                                            <TableHead key={header}>{header}</TableHead>
                                        ))}
                                    </TableRow>
                                </TableHeader>
                                <TableBody>
                                    {filteredData.length > 0 ? (
                                        filteredData.slice(0, 100).map((row, rowIndex) => ( // Limit to 100 rows for performance
                                            <TableRow key={rowIndex}>
                                                {headers.map(header => (
                                                    <TableCell key={`${rowIndex}-${header}`} className="font-mono text-xs max-w-xs truncate">
                                                        {renderCell(row[header])}
                                                    </TableCell>
                                                ))}
                                            </TableRow>
                                        ))
                                    ) : (
                                        <TableRow>
                                            <TableCell colSpan={headers.length} className="h-24 text-center">
                                                Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø¹Ø±Ø¶Ù‡Ø§.
                                            </TableCell>
                                        </TableRow>
                                    )}
                                </TableBody>
                            </Table>
                        )}
                    </div>
                    {filteredData.length > 100 && (
                        <p className="text-sm text-muted-foreground text-center">
                            ÙŠØªÙ… Ø¹Ø±Ø¶ Ø£ÙˆÙ„ 100 Ø³Ø¬Ù„ ÙÙ‚Ø·. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¨Ø­Ø« Ù„ØªØµÙÙŠØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬.
                        </p>
                    )}
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/users/_components/UserManagement.tsx
// ==========================================


'use client';

import { useState } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import {
  Users,
  Search,
  PlusCircle,
  FilePenLine,
  Trash2,
  Loader2,
  Ban,
} from "lucide-react";
import { Switch } from "@/components/ui/switch";
import { useUsers, useSubjects, useLevels, useStages } from "@/hooks";
import { useToast } from "@/hooks/use-toast";

const roleTranslation: Record<string, string> = {
  directeur: 'Ù…Ø¯ÙŠØ±',
  supervisor_general: 'Ù…Ø´Ø±Ù Ø¹Ø§Ù…',
  supervisor_specific: 'Ù…Ø´Ø±Ù Ù…Ø§Ø¯Ø©',
  teacher: 'Ù…Ø¹Ù„Ù…',
  student: 'Ø·Ø§Ù„Ø¨',
  parent: 'ÙˆÙ„ÙŠ Ø£Ù…Ø±',
};

const roleVariant: Record<string, "default" | "secondary" | "destructive" | "outline"> = {
  directeur: 'destructive',
  supervisor_general: 'secondary',
  supervisor_specific: 'secondary',
  teacher: 'outline',
  student: 'default',
  parent: 'default',
};

interface UserFormData {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  role: string;
  stageId?: number;
  subjectId?: number;
  levelId?: number;
}

export default function UserManagement() {
  const { toast } = useToast();
  const [search, setSearch] = useState("");
  const [roleFilter, setRoleFilter] = useState<string>("all");
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [selectedUserId, setSelectedUserId] = useState<number | null>(null);
  const [formData, setFormData] = useState<UserFormData>({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    role: 'student',
  });

  const { users, isLoading, createUser, updateUser, deleteUser, refetch } = useUsers({
    role: roleFilter === 'all' ? undefined : roleFilter,
    search: search || undefined,
  });
  
  const { subjects } = useSubjects();
  const { levels } = useLevels();
  const { stages } = useStages();

  const students = Array.isArray(users) ? users.filter((u) => u.role === "student").length : 0;
  const teachers = Array.isArray(users) ? users.filter((u) => u.role === "teacher" || u.role === 'supervisor_specific').length : 0;
  const parents = Array.isArray(users) ? users.filter((u) => u.role === "parent").length : 0;

  const handleCreateUser = async () => {
    const result = await createUser({
      email: formData.email,
      password: formData.password,
      firstName: formData.firstName,
      lastName: formData.lastName,
      roleName: formData.role,
      stageId: formData.stageId,
      subjectId: formData.subjectId,
      levelId: formData.levelId,
    });

    if (result.success) {
      toast({
        title: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…',
        description: 'ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­',
      });
      setIsCreateDialogOpen(false);
      setFormData({ firstName: '', lastName: '', email: '', password: '', role: 'student' });
    } else {
      toast({
        title: 'Ø®Ø·Ø£',
        description: result.error || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…',
        variant: 'destructive',
      });
    }
  };

  const handleEditUser = async () => {
    if (!selectedUserId) return;

    const updateData: any = {
      firstName: formData.firstName,
      lastName: formData.lastName,
      role: formData.role,
      subjectId: formData.subjectId,
      levelId: formData.levelId,
    };

    // Only include password if it's been changed
    if (formData.password && formData.password.trim()) {
      updateData.password = formData.password;
    }

    const result = await updateUser(selectedUserId, updateData);

    if (result.success) {
      toast({
        title: 'ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«',
        description: 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­',
      });
      setIsEditDialogOpen(false);
      setSelectedUserId(null);
      setFormData({ firstName: '', lastName: '', email: '', password: '', role: 'student' });
    } else {
      toast({
        title: 'Ø®Ø·Ø£',
        description: result.error || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…',
        variant: 'destructive',
      });
    }
  };

  const handleDeleteUser = async (id: number) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŸ')) return;

    const result = await deleteUser(id);
    if (result.success) {
      toast({
        title: 'ØªÙ… Ø§Ù„Ø­Ø°Ù',
        description: 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­',
      });
    } else {
      toast({
        title: 'Ø®Ø·Ø£',
        description: result.error || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…',
        variant: 'destructive',
      });
    }
  };

  const openEditDialog = (user: any) => {
    // Split name into firstName and lastName
    const nameParts = user.name ? user.name.trim().split(' ') : ['', ''];
    const firstName = nameParts[0] || '';
    const lastName = nameParts.slice(1).join(' ') || '';

    setSelectedUserId(user.id);
    setFormData({
      firstName,
      lastName,
      email: user.email,
      password: '',
      role: user.role,
      stageId: user.details?.stageId || undefined,
      subjectId: user.details?.subjectId || undefined,
      levelId: user.details?.levelId || undefined,
    });
    setIsEditDialogOpen(true);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <div className="grid gap-1">
          <h1 className="text-3xl font-bold tracking-tight">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</h1>
          <p className="text-muted-foreground">
            Ø¹Ø±Ø¶ ÙˆØªØ¹Ø¯ÙŠÙ„ ÙˆØ§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙÙŠ Ø§Ù„Ù…Ù†ØµØ©.
          </p>
        </div>
        <Button onClick={() => setIsCreateDialogOpen(true)}>
          <PlusCircle className="ml-2 h-4 w-4" />
          <span>Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯</span>
        </Button>
      </div>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{users.length}</div>
            <p className="text-xs text-muted-foreground">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¯ÙˆØ§Ø±</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø§Ù„Ø·Ù„Ø§Ø¨</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{students}</div>
            <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ†</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø§Ù„Ø·Ø§Ù‚Ù… Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{teachers}</div>
            <p className="text-xs text-muted-foreground">Ù…Ø¹Ù„Ù…ÙˆÙ† ÙˆÙ…Ø´Ø±ÙÙˆÙ†</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{parents}</div>
            <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±</p>
          </CardContent>
        </Card>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</CardTitle>
          <CardDescription>
            ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {users.length} Ù…Ø³ØªØ®Ø¯Ù….
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="flex flex-col sm:flex-row items-center gap-4 mb-6">
            <div className="relative w-full sm:max-w-xs">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input 
                placeholder="Ø§Ø¨Ø­Ø« Ø¨Ø§Ù„Ø§Ø³Ù… Ø£Ùˆ Ø§Ù„Ø¨Ø±ÙŠØ¯..." 
                className="pl-10" 
                value={search}
                onChange={(e) => setSearch(e.target.value)}
              />
            </div>
            <Select value={roleFilter} onValueChange={setRoleFilter}>
              <SelectTrigger className="w-full sm:w-[200px]">
                <SelectValue placeholder="ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø¯ÙˆØ±" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¯ÙˆØ§Ø±</SelectItem>
                <SelectItem value="student">Ø·Ø§Ù„Ø¨</SelectItem>
                <SelectItem value="teacher">Ù…Ø¹Ù„Ù…</SelectItem>
                <SelectItem value="parent">ÙˆÙ„ÙŠ Ø£Ù…Ø±</SelectItem>
                <SelectItem value="supervisor_specific">Ù…Ø´Ø±Ù Ù…Ø§Ø¯Ø©</SelectItem>
                <SelectItem value="supervisor_general">Ù…Ø´Ø±Ù Ø¹Ø§Ù…</SelectItem>
                <SelectItem value="directeur">Ù…Ø¯ÙŠØ±</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</TableHead>
                <TableHead>Ø§Ù„Ø¯ÙˆØ±</TableHead>
                <TableHead>Ø§Ù„ØªÙØ§ØµÙŠÙ„</TableHead>
                <TableHead>Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</TableHead>
                <TableHead>Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</TableHead>
                <TableHead className="text-center">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {Array.isArray(users) && users.length > 0 ? (
                users.map((user) => (
                  <TableRow key={user.id}>
                    <TableCell>
                      <div className="flex items-center gap-3">
                        <Avatar>
                          <AvatarImage src={user.image || undefined} alt={user.name} />
                          <AvatarFallback>{user.name.charAt(0)}</AvatarFallback>
                        </Avatar>
                        <div className="flex flex-col gap-1">
                          <span className="font-medium">{user.name}</span>
                          {user.isBanned && (
                            <Badge variant="destructive" className="text-xs w-fit">
                              Ù…Ø­Ø¸ÙˆØ±
                            </Badge>
                          )}
                        </div>
                      </div>
                    </TableCell>
                    <TableCell>
                      <Badge variant={roleVariant[user.role] || 'default'}>
                        {roleTranslation[user.role] || user.role}
                      </Badge>
                    </TableCell>
                    <TableCell>
                      <div className="flex flex-col gap-1 text-sm">
                        {user.details?.subject && (
                          <span className="text-muted-foreground">
                            {user.details.subject.name}
                          </span>
                        )}
                        {user.details?.level && (
                          <span className="text-muted-foreground">
                            {user.details.level.name}
                          </span>
                        )}
                      </div>
                    </TableCell>
                    <TableCell>
                      {(user.role === 'teacher' || user.role === 'supervisor_specific') && (
                        <div className="flex flex-col gap-1 text-sm">
                          <span className="text-muted-foreground">
                            ğŸ“š {user.lessonsCount || 0} Ø¯Ø±Ø³
                          </span>
                          <span className="text-muted-foreground">
                            âœï¸ {user.exercisesCount || 0} ØªÙ…Ø±ÙŠÙ†
                          </span>
                        </div>
                      )}
                    </TableCell>
                    <TableCell>{user.email}</TableCell>
                    <TableCell className="text-center">
                      <div className="flex justify-center gap-2">
                        <Button 
                          variant="ghost" 
                          size="icon" 
                          title="ØªØ¹Ø¯ÙŠÙ„"
                          onClick={() => openEditDialog(user)}
                        >
                          <FilePenLine className="h-4 w-4" />
                        </Button>
                        <Button 
                          variant="ghost" 
                          size="icon" 
                          title="Ø­Ø°Ù" 
                          className="text-destructive hover:text-destructive"
                          onClick={() => handleDeleteUser(user.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={6} className="text-center h-24">
                    Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>

      {/* Create User Dialog */}
      <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>
        <DialogContent className="sm:max-w-[500px]">
          <DialogHeader>
            <DialogTitle>Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯</DialogTitle>
            <DialogDescription>
              Ù‚Ù… Ø¨Ø¥Ø¯Ø®Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="grid gap-2">
                <Label htmlFor="firstName">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„</Label>
                <Input
                  id="firstName"
                  value={formData.firstName}
                  onChange={(e) => setFormData({ ...formData, firstName: e.target.value })}
                  placeholder="Ù…Ø«Ø§Ù„: Ø£Ø­Ù…Ø¯"
                  required
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="lastName">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£Ø®ÙŠØ±</Label>
                <Input
                  id="lastName"
                  value={formData.lastName}
                  onChange={(e) => setFormData({ ...formData, lastName: e.target.value })}
                  placeholder="Ù…Ø«Ø§Ù„: Ø§Ù„Ù…Ø­Ù…ÙˆØ¯"
                  required
                />
              </div>
            </div>
            <div className="grid gap-2">
              <Label htmlFor="email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</Label>
              <Input
                id="email"
                type="email"
                value={formData.email}
                onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                placeholder="email@example.com"
                required
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="role">Ø§Ù„Ø¯ÙˆØ±</Label>
              <Select 
                value={formData.role} 
                onValueChange={(value) => setFormData({ ...formData, role: value, stageId: undefined, subjectId: undefined, levelId: undefined })}
              >
                <SelectTrigger id="role">
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ø¯ÙˆØ±" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="student">Ø·Ø§Ù„Ø¨</SelectItem>
                  <SelectItem value="teacher">Ù…Ø¹Ù„Ù…</SelectItem>
                  <SelectItem value="parent">ÙˆÙ„ÙŠ Ø£Ù…Ø±</SelectItem>
                  <SelectItem value="supervisor_specific">Ù…Ø´Ø±Ù Ù…Ø§Ø¯Ø©</SelectItem>
                  <SelectItem value="supervisor_general">Ù…Ø´Ø±Ù Ø¹Ø§Ù…</SelectItem>
                  <SelectItem value="directeur">Ù…Ø¯ÙŠØ±</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {formData.role === 'teacher' && (
              <div className="grid grid-cols-2 gap-4">
                <div className="grid gap-2">
                  <Label htmlFor="teacher-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                  <Select 
                    value={formData.stageId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, stageId: parseInt(value), subjectId: undefined })}
                  >
                    <SelectTrigger id="teacher-stage">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(stages) && stages.map(stage => (
                        <SelectItem key={stage.id} value={stage.id.toString()}>
                          {stage.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="subjectId">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                  <Select 
                    value={formData.subjectId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, subjectId: parseInt(value) })}
                    disabled={!formData.stageId}
                  >
                    <SelectTrigger id="subjectId">
                      <SelectValue placeholder={!formData.stageId ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø©"} />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(subjects) && subjects
                        .filter(subject => {
                          const subjectStageId = (subject as any).stageId || (subject as any).stage_id;
                          return String(subjectStageId) === String(formData.stageId);
                        })
                        .map(subject => (
                          <SelectItem key={subject.id} value={subject.id.toString()}>
                            {subject.name}
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}

            {formData.role === 'student' && (
              <div className="space-y-4">
                <div className="grid gap-2">
                  <Label htmlFor="student-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</Label>
                  <Select 
                    value={formData.stageId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, stageId: parseInt(value), levelId: undefined })}
                  >
                    <SelectTrigger id="student-stage">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(stages) && stages.map(stage => (
                        <SelectItem key={stage.id} value={stage.id.toString()}>
                          {stage.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="levelId">Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</Label>
                  <Select 
                    value={formData.levelId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, levelId: parseInt(value) })}
                    disabled={!formData.stageId}
                  >
                    <SelectTrigger id="levelId">
                      <SelectValue placeholder={!formData.stageId ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©"} />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(levels) && levels
                        .filter(level => {
                          const levelStageId = (level as any).stageId || (level as any).stage_id;
                          return String(levelStageId) === String(formData.stageId);
                        })
                        .map(level => (
                          <SelectItem key={level.id} value={level.id.toString()}>
                            {level.name}
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}

            {formData.role === 'supervisor_specific' && (
              <div className="space-y-4">
                <div className="grid grid-cols-2 gap-4">
                  <div className="grid gap-2">
                    <Label htmlFor="supervisor-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                    <Select 
                      value={formData.stageId?.toString()} 
                      onValueChange={(value) => setFormData({ ...formData, stageId: parseInt(value), subjectId: undefined, levelId: undefined })}
                    >
                      <SelectTrigger id="supervisor-stage">
                        <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                      </SelectTrigger>
                      <SelectContent>
                        {Array.isArray(stages) && stages.map(stage => (
                          <SelectItem key={stage.id} value={stage.id.toString()}>
                            {stage.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="grid gap-2">
                    <Label htmlFor="supervisor-subject">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                    <Select 
                      value={formData.subjectId?.toString()} 
                      onValueChange={(value) => setFormData({ ...formData, subjectId: parseInt(value) })}
                      disabled={!formData.stageId}
                    >
                      <SelectTrigger id="supervisor-subject">
                        <SelectValue placeholder={!formData.stageId ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø©"} />
                      </SelectTrigger>
                      <SelectContent>
                        {Array.isArray(subjects) && subjects
                          .filter(subject => {
                            const subjectStageId = (subject as any).stageId || (subject as any).stage_id;
                            return String(subjectStageId) === String(formData.stageId);
                          })
                          .map(subject => (
                            <SelectItem key={subject.id} value={subject.id.toString()}>
                              {subject.name}
                            </SelectItem>
                          ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="supervisor-level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ</Label>
                  <Select 
                    value={formData.levelId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, levelId: parseInt(value) })}
                    disabled={!formData.stageId}
                  >
                    <SelectTrigger id="supervisor-level">
                      <SelectValue placeholder={!formData.stageId ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ"} />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(levels) && levels
                        .filter(level => {
                          const levelStageId = (level as any).stageId || (level as any).stage_id;
                          return String(levelStageId) === String(formData.stageId);
                        })
                        .map(level => (
                          <SelectItem key={level.id} value={level.id.toString()}>
                            {level.name}
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}

            <div className="grid gap-2">
              <Label htmlFor="password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</Label>
              <Input
                id="password"
                type="password"
                value={formData.password}
                onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                placeholder="********"
                required
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsCreateDialogOpen(false)}>
              Ø¥Ù„ØºØ§Ø¡
            </Button>
            <Button onClick={handleCreateUser}>Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Edit User Dialog */}
      <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
        <DialogContent className="sm:max-w-[500px]">
          <DialogHeader>
            <DialogTitle>ØªØ¹Ø¯ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</DialogTitle>
            <DialogDescription>
              Ù‚Ù… Ø¨ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="grid gap-2">
                <Label htmlFor="edit-firstName">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„</Label>
                <Input
                  id="edit-firstName"
                  value={formData.firstName}
                  onChange={(e) => setFormData({ ...formData, firstName: e.target.value })}
                  placeholder="Ù…Ø«Ø§Ù„: Ø£Ø­Ù…Ø¯"
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="edit-lastName">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£Ø®ÙŠØ±</Label>
                <Input
                  id="edit-lastName"
                  value={formData.lastName}
                  onChange={(e) => setFormData({ ...formData, lastName: e.target.value })}
                  placeholder="Ù…Ø«Ø§Ù„: Ø§Ù„Ù…Ø­Ù…ÙˆØ¯"
                />
              </div>
            </div>
            <div className="grid gap-2">
              <Label htmlFor="edit-email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</Label>
              <Input
                id="edit-email"
                type="email"
                value={formData.email}
                disabled
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="edit-role">Ø§Ù„Ø¯ÙˆØ±</Label>
              <Select 
                value={formData.role} 
                onValueChange={(value) => setFormData({ ...formData, role: value, stageId: undefined, subjectId: undefined, levelId: undefined })}
              >
                <SelectTrigger id="edit-role">
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ø¯ÙˆØ±" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="student">Ø·Ø§Ù„Ø¨</SelectItem>
                  <SelectItem value="teacher">Ù…Ø¹Ù„Ù…</SelectItem>
                  <SelectItem value="parent">ÙˆÙ„ÙŠ Ø£Ù…Ø±</SelectItem>
                  <SelectItem value="supervisor_specific">Ù…Ø´Ø±Ù Ù…Ø§Ø¯Ø©</SelectItem>
                  <SelectItem value="supervisor_general">Ù…Ø´Ø±Ù Ø¹Ø§Ù…</SelectItem>
                  <SelectItem value="directeur">Ù…Ø¯ÙŠØ±</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {formData.role === 'teacher' && (
              <div className="grid grid-cols-2 gap-4">
                <div className="grid gap-2">
                  <Label htmlFor="edit-teacher-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                  <Select 
                    value={formData.stageId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, stageId: parseInt(value), subjectId: undefined })}
                  >
                    <SelectTrigger id="edit-teacher-stage">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(stages) && stages.map(stage => (
                        <SelectItem key={stage.id} value={stage.id.toString()}>
                          {stage.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="edit-subjectId">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                  <Select 
                    value={formData.subjectId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, subjectId: parseInt(value) })}
                    disabled={!formData.stageId}
                  >
                  <SelectTrigger id="edit-subjectId">
                    <SelectValue placeholder={!formData.stageId ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø©"} />
                  </SelectTrigger>
                  <SelectContent>
                    {Array.isArray(subjects) && subjects
                      .filter(subject => {
                        const subjectStageId = (subject as any).stageId || (subject as any).stage_id;
                        return String(subjectStageId) === String(formData.stageId);
                      })
                      .map(subject => (
                        <SelectItem key={subject.id} value={subject.id.toString()}>
                          {subject.name}
                        </SelectItem>
                      ))}
                  </SelectContent>
                </Select>
              </div>
              </div>
            )}

            {formData.role === 'student' && (
              <div className="space-y-4">
                <div className="grid gap-2">
                  <Label htmlFor="edit-student-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</Label>
                  <Select 
                    value={formData.stageId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, stageId: parseInt(value), levelId: undefined })}
                  >
                    <SelectTrigger id="edit-student-stage">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(stages) && stages.map(stage => (
                        <SelectItem key={stage.id} value={stage.id.toString()}>
                          {stage.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="edit-levelId">Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</Label>
                  <Select 
                    value={formData.levelId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, levelId: parseInt(value) })}
                    disabled={!formData.stageId}
                  >
                    <SelectTrigger id="edit-levelId">
                      <SelectValue placeholder={!formData.stageId ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©"} />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(levels) && levels
                        .filter(level => {
                          const levelStageId = (level as any).stageId || (level as any).stage_id;
                          return String(levelStageId) === String(formData.stageId);
                        })
                        .map(level => (
                          <SelectItem key={level.id} value={level.id.toString()}>
                            {level.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              </div>
            )}

            {formData.role === 'supervisor_specific' && (
              <div className="space-y-4">
                <div className="grid grid-cols-2 gap-4">
                  <div className="grid gap-2">
                    <Label htmlFor="edit-supervisor-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                    <Select 
                      value={formData.stageId?.toString()} 
                      onValueChange={(value) => setFormData({ ...formData, stageId: parseInt(value), subjectId: undefined, levelId: undefined })}
                    >
                      <SelectTrigger id="edit-supervisor-stage">
                        <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                      </SelectTrigger>
                      <SelectContent>
                        {Array.isArray(stages) && stages.map(stage => (
                          <SelectItem key={stage.id} value={stage.id.toString()}>
                            {stage.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="grid gap-2">
                    <Label htmlFor="edit-supervisor-subject">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                    <Select 
                      value={formData.subjectId?.toString()} 
                      onValueChange={(value) => setFormData({ ...formData, subjectId: parseInt(value) })}
                      disabled={!formData.stageId}
                    >
                      <SelectTrigger id="edit-supervisor-subject">
                        <SelectValue placeholder={!formData.stageId ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø©"} />
                      </SelectTrigger>
                      <SelectContent>
                        {Array.isArray(subjects) && subjects
                          .filter(subject => {
                            const subjectStageId = (subject as any).stageId || (subject as any).stage_id;
                            return String(subjectStageId) === String(formData.stageId);
                          })
                          .map(subject => (
                            <SelectItem key={subject.id} value={subject.id.toString()}>
                              {subject.name}
                            </SelectItem>
                          ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="edit-supervisor-level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ</Label>
                  <Select 
                    value={formData.levelId?.toString()} 
                    onValueChange={(value) => setFormData({ ...formData, levelId: parseInt(value) })}
                    disabled={!formData.stageId}
                  >
                    <SelectTrigger id="edit-supervisor-level">
                      <SelectValue placeholder={!formData.stageId ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ"} />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.isArray(levels) && levels
                        .filter(level => {
                          const levelStageId = (level as any).stageId || (level as any).stage_id;
                          return String(levelStageId) === String(formData.stageId);
                        })
                        .map(level => (
                          <SelectItem key={level.id} value={level.id.toString()}>
                            {level.name}
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}

            <div className="grid gap-2">
              <Label htmlFor="edit-password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (Ø§ØªØ±ÙƒÙ‡ ÙØ§Ø±ØºØ§Ù‹ Ø¥Ø°Ø§ Ù„Ù… ØªØ±Ø¯ Ø§Ù„ØªØºÙŠÙŠØ±)</Label>
              <Input
                id="edit-password"
                type="password"
                placeholder="********"
                value={formData.password}
                onChange={(e) => setFormData({ ...formData, password: e.target.value })}
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsEditDialogOpen(false)}>
              Ø¥Ù„ØºØ§Ø¡
            </Button>
            <Button onClick={handleEditUser}>Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/users/page.tsx
// ==========================================

'use client';

import UserManagement from "./_components/UserManagement";

export default function UserManagementPage() {
  return <UserManagement />;
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/settings/page.tsx
// ==========================================


'use client';

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Save, Brush, UserPlus, Info, Palette } from "lucide-react";
import { useState, useEffect } from "react";
import { useToast } from "@/hooks/use-toast";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";


// Helper function to convert hex to HSL string
const hexToHsl = (hex: string): string => {
    hex = hex.replace('#', '');
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2;

    if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return `${Math.round(h * 360)} ${Math.round(s * 100)}% ${Math.round(l * 100)}%`;
};

export default function SettingsPage() {
    const { toast } = useToast();

    const [theme, setTheme] = useState({
        primary: '#3F51B5', // Deep blue
        background: '#E8EAF6', // Very light blue
        accent: '#7E57C2', // Purple
        font: 'Amiri',
    });

    useEffect(() => {
        // This effect runs on the client-side
        const root = document.documentElement;
        const body = document.body;

        try {
            const primaryHsl = hexToHsl(theme.primary);
            const backgroundHsl = hexToHsl(theme.background);
            const accentHsl = hexToHsl(theme.accent);

            root.style.setProperty('--primary', primaryHsl);
            root.style.setProperty('--background', backgroundHsl);
            root.style.setProperty('--accent', accentHsl);
            
            // For the font, we need to make sure the variable is set on the body
            // and that tailwind.config.ts is configured to use it.
            body.style.fontFamily = `var(--font-body), sans-serif`;
            root.style.setProperty('--font-body', theme.font);

        } catch (error) {
            console.error("Error applying theme:", error);
        }

    }, [theme]);


    const handleColorChange = (key: 'primary' | 'background' | 'accent', value: string) => {
        setTheme(prev => ({...prev, [key]: value}))
    }
    
    const handleFontChange = (value: string) => {
        setTheme(prev => ({ ...prev, font: value }));
    };

    const handleSave = (section: string) => {
        toast({
            title: "ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­!",
            description: `ØªÙ… Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ${section}.`,
        });
    }

    return (
        <div className="flex flex-col gap-8 max-w-4xl mx-auto">
            <div className="grid gap-1">
                <h1 className="text-3xl font-bold tracking-tight">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ù†ØµØ©</h1>
                <p className="text-muted-foreground">
                    Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ù„Ù…Ù†ØµØ©ØŒ Ø§Ù„Ù…Ø¸Ù‡Ø±ØŒ ÙˆØ§Ù„ØªØ³Ø¬ÙŠÙ„.
                </p>
            </div>

            <Card>
                <CardHeader>
                    <CardTitle className="flex items-center gap-2">
                        <Info className="h-5 w-5 text-primary" />
                        <span>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¹Ø§Ù…Ø©</span>
                    </CardTitle>
                    <CardDescription>
                        Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ù…Ù†ØµØ©.
                    </CardDescription>
                </CardHeader>
                <CardContent className="space-y-6">
                    <div className="space-y-2">
                        <Label htmlFor="platform-name">Ø§Ø³Ù… Ø§Ù„Ù…Ù†ØµØ©</Label>
                        <Input id="platform-name" defaultValue="SmartEdu" />
                    </div>
                     <div className="space-y-2">
                        <Label htmlFor="platform-description">ÙˆØµÙ Ø§Ù„Ù…Ù†ØµØ©</Label>
                        <Input id="platform-description" defaultValue="Ù…Ù†ØµØ© ØªØ¹Ù„ÙŠÙ…ÙŠØ© Ø°ÙƒÙŠØ©" />
                    </div>
                     <div className="flex items-center justify-between rounded-lg border p-4">
                        <div>
                            <Label htmlFor="maintenance-mode" className="font-semibold">ÙˆØ¶Ø¹ Ø§Ù„ØµÙŠØ§Ù†Ø©</Label>
                            <p className="text-sm text-muted-foreground">
                                Ø¹Ù†Ø¯ Ø§Ù„ØªÙØ¹ÙŠÙ„ØŒ Ù„Ù† ÙŠØªÙ…ÙƒÙ† Ø³ÙˆÙ‰ Ø§Ù„Ù…Ø¯ÙŠØ±ÙŠÙ† Ù…Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ù†ØµØ©.
                            </p>
                        </div>
                        <Switch id="maintenance-mode" />
                    </div>
                    <div className="flex justify-end">
                        <Button onClick={() => handleSave('Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©')}><Save className="ml-2 h-4 w-4" /> Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©</Button>
                    </div>
                </CardContent>
            </Card>

            <Card>
                <CardHeader>
                     <CardTitle className="flex items-center gap-2">
                        <Brush className="h-5 w-5 text-primary" />
                        <span>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø¸Ù‡Ø±</span>
                    </CardTitle>
                    <CardDescription>
                        ØªØ®ØµÙŠØµ Ø§Ù„Ø£Ù„ÙˆØ§Ù† ÙˆØ§Ù„Ø®Ø·ÙˆØ· Ù„ØªÙ†Ø§Ø³Ø¨ Ù‡ÙˆÙŠØ© Ø§Ù„Ù…Ù†ØµØ©.
                    </CardDescription>
                </CardHeader>
                <CardContent className="space-y-6">
                    <div className="space-y-2">
                        <Label htmlFor="font-select">Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·</Label>
                         <Select onValueChange={handleFontChange} defaultValue={theme.font}>
                            <SelectTrigger id="font-select">
                                <SelectValue placeholder="Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·" />
                            </SelectTrigger>
                            <SelectContent>
                                <SelectItem value="Inter">Inter</SelectItem>
                                <SelectItem value="Tajawal">Tajawal</SelectItem>
                                <SelectItem value="Cairo">Cairo</SelectItem>
                                <SelectItem value="Amiri">Amiri</SelectItem>
                            </SelectContent>
                        </Select>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div className="space-y-2">
                            <Label htmlFor="color-primary" className="flex items-center gap-2"><Palette size={16}/> Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ</Label>
                            <Input id="color-primary" type="color" value={theme.primary} onChange={(e) => handleColorChange('primary', e.target.value)} className="p-1 h-10" />
                        </div>
                        <div className="space-y-2">
                            <Label htmlFor="color-background" className="flex items-center gap-2"><Palette size={16}/> Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ©</Label>
                            <Input id="color-background" type="color" value={theme.background} onChange={(e) => handleColorChange('background', e.target.value)} className="p-1 h-10" />
                        </div>
                         <div className="space-y-2">
                            <Label htmlFor="color-accent" className="flex items-center gap-2"><Palette size={16}/> Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ</Label>
                            <Input id="color-accent" type="color" value={theme.accent} onChange={(e) => handleColorChange('accent', e.target.value)} className="p-1 h-10" />
                        </div>
                    </div>
                     <div className="flex justify-end">
                        <Button onClick={() => handleSave('Ø§Ù„Ù…Ø¸Ù‡Ø±')}><Save className="ml-2 h-4 w-4" /> Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø¸Ù‡Ø±</Button>
                    </div>
                </CardContent>
            </Card>

            <Card>
                <CardHeader>
                    <CardTitle className="flex items-center gap-2">
                        <UserPlus className="h-5 w-5 text-primary" />
                        <span>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„</span>
                    </CardTitle>
                    <CardDescription>
                       Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ ÙƒÙŠÙÙŠØ© Ø§Ù†Ø¶Ù…Ø§Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø¯ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù†ØµØ©.
                    </CardDescription>
                </CardHeader>
                <CardContent className="space-y-6">
                    <div className="flex items-center justify-between rounded-lg border p-4">
                        <div>
                            <Label htmlFor="allow-registration" className="font-semibold">Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨ØªØ³Ø¬ÙŠÙ„ Ø¬Ø¯ÙŠØ¯</Label>
                            <p className="text-sm text-muted-foreground">
                                Ù‡Ù„ ÙŠÙ…ÙƒÙ† Ù„Ù„Ø²ÙˆØ§Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø£Ù†ÙØ³Ù‡Ù…ØŸ
                            </p>
                        </div>
                        <Switch id="allow-registration" defaultChecked />
                    </div>
                    <div className="flex items-center justify-between rounded-lg border p-4">
                        <div>
                            <Label htmlFor="require-verification" className="font-semibold">ØªØ·Ù„Ø¨ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</Label>
                             <p className="text-sm text-muted-foreground">
                                Ù‡Ù„ ÙŠØ¬Ø¨ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø¬Ø¯Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ù‡Ù… Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù‚Ø¨Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ØŸ
                            </p>
                        </div>
                        <Switch id="require-verification" defaultChecked />
                    </div>
                    <div className="flex justify-end">
                        <Button onClick={() => handleSave('Ø§Ù„ØªØ³Ø¬ÙŠÙ„')}><Save className="ml-2 h-4 w-4" /> Ø­ÙØ¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„</Button>
                    </div>
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/promotions/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from '@/components/ui/table';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { 
  GraduationCap, 
  Send, 
  CheckCircle2, 
  XCircle, 
  Clock,
  TrendingUp,
  Users,
  Calendar,
  Plus,
  RefreshCw
} from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { formatDistanceToNow } from 'date-fns';
import { ar } from 'date-fns/locale';
import Confetti from 'react-confetti';
import { useWindowSize } from '@/hooks/use-window-size';

interface AcademicYear {
  id: string;
  name: string;
  startDate: string;
  endDate: string;
  isCurrent: boolean;
  status: string;
  _count: {
    promotions: number;
  };
}

interface PromotionStats {
  total: number;
  pending: number;
  approved: number;
  rejected: number;
  completed: number;
  responseRate: number;
}

interface Promotion {
  id: string;
  status: string;
  parentResponse: string | null;
  notifiedAt: string | null;
  respondedAt: string | null;
  promotedAt: string | null;
  student: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
  parent: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
  fromLevel: {
    id: number;
    name: string;
  };
  toLevel: {
    id: number;
    name: string;
  } | null;
}

export default function PromotionsPage() {
  const [years, setYears] = useState<AcademicYear[]>([]);
  const [selectedYear, setSelectedYear] = useState<string>('');
  const [stats, setStats] = useState<PromotionStats | null>(null);
  const [promotions, setPromotions] = useState<Promotion[]>([]);
  const [loading, setLoading] = useState(false);
  const [creating, setCreating] = useState(false);
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [showInitiateDialog, setShowInitiateDialog] = useState(false);
  const [showConfetti, setShowConfetti] = useState(false);
  
  const [newYear, setNewYear] = useState({
    name: '',
    startDate: '',
    endDate: ''
  });

  const { toast } = useToast();
  const { width, height } = useWindowSize();

  useEffect(() => {
    fetchYears();
  }, []);

  useEffect(() => {
    if (selectedYear) {
      fetchStats();
    }
  }, [selectedYear]);

  const fetchYears = async () => {
    try {
      const response = await fetch('/api/academic-years');
      if (response.ok) {
        const data = await response.json();
        setYears(data.years);
        
        // Auto-select current year
        const current = data.years.find((y: AcademicYear) => y.isCurrent);
        if (current) {
          setSelectedYear(current.id);
        } else if (data.years.length > 0) {
          setSelectedYear(data.years[0].id);
        }
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ù†ÙˆØ§Øª Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©',
        variant: 'destructive'
      });
    }
  };

  const fetchStats = async () => {
    try {
      setLoading(true);
      const response = await fetch(`/api/academic-years/promotions/stats?academicYearId=${selectedYear}`);
      if (response.ok) {
        const data = await response.json();
        setStats(data.stats);
        setPromotions(data.promotions);
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª',
        variant: 'destructive'
      });
    } finally {
      setLoading(false);
    }
  };

  const createYear = async () => {
    try {
      setCreating(true);
      const response = await fetch('/api/academic-years', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...newYear,
          isCurrent: true
        })
      });

      const data = await response.json();

      if (response.ok) {
        toast({
          title: 'ØªÙ… Ø¨Ù†Ø¬Ø§Ø­',
          description: data.message
        });
        setShowCreateDialog(false);
        setNewYear({ name: '', startDate: '', endDate: '' });
        fetchYears();
      } else {
        throw new Error(data.error);
      }
    } catch (error: any) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©',
        variant: 'destructive'
      });
    } finally {
      setCreating(false);
    }
  };

  const initiatePromotions = async () => {
    try {
      setLoading(true);
      toast({
        title: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...',
        description: 'Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù„Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±...',
      });

      const response = await fetch('/api/academic-years/promotions/initiate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ academicYearId: selectedYear })
      });

      const data = await response.json();

      if (response.ok) {
        setShowConfetti(true);
        setTimeout(() => setShowConfetti(false), 5000);

        toast({
          title: 'ğŸ‰ ØªÙ… Ø¨Ù†Ø¬Ø§Ø­!',
          description: data.message,
        });
        setShowInitiateDialog(false);
        fetchStats();
      } else {
        throw new Error(data.error);
      }
    } catch (error: any) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ù‚ÙŠØ©',
        variant: 'destructive'
      });
    } finally {
      setLoading(false);
    }
  };

  const getStatusBadge = (status: string, parentResponse: string | null) => {
    switch (status) {
      case 'pending':
        return <Badge variant="secondary" className="gap-1"><Clock className="h-3 w-3" />ÙÙŠ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±</Badge>;
      case 'approved':
        return <Badge variant="default" className="gap-1 bg-green-500"><CheckCircle2 className="h-3 w-3" />Ù†Ø¬Ø­</Badge>;
      case 'rejected':
        return <Badge variant="destructive" className="gap-1"><XCircle className="h-3 w-3" />Ù„Ù… ÙŠÙ†Ø¬Ø­</Badge>;
      case 'completed':
        return <Badge variant="default" className="gap-1 bg-blue-500"><GraduationCap className="h-3 w-3" />Ù…ÙƒØªÙ…Ù„</Badge>;
      default:
        return <Badge variant="outline">{status}</Badge>;
    }
  };

  const selectedYearData = years.find(y => y.id === selectedYear);

  return (
    <div className="container mx-auto p-6 space-y-6">
      {showConfetti && <Confetti width={width} height={height} recycle={false} numberOfPieces={500} />}

      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold flex items-center gap-2">
            <GraduationCap className="h-8 w-8" />
            Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª ÙˆØ§Ù„Ø³Ù†ÙˆØ§Øª Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©
          </h1>
          <p className="text-muted-foreground mt-2">
            Ø¥Ø¯Ø§Ø±Ø© Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©
          </p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={fetchStats} disabled={loading || !selectedYear}>
            <RefreshCw className={`h-4 w-4 ml-2 ${loading ? 'animate-spin' : ''}`} />
            ØªØ­Ø¯ÙŠØ«
          </Button>
          <Button onClick={() => setShowCreateDialog(true)}>
            <Plus className="h-4 w-4 ml-2" />
            Ø³Ù†Ø© Ø¯Ø±Ø§Ø³ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©
          </Button>
        </div>
      </div>

      {/* Academic Year Selector */}
      <Card>
        <CardHeader>
          <CardTitle>Ø§Ø®ØªØ± Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            {years.map(year => (
              <Card 
                key={year.id}
                className={`cursor-pointer transition-all ${
                  selectedYear === year.id 
                    ? 'border-primary border-2 bg-primary/5' 
                    : 'hover:border-primary/50'
                }`}
                onClick={() => setSelectedYear(year.id)}
              >
                <CardHeader className="pb-3">
                  <div className="flex items-center justify-between">
                    <CardTitle className="text-lg">{year.name}</CardTitle>
                    {year.isCurrent && (
                      <Badge variant="default">Ø§Ù„Ø­Ø§Ù„ÙŠØ©</Badge>
                    )}
                  </div>
                </CardHeader>
                <CardContent>
                  <div className="space-y-2 text-sm">
                    <div className="flex items-center gap-2">
                      <Calendar className="h-4 w-4 text-muted-foreground" />
                      <span>
                        {new Date(year.startDate).toLocaleDateString('ar')} - 
                        {new Date(year.endDate).toLocaleDateString('ar')}
                      </span>
                    </div>
                    <div className="flex items-center gap-2">
                      <Users className="h-4 w-4 text-muted-foreground" />
                      <span>{year._count.promotions} ØªØ±Ù‚ÙŠØ©</span>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        </CardContent>
      </Card>

      {selectedYear && stats && (
        <>
          {/* Statistics Cards */}
          <div className="grid grid-cols-1 md:grid-cols-5 gap-4">
            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø§Ø¨</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{stats.total}</div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="text-sm font-medium">ÙÙŠ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold text-yellow-600">{stats.pending}</div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="text-sm font-medium">Ù†Ø¬Ø­</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold text-green-600">{stats.approved}</div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="text-sm font-medium">Ù„Ù… ÙŠÙ†Ø¬Ø­</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold text-red-600">{stats.rejected}</div>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-3">
                <CardTitle className="text-sm font-medium">Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold text-blue-600">{stats.responseRate}%</div>
              </CardContent>
            </Card>
          </div>

          {/* Action Button */}
          {stats.total === 0 && (
            <Card className="bg-gradient-to-r from-blue-50 to-indigo-50 border-2 border-dashed">
              <CardContent className="pt-6">
                <div className="text-center space-y-4">
                  <Send className="h-12 w-12 mx-auto text-primary" />
                  <div>
                    <h3 className="text-lg font-semibold">Ø§Ø¨Ø¯Ø£ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ù‚ÙŠØ©</h3>
                    <p className="text-muted-foreground mt-2">
                      Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ± Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø± Ø¹Ù† Ù†ØªØ§Ø¦Ø¬ Ø£Ø¨Ù†Ø§Ø¦Ù‡Ù…
                    </p>
                  </div>
                  <Button size="lg" onClick={() => setShowInitiateDialog(true)}>
                    <Send className="h-4 w-4 ml-2" />
                    Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø±
                  </Button>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Promotions Table */}
          {stats.total > 0 && (
            <Card>
              <CardHeader>
                <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª</CardTitle>
                <CardDescription>
                  Ø¬Ù…ÙŠØ¹ Ø·Ù„Ø¨Ø§Øª Ø§Ù„ØªØ±Ù‚ÙŠØ© Ù„Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© {selectedYearData?.name}
                </CardDescription>
              </CardHeader>
              <CardContent>
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Ø§Ù„Ø·Ø§Ù„Ø¨</TableHead>
                      <TableHead>ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±</TableHead>
                      <TableHead>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ</TableHead>
                      <TableHead>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ</TableHead>
                      <TableHead>Ø§Ù„Ø­Ø§Ù„Ø©</TableHead>
                      <TableHead>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø±Ø³Ø§Ù„</TableHead>
                      <TableHead>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø±Ø¯</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {promotions.map(promotion => (
                      <TableRow key={promotion.id}>
                        <TableCell>
                          <div>
                            <div className="font-medium">
                              {promotion.student.firstName} {promotion.student.lastName}
                            </div>
                            <div className="text-sm text-muted-foreground">
                              {promotion.student.email}
                            </div>
                          </div>
                        </TableCell>
                        <TableCell>
                          <div>
                            <div className="font-medium">
                              {promotion.parent.firstName} {promotion.parent.lastName}
                            </div>
                            <div className="text-sm text-muted-foreground">
                              {promotion.parent.email}
                            </div>
                          </div>
                        </TableCell>
                        <TableCell>{promotion.fromLevel.name}</TableCell>
                        <TableCell>
                          {promotion.toLevel?.name || (
                            <Badge variant="secondary">Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Badge>
                          )}
                        </TableCell>
                        <TableCell>
                          {getStatusBadge(promotion.status, promotion.parentResponse)}
                        </TableCell>
                        <TableCell>
                          {promotion.notifiedAt 
                            ? formatDistanceToNow(new Date(promotion.notifiedAt), {
                                addSuffix: true,
                                locale: ar
                              })
                            : '-'}
                        </TableCell>
                        <TableCell>
                          {promotion.respondedAt 
                            ? formatDistanceToNow(new Date(promotion.respondedAt), {
                                addSuffix: true,
                                locale: ar
                              })
                            : '-'}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </CardContent>
            </Card>
          )}
        </>
      )}

      {/* Create Year Dialog */}
      <Dialog open={showCreateDialog} onOpenChange={setShowCreateDialog}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Ø¥Ù†Ø´Ø§Ø¡ Ø³Ù†Ø© Ø¯Ø±Ø§Ø³ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©</DialogTitle>
            <DialogDescription>
              Ø£Ø¯Ø®Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <div>
              <Label>Ø§Ø³Ù… Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</Label>
              <Input
                placeholder="Ù…Ø«Ø§Ù„: 2024-2025"
                value={newYear.name}
                onChange={(e) => setNewYear({ ...newYear, name: e.target.value })}
              />
            </div>
            <div>
              <Label>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (1 Ø³Ø¨ØªÙ…Ø¨Ø±)</Label>
              <Input
                type="date"
                value={newYear.startDate}
                onChange={(e) => setNewYear({ ...newYear, startDate: e.target.value })}
              />
            </div>
            <div>
              <Label>ØªØ§Ø±ÙŠØ® Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (30 Ø¬ÙˆØ§Ù†)</Label>
              <Input
                type="date"
                value={newYear.endDate}
                onChange={(e) => setNewYear({ ...newYear, endDate: e.target.value })}
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowCreateDialog(false)}>
              Ø¥Ù„ØºØ§Ø¡
            </Button>
            <Button onClick={createYear} disabled={creating || !newYear.name || !newYear.startDate || !newYear.endDate}>
              {creating ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡...' : 'Ø¥Ù†Ø´Ø§Ø¡'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Initiate Promotions Dialog */}
      <AlertDialog open={showInitiateDialog} onOpenChange={setShowInitiateDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="flex items-center gap-2">
              <Send className="h-5 w-5 text-primary" />
              ØªØ£ÙƒÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø§Ø³ØªÙØ³Ø§Ø±
            </AlertDialogTitle>
            <AlertDialogDescription>
              <div className="space-y-2 text-right">
                <p>Ø³ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø£Ù…ÙˆØ± Ø§Ù„Ø·Ù„Ø§Ø¨ ØªØ·Ù„Ø¨ Ù…Ù†Ù‡Ù… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù†:</p>
                <div className="bg-muted p-4 rounded-lg my-4">
                  <p className="font-semibold text-foreground">
                    "Ù‡Ù„ Ù†Ø¬Ø­ Ø§Ø¨Ù†Ùƒ/Ø§Ø¨Ù†ØªÙƒ ÙÙŠ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø£Ø¹Ù„Ù‰ØŸ"
                  </p>
                </div>
                <p>Ø¨Ø¹Ø¯ Ø±Ø¯ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±ØŒ Ø³ÙŠØªÙ…:</p>
                <ul className="list-disc list-inside space-y-1 text-foreground">
                  <li>ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø·Ø§Ù„Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù†Ø§Ø¬Ø­Ø§Ù‹</li>
                  <li>Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªÙ‡Ù†Ø¦Ø© Ù„Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ù†Ø§Ø¬Ø­ ğŸ‰</li>
                  <li>Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© ØªØ´Ø¬ÙŠØ¹ Ù„Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ø°ÙŠ Ù„Ù… ÙŠÙ†Ø¬Ø­ ğŸ’ª</li>
                </ul>
              </div>
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Ø¥Ù„ØºØ§Ø¡</AlertDialogCancel>
            <AlertDialogAction onClick={initiatePromotions}>
              Ù†Ø¹Ù…ØŒ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/directeur/backup/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { 
  Table, 
  TableBody, 
  TableCell, 
  TableHead, 
  TableHeader, 
  TableRow 
} from '@/components/ui/table';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Database, Download, Trash2, RefreshCw, AlertTriangle, CheckCircle2 } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { formatDistanceToNow } from 'date-fns';
import { ar } from 'date-fns/locale';

interface Backup {
  id: string;
  filename: string;
  filepath: string;
  size: number;
  sizeInMB: string;
  type: string;
  status: string;
  createdAt: string;
  createdBy: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
  };
}

export default function BackupPage() {
  const [backups, setBackups] = useState<Backup[]>([]);
  const [loading, setLoading] = useState(false);
  const [creating, setCreating] = useState(false);
  const [deleteId, setDeleteId] = useState<string | null>(null);
  const [restoreId, setRestoreId] = useState<string | null>(null);
  const { toast } = useToast();

  useEffect(() => {
    fetchBackups();
  }, []);

  const fetchBackups = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/backup/export');
      if (response.ok) {
        const data = await response.json();
        setBackups(data.backups);
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©',
        variant: 'destructive'
      });
    } finally {
      setLoading(false);
    }
  };

  const createBackup = async () => {
    try {
      setCreating(true);
      toast({
        title: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡...',
        description: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø©ØŒ Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ù‡Ø°Ø§ Ø¨Ø¶Ø¹ Ø¯Ù‚Ø§Ø¦Ù‚...',
      });

      const response = await fetch('/api/backup/export', {
        method: 'POST',
      });

      const data = await response.json();

      if (response.ok) {
        toast({
          title: 'ØªÙ… Ø¨Ù†Ø¬Ø§Ø­',
          description: `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: ${data.backup.filename}`,
        });

        // Auto-download the file
        if (data.backup.id) {
          const link = document.createElement('a');
          link.href = `/api/backup/${data.backup.id}`;
          link.download = data.backup.filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        fetchBackups();
      } else {
        throw new Error(data.details || data.error);
      }
    } catch (error: any) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©',
        variant: 'destructive'
      });
    } finally {
      setCreating(false);
    }
  };

  const deleteBackup = async (id: string) => {
    try {
      const response = await fetch(`/api/backup/${id}`, {
        method: 'DELETE',
      });

      if (response.ok) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø­Ø°Ù',
          description: 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
        });
        fetchBackups();
      } else {
        throw new Error('ÙØ´Ù„ Ø§Ù„Ø­Ø°Ù');
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©',
        variant: 'destructive'
      });
    } finally {
      setDeleteId(null);
    }
  };

  const restoreBackup = async (id: string) => {
    try {
      toast({
        title: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø©...',
        description: 'Ø¬Ø§Ø±ÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ù‡Ø°Ø§ Ø¨Ø¶Ø¹ Ø¯Ù‚Ø§Ø¦Ù‚...',
      });

      const response = await fetch('/api/backup/import', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ backupId: id }),
      });

      const data = await response.json();

      if (response.ok) {
        toast({
          title: 'ØªÙ… Ø¨Ù†Ø¬Ø§Ø­',
          description: 'ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­',
        });
      } else {
        throw new Error(data.error);
      }
    } catch (error: any) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©',
        variant: 'destructive'
      });
    } finally {
      setRestoreId(null);
    }
  };

  return (
    <div className="container mx-auto p-6 space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold flex items-center gap-2">
            <Database className="h-8 w-8" />
            Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ
          </h1>
          <p className="text-muted-foreground mt-2">
            Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
          </p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={fetchBackups} disabled={loading}>
            <RefreshCw className={`h-4 w-4 ml-2 ${loading ? 'animate-spin' : ''}`} />
            ØªØ­Ø¯ÙŠØ«
          </Button>
          <Button onClick={createBackup} disabled={creating}>
            <Download className="h-4 w-4 ml-2" />
            {creating ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡...' : 'Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©'}
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©</CardTitle>
          <CardDescription>
            Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
          </CardDescription>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="text-center py-8 text-muted-foreground">
              Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...
            </div>
          ) : backups.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              <Database className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©</p>
              <p className="text-sm mt-2">Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø¨Ø¯Ø¡</p>
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù</TableHead>
                  <TableHead>Ø§Ù„Ø­Ø¬Ù…</TableHead>
                  <TableHead>Ø§Ù„Ù†ÙˆØ¹</TableHead>
                  <TableHead>Ø§Ù„Ø­Ø§Ù„Ø©</TableHead>
                  <TableHead>ØªÙ… Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡</TableHead>
                  <TableHead>Ø¨ÙˆØ§Ø³Ø·Ø©</TableHead>
                  <TableHead className="text-left">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {backups.map((backup) => (
                  <TableRow key={backup.id}>
                    <TableCell className="font-medium">
                      {backup.filename}
                    </TableCell>
                    <TableCell>{backup.sizeInMB} MB</TableCell>
                    <TableCell>
                      <Badge variant="outline">{backup.type}</Badge>
                    </TableCell>
                    <TableCell>
                      {backup.status === 'COMPLETED' ? (
                        <Badge variant="default" className="gap-1">
                          <CheckCircle2 className="h-3 w-3" />
                          Ù…ÙƒØªÙ…Ù„
                        </Badge>
                      ) : (
                        <Badge variant="destructive" className="gap-1">
                          <AlertTriangle className="h-3 w-3" />
                          {backup.status}
                        </Badge>
                      )}
                    </TableCell>
                    <TableCell>
                      {formatDistanceToNow(new Date(backup.createdAt), {
                        addSuffix: true,
                        locale: ar
                      })}
                    </TableCell>
                    <TableCell>
                      {backup.createdBy.firstName} {backup.createdBy.lastName}
                    </TableCell>
                    <TableCell>
                      <div className="flex gap-2">
                        <Button size="sm" variant="ghost" asChild>
                          <a href={`/api/backup/${backup.id}`} download>
                            <Download className="h-4 w-4" />
                          </a>
                        </Button>
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => setRestoreId(backup.id)}
                          disabled={backup.status !== 'COMPLETED'}
                        >
                          <RefreshCw className="h-4 w-4 ml-1" />
                          Ø§Ø³ØªØ¹Ø§Ø¯Ø©
                        </Button>
                        <Button
                          size="sm"
                          variant="destructive"
                          onClick={() => setDeleteId(backup.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={!!deleteId} onOpenChange={() => setDeleteId(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù</AlertDialogTitle>
            <AlertDialogDescription>
              Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©ØŸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Ø¥Ù„ØºØ§Ø¡</AlertDialogCancel>
            <AlertDialogAction onClick={() => deleteId && deleteBackup(deleteId)}>
              Ø­Ø°Ù
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Restore Confirmation Dialog */}
      <AlertDialog open={!!restoreId} onOpenChange={() => setRestoreId(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle className="flex items-center gap-2 text-destructive">
              <AlertTriangle className="h-5 w-5" />
              ØªØ­Ø°ÙŠØ±: Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
            </AlertDialogTitle>
            <AlertDialogDescription>
              <div className="space-y-2">
                <p className="font-semibold">
                  Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¨Ù‡Ø°Ù‡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©!
                </p>
                <p>
                  Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© (Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†ØŒ Ø§Ù„Ø¯Ø±ÙˆØ³ØŒ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†ØŒ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ØŒ Ø¥Ù„Ø®) 
                  Ø³ÙŠØªÙ… Ø­Ø°ÙÙ‡Ø§ ÙˆØ§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡Ø§ Ø¨Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©.
                </p>
                <p className="text-destructive font-semibold">
                  Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ
                </p>
              </div>
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Ø¥Ù„ØºØ§Ø¡</AlertDialogCancel>
            <AlertDialogAction 
              onClick={() => restoreId && restoreBackup(restoreId)}
              className="bg-destructive hover:bg-destructive/90"
            >
              Ù†Ø¹Ù…ØŒ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/_components/StudentDashboard.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { BarChart2, BookCheck, Link as LinkIcon, PlayCircle, Loader2 } from "lucide-react";
import Link from "next/link";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useSession } from "next-auth/react";
import { useToast } from "@/hooks/use-toast";

export default function StudentDashboard() {
  const { data: session, status } = useSession();
  const { toast } = useToast();
  const [stats, setStats] = useState({
    completedLessons: 0,
    totalSubmissions: 0,
    averageScore: 0,
    pendingExercises: 0,
  });
  const [studentInfo, setStudentInfo] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [teacherCode, setTeacherCode] = useState('');
  const [teachers, setTeachers] = useState<any[]>([]);
  const [connecting, setConnecting] = useState(false);

  useEffect(() => {
    if (session?.user) {
      fetchStudentStats();
      fetchStudentInfo();
      fetchTeachers();
    }
  }, [session]);

  const fetchStudentInfo = async () => {
    try {
      const response = await fetch(`/api/users/${session?.user?.id}`);
      const result = await response.json();
      
      if (result.success && result.data) {
        setStudentInfo(result.data);
      }
    } catch (error) {
      console.error('Error fetching student info:', error);
    }
  };

  const fetchStudentStats = async () => {
    try {
      setLoading(true);
      
      const response = await fetch('/api/students/stats');
      const result = await response.json();
      
      if (result.success && result.data?.stats) {
        setStats(result.data.stats);
      }
    } catch (error) {
      console.error('Error fetching student stats:', error);
    } finally {
      setLoading(false);
    }
  };

  const fetchTeachers = async () => {
    try {
      const response = await fetch('/api/students/teachers');
      const result = await response.json();
      if (result.success) {
        setTeachers(result.data?.teachers || []);
      }
    } catch (error) {
      console.error('Error fetching teachers:', error);
    }
  };

  if (status === 'loading' || loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!session?.user) {
    return <div>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø§Ù„Ø¨.</div>;
  }

  const handleConnectTeacher = async () => {
    if (!teacherCode.trim()) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³ØªØ§Ø°",
        variant: "destructive",
      });
      return;
    }

    setConnecting(true);
    try {
      const response = await fetch('/api/students/connect-teacher', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ teacherCode: teacherCode.trim() }),
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: "ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­",
          description: `ØªÙ… Ø±Ø¨Ø·Ùƒ Ø¨Ø§Ù„Ø£Ø³ØªØ§Ø° ${result.data.teacher.name}`,
        });
        setTeacherCode('');
        fetchTeachers();
      } else {
        toast({
          title: "ÙØ´Ù„ Ø§Ù„Ø±Ø¨Ø·",
          description: result.error || "ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³ØªØ§Ø° ØºÙŠØ± ØµØ­ÙŠØ­",
          variant: "destructive",
        });
      }
    } catch (error) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø¨Ø·",
        variant: "destructive",
      });
    } finally {
      setConnecting(false);
    }
  };

  const handleDisconnectTeacher = async (teacherId: string) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³ØªØ§Ø°ØŸ')) return;

    try {
      const response = await fetch(`/api/students/connect-teacher?teacherId=${teacherId}`, {
        method: 'DELETE',
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: "ØªÙ… ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·",
          description: "ØªÙ… ÙÙƒ Ø§Ø±ØªØ¨Ø§Ø·Ùƒ Ø¨Ø§Ù„Ø£Ø³ØªØ§Ø° Ø¨Ù†Ø¬Ø§Ø­",
        });
        fetchTeachers();
      } else {
        toast({
          title: "ÙØ´Ù„ ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·",
          description: result.error || "Ø­Ø¯Ø« Ø®Ø·Ø£",
          variant: "destructive",
        });
      }
    } catch (error) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·",
        variant: "destructive",
      });
    }
  };

  return (
    <div className="flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <div className="grid gap-1">
            <h1 className="text-3xl font-bold tracking-tight">
                Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ØŒ {session.user.name}!
            </h1>
            <p className="text-muted-foreground">
                {studentInfo?.userDetails?.level?.name ? (
                  <span>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ: <strong>{studentInfo.userDetails.level.name}</strong> â€¢ Ù„Ù†ÙˆØ§ØµÙ„ Ø±Ø­Ù„ØªÙ†Ø§ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ© ÙˆÙ†Ø­Ù‚Ù‚ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªÙ‚Ø¯Ù….</span>
                ) : (
                  <span>Ù„Ù†ÙˆØ§ØµÙ„ Ø±Ø­Ù„ØªÙ†Ø§ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ© ÙˆÙ†Ø­Ù‚Ù‚ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªÙ‚Ø¯Ù….</span>
                )}
            </p>
        </div>
      </div>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©</CardTitle>
            <BookCheck className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.completedLessons}</div>
            <p className="text-xs text-muted-foreground">Ù…Ù† Ø£ØµÙ„ Ø¯Ø±ÙˆØ³Ùƒ</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙˆÙ„Ø©</CardTitle>
            <PlayCircle className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.totalSubmissions}</div>
            <p className="text-xs text-muted-foreground">Ø¥Ø¬Ø§Ø¨Ø§Øª Ù…Ø±Ø³Ù„Ø©</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª</CardTitle>
            <BarChart2 className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.averageScore}%</div>
            <p className="text-xs text-muted-foreground">Ù…Ù† 100%</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">ØªÙ…Ø§Ø±ÙŠÙ† Ù‚ÙŠØ¯ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±</CardTitle>
            <BookCheck className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.pendingExercises}</div>
            <p className="text-xs text-muted-foreground">Ù„Ù… ÙŠØªÙ… Ø­Ù„Ù‡Ø§</p>
          </CardContent>
        </Card>
      </div>
      
      <div className="grid gap-6 md:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <LinkIcon className="text-primary" />
              <span>Ø±Ø¨Ø· Ø£Ø³ØªØ§Ø° Ø¬Ø¯ÙŠØ¯</span>
            </CardTitle>
            <CardDescription>
              Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³ØªØ§Ø° Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø¯Ø±ÙˆØ³Ù‡ ÙˆØªÙ…Ø§Ø±ÙŠÙ‡.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Input 
                id="teacher-code" 
                placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³ØªØ§Ø° Ù‡Ù†Ø§" 
                value={teacherCode}
                onChange={(e) => setTeacherCode(e.target.value.toUpperCase())}
                disabled={connecting}
              />
              <Button onClick={handleConnectTeacher} disabled={connecting}>
                {connecting && <Loader2 className="ml-2 h-4 w-4 animate-spin" />}
                Ø±Ø¨Ø·
              </Button>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <BookCheck className="text-primary" />
              <span>Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙˆÙ†</span>
            </CardTitle>
            <CardDescription>
              Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„Ø°ÙŠÙ† Ø£Ù†Øª Ù…Ø±ØªØ¨Ø· Ø¨Ù‡Ù… Ø­Ø§Ù„ÙŠØ§Ù‹.
            </CardDescription>
          </CardHeader>
          <CardContent>
            {teachers.length > 0 ? (
              <div className="space-y-3">
                {teachers.map((teacher) => (
                  <div key={teacher.id} className="flex items-center justify-between rounded-lg border p-3">
                    <div className="flex items-center gap-3">
                      <Avatar className="h-10 w-10">
                        <AvatarImage src={teacher.image} alt={teacher.name} />
                        <AvatarFallback>{teacher.name.charAt(0)}</AvatarFallback>
                      </Avatar>
                      <div>
                        <p className="font-semibold">{teacher.name}</p>
                        <p className="text-xs text-muted-foreground">{teacher.subject?.name || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</p>
                      </div>
                    </div>
                    <Button 
                      variant="ghost" 
                      size="sm"
                      onClick={() => handleDisconnectTeacher(teacher.id)}
                    >
                      ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·
                    </Button>
                  </div>
                ))}
              </div>
            ) : (
              <p className="text-center text-muted-foreground py-4">
                Ù„Ù… ØªÙ‚Ù… Ø¨Ø§Ù„Ø±Ø¨Ø· Ø¨Ø£ÙŠ Ø£Ø³ØªØ§Ø° Ø¨Ø¹Ø¯
              </p>
            )}
          </CardContent>
        </Card>
      </div>

    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/_components/ParentDashboard.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Users, BarChart2, MessageSquare, Copy, Loader2 } from "lucide-react";
import Link from "next/link";
import { Input } from "@/components/ui/input";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useToast } from "@/hooks/use-toast";

type Child = {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    level: {
        id: number;
        name: string;
        stage: {
            id: number;
            name: string;
        };
    } | null;
};

type ParentData = {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    parentCode: string | null;
};

type Stats = {
    totalChildren: number;
    totalSubmissions: number;
    averageScore: number;
    unreadMessages: number;
};

export default function ParentDashboard() {
    const { data: session } = useSession();
    const { toast } = useToast();
    const [parent, setParent] = useState<ParentData | null>(null);
    const [children, setChildren] = useState<Child[]>([]);
    const [stats, setStats] = useState<Stats | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [isGenerating, setIsGenerating] = useState(false);

    const fetchDashboard = async () => {
        try {
            setIsLoading(true);
            const response = await fetch('/api/parents/dashboard');
            const result = await response.json();
            if (result.success) {
                setParent(result.data.parent);
                setChildren(result.data.children);
                setStats(result.data.stats);
            }
        } catch (error) {
            console.error('Error fetching parent dashboard:', error);
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        if (session?.user) {
            fetchDashboard();
        }
    }, [session]);

    const handleCopy = () => {
        if (parent?.parentCode) {
            navigator.clipboard.writeText(parent.parentCode);
            toast({
                title: "ØªÙ… Ø§Ù„Ù†Ø³Ø®!",
                description: "ØªÙ… Ù†Ø³Ø® ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©.",
            });
        }
    };

    const handleGenerateCode = async () => {
        try {
            setIsGenerating(true);
            const response = await fetch('/api/parents/generate-code', {
                method: 'POST',
            });
            const result = await response.json();
            
            if (result.success) {
                toast({
                    title: "ØªÙ… Ø¨Ù†Ø¬Ø§Ø­!",
                    description: result.data.message,
                });
                // Refresh dashboard data
                await fetchDashboard();
            } else {
                toast({
                    title: "Ø®Ø·Ø£",
                    description: result.error || "ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯",
                    variant: "destructive",
                });
            }
        } catch (error) {
            toast({
                title: "Ø®Ø·Ø£",
                description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯",
                variant: "destructive",
            });
        } finally {
            setIsGenerating(false);
        }
    };

    if (isLoading) {
        return (
            <div className="flex items-center justify-center min-h-[400px]">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
        );
    }

    if (!parent) {
        return <div>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±.</div>;
    }

    const parentName = `${parent.firstName} ${parent.lastName}`; 

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">
                        Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ {parentName}!
                    </h1>
                    <p className="text-muted-foreground">
                        Ù‡Ø°Ù‡ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ Ù„Ù…ØªØ§Ø¨Ø¹Ø© ØªÙ‚Ø¯Ù… Ø£Ø¨Ù†Ø§Ø¦Ùƒ.
                    </p>
                </div>
            </div>

            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙˆÙ†</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats?.totalChildren || 0}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª</CardTitle>
                        <BarChart2 className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats?.averageScore || 0}%</div>
                        <p className="text-xs text-muted-foreground">Ù…ØªÙˆØ³Ø· Ø¯Ø±Ø¬Ø§Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ØºÙŠØ± Ø§Ù„Ù…Ù‚Ø±ÙˆØ¡Ø©</CardTitle>
                        <MessageSquare className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats?.unreadMessages || 0}</div>
                        <p className="text-xs text-muted-foreground">Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ø¦Ù„ Ø¬Ø¯ÙŠØ¯Ø©</p>
                    </CardContent>
                </Card>
            </div>
            
            <div className="grid gap-6 lg:grid-cols-2">
                <Card>
                    <CardHeader>
                        <CardTitle>ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ</CardTitle>
                        <CardDescription>
                            Ø´Ø§Ø±Ùƒ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¹ Ø£Ø¨Ù†Ø§Ø¦Ùƒ Ù„Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ø§ØªÙ‡Ù… Ø¨Ø­Ø³Ø§Ø¨Ùƒ. Ø¹Ù†Ø¯ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯ Ø³ÙŠØªÙ… ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø³Ø§Ø¨Ù‚ÙŠÙ†.
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="space-y-4">
                        <div className="flex items-center gap-4">
                            <Input 
                                readOnly 
                                value={parent.parentCode || 'Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø¨Ø¹Ø¯'} 
                                className="text-lg font-mono tracking-widest text-center" 
                            />
                            <Button variant="outline" onClick={handleCopy} disabled={!parent.parentCode}>
                                <Copy className="ml-2 h-4 w-4" />
                                Ù†Ø³Ø®
                            </Button>
                        </div>
                        <Button 
                            onClick={handleGenerateCode} 
                            disabled={isGenerating}
                            className="w-full"
                            variant={parent.parentCode ? "destructive" : "default"}
                        >
                            {isGenerating ? (
                                <>
                                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                                    Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙˆÙ„ÙŠØ¯...
                                </>
                            ) : parent.parentCode ? (
                                'ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯ (Ø³ÙŠÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡)'
                            ) : (
                                'ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø·'
                            )}
                        </Button>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader>
                        <CardTitle>Ø±ÙˆØ§Ø¨Ø· Ø³Ø±ÙŠØ¹Ø©</CardTitle>
                    </CardHeader>
                    <CardContent className="grid grid-cols-2 gap-4">
                        <Link href="/dashboard/parent/children" passHref><Button variant="secondary" className="w-full justify-start">Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡</Button></Link>
                        <Link href="/dashboard/parent/reports" passHref><Button variant="secondary" className="w-full justify-start">Ø¹Ø±Ø¶ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±</Button></Link>
                        <Link href="/messages" passHref><Button variant="secondary" className="w-full justify-start">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„</Button></Link>
                        <Link href="/profile" passHref><Button variant="secondary" className="w-full justify-start">Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ</Button></Link>
                    </CardContent>
                </Card>
            </div>
            
            <Card>
                <CardHeader>
                    <CardTitle className="flex justify-between items-center">
                        <span>Ù†Ø¸Ø±Ø© Ø³Ø±ÙŠØ¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡</span>
                         <Link href="/dashboard/parent/children" passHref>
                            <Button variant="ghost" size="sm">
                                <span>Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙ„</span>
                            </Button>
                        </Link>
                    </CardTitle>
                    <CardDescription>Ø¢Ø®Ø± Ø§Ù„Ù†Ø´Ø§Ø·Ø§Øª ÙˆØ§Ù„ØªÙ‚Ø¯Ù… Ù„Ø£Ø¨Ù†Ø§Ø¦Ùƒ.</CardDescription>
                </CardHeader>
                <CardContent>
                    {children.length > 0 ? (
                        <div className="space-y-4">
                            {children.map(child => {
                                const childName = `${child.firstName} ${child.lastName}`;
                                const childInitial = child.firstName.charAt(0);
                                return (
                                    <div key={child.id} className="flex items-center justify-between p-3 rounded-lg border bg-muted/50">
                                        <div className="flex items-center gap-4">
                                            <Avatar>
                                                <AvatarFallback>{childInitial}</AvatarFallback>
                                            </Avatar>
                                            <div>
                                                <p className="font-semibold">{childName}</p>
                                                <p className="text-sm text-muted-foreground">
                                                    {child.level ? `${child.level.stage.name} - ${child.level.name}` : 'Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³ØªÙˆÙ‰'}
                                                </p>
                                            </div>
                                        </div>
                                        <div className="flex gap-2">
                                            <Link href={`/dashboard/parent/children/${child.id}/subjects`} passHref>
                                                <Button variant="default" size="sm">
                                                    <span>Ø§Ù„Ù…ÙˆØ§Ø¯</span>
                                                </Button>
                                            </Link>
                                            <Link href={`/dashboard/parent/children/${child.id}`} passHref>
                                                <Button variant="outline" size="sm">
                                                    <span>Ø§Ù„ØªÙØ§ØµÙŠÙ„</span>
                                                </Button>
                                            </Link>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    ) : (
                        <p className="text-muted-foreground text-center py-8">Ù„Ù… ÙŠØªÙ… Ø±Ø¨Ø· Ø£ÙŠ Ø£Ø¨Ù†Ø§Ø¡ Ø¨Ø¹Ø¯. Ø´Ø§Ø±Ùƒ ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ù…Ø¹ Ø£Ø¨Ù†Ø§Ø¦Ùƒ.</p>
                    )}
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/_components/TeacherDashboard.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Book, CheckCircle, ClipboardList, PlusCircle, Users, Link as LinkIcon, FileQuestion, MessageSquare, Copy, Loader2 } from "lucide-react";
import Link from "next/link";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { useSession } from "next-auth/react";


export default function TeacherDashboard() {
    const { toast } = useToast();
    const { data: session, status } = useSession();
    const [stats, setStats] = useState({
        lessons: 0,
        students: 0,
        exercises: 0,
        submissions: 0,
    });
    const [loading, setLoading] = useState(true);
    const [teacherCode, setTeacherCode] = useState('');
    const [generatingCode, setGeneratingCode] = useState(false);
    const [allowMessaging, setAllowMessaging] = useState(false);
    const [togglingMessaging, setTogglingMessaging] = useState(false);

    useEffect(() => {
        if (session?.user) {
            fetchDashboardData();
        }
    }, [session]);

    const fetchDashboardData = async () => {
        try {
            setLoading(true);
            const response = await fetch('/api/teachers/dashboard');
            const result = await response.json();
            
            if (result.success) {
                setTeacherCode(result.data.teacher.teacherCode || '');
                setAllowMessaging(result.data.teacher.allowMessaging || false);
                setStats({
                    lessons: result.data.stats.lessons,
                    students: result.data.stats.students,
                    exercises: result.data.stats.exercises,
                    submissions: result.data.stats.submissions,
                });
            }
        } catch (error) {
            console.error('Error fetching dashboard data:', error);
        } finally {
            setLoading(false);
        }
    };

    const handleToggleMessaging = async () => {
        try {
            setTogglingMessaging(true);
            const response = await fetch('/api/teachers/toggle-messaging', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ allowMessaging: !allowMessaging }),
            });
            const result = await response.json();
            
            if (result.success) {
                setAllowMessaging(!allowMessaging);
                toast({
                    title: "ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«",
                    description: result.data.message,
                });
            }
        } catch (error) {
            console.error('Error toggling messaging:', error);
            toast({
                title: "Ø®Ø·Ø£",
                description: "ÙØ´Ù„ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯",
                variant: "destructive",
            });
        } finally {
            setTogglingMessaging(false);
        }
    };

    if (status === 'loading' || loading) {
        return (
            <div className="flex items-center justify-center h-64">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
        );
    }

    if (!session?.user) {
        return <div>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ù„Ù….</div>;
    }

    const handleCopy = () => {
        const code = teacherCode || 'N/A';
        navigator.clipboard.writeText(code);
        toast({
            title: "ØªÙ… Ø§Ù„Ù†Ø³Ø®!",
            description: "ØªÙ… Ù†Ø³Ø® ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©.",
        });
    };

    const handleGenerateCode = async () => {
        try {
            setGeneratingCode(true);
            const response = await fetch('/api/users/generate-teacher-code', {
                method: 'POST',
            });
            const result = await response.json();
            
            if (result.success && result.data?.teacherCode) {
                setTeacherCode(result.data.teacherCode);
                // Refresh dashboard data
                await fetchDashboardData();
                toast({
                    title: "ØªÙ… Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­!",
                    description: "ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø±Ø¨Ø· Ø¬Ø¯ÙŠØ¯ ÙˆÙÙƒ Ø§Ø±ØªØ¨Ø§Ø· Ø§Ù„ØªÙ„Ø§Ù…ÙŠØ° Ø§Ù„Ø³Ø§Ø¨Ù‚ÙŠÙ†.",
                });
            } else {
                toast({
                    title: "ÙØ´Ù„ Ø§Ù„ØªÙˆÙ„ÙŠØ¯",
                    description: result.error || "Ø­Ø¯Ø« Ø®Ø·Ø£",
                    variant: "destructive",
                });
            }
        } catch (error) {
            console.error('Error generating code:', error);
            toast({
                title: "ÙØ´Ù„ Ø§Ù„ØªÙˆÙ„ÙŠØ¯",
                description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯",
                variant: "destructive",
            });
        } finally {
            setGeneratingCode(false);
        }
    };

    // Display submission stats
    const totalSubmissions = stats.submissions;
    const gradedSubmissions = 0; // TODO: Filter graded submissions
    const pendingSubmissions = totalSubmissions; // For now, all are pending
    const unreadMessages = 0; // TODO: Fetch from messages API

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">
                        Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ Ø£Ø³ØªØ§Ø°ØŒ {session?.user?.name || 'Ø§Ù„Ù…Ø¹Ù„Ù…'}!
                    </h1>
                    <p className="text-muted-foreground">
                        Ù‡Ø°Ù‡ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ ÙˆØ§Ù„Ø·Ù„Ø§Ø¨.
                    </p>
                </div>
                <Link href="/dashboard/teacher/lessons/create" passHref>
                    <Button>
                        <PlusCircle className="ml-2 h-4 w-4" />
                        <span>Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯</span>
                    </Button>
                </Link>
            </div>

            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…Ø¶Ø§ÙØ©</CardTitle>
                        <Book className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.lessons}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙˆÙ†</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.students}</div>
                        <p className="text-xs text-muted-foreground">Ø¹Ø¯Ø¯ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø¨Ùƒ</p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</CardTitle>
                        <FileQuestion className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.exercises}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ù…Ø¶Ø§ÙØ©</p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</CardTitle>
                        <MessageSquare className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{unreadMessages}</div>
                        <p className="text-xs text-muted-foreground">Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±</p>
                    </CardContent>
                </Card>
            </div>
            
            <div className="grid gap-6 md:grid-cols-2">
                 <Card>
                    <CardHeader>
                        <CardTitle className="flex items-center gap-2">
                            <LinkIcon className="text-primary" />
                            <span>ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ</span>
                        </CardTitle>
                        <CardDescription>
                            Ø´Ø§Ø±Ùƒ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¹ Ø·Ù„Ø§Ø¨Ùƒ Ù„Ø±Ø¨Ø·Ù‡Ù… Ø¨Ø­Ø³Ø§Ø¨Ùƒ.
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="space-y-4">
                        <div className="flex items-center gap-2">
                            <Input readOnly value={teacherCode || 'Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªÙˆÙ„ÙŠØ¯ Ø¨Ø¹Ø¯'} className="text-lg font-mono tracking-widest text-center" />
                            <Button variant="outline" onClick={handleCopy} disabled={!teacherCode}>
                                <Copy className="ml-2 h-4 w-4" />
                                Ù†Ø³Ø®
                            </Button>
                            <Button variant="default" onClick={handleGenerateCode} disabled={generatingCode}>
                                {generatingCode ? <Loader2 className="ml-2 h-4 w-4 animate-spin" /> : <PlusCircle className="ml-2 h-4 w-4" />}
                                {teacherCode ? 'ØªÙˆÙ„ÙŠØ¯ Ø¬Ø¯ÙŠØ¯' : 'ØªÙˆÙ„ÙŠØ¯'}
                            </Button>
                        </div>
                        <div className="flex items-center justify-between p-3 bg-muted rounded-lg">
                            <div className="flex items-center gap-2">
                                <MessageSquare className="h-5 w-5 text-primary" />
                                <div>
                                    <p className="font-medium text-sm">Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±</p>
                                    <p className="text-xs text-muted-foreground">Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ± Ø¨Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ø¦Ù„</p>
                                </div>
                            </div>
                            <Button 
                                variant={allowMessaging ? "default" : "outline"}
                                size="sm"
                                onClick={handleToggleMessaging}
                                disabled={togglingMessaging}
                            >
                                {togglingMessaging ? (
                                    <Loader2 className="h-4 w-4 animate-spin" />
                                ) : (
                                    allowMessaging ? 'Ù…ÙØ¹Ù‘Ù„' : 'ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„'
                                )}
                            </Button>
                        </div>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader>
                        <CardTitle>Ø±ÙˆØ§Ø¨Ø· Ø³Ø±ÙŠØ¹Ø©</CardTitle>
                    </CardHeader>
                    <CardContent className="grid grid-cols-2 gap-4">
                        <Link href="/dashboard/teacher/lessons" passHref><Button variant="secondary" className="w-full justify-start">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¯Ø±ÙˆØ³</Button></Link>
                        <Link href="/dashboard/teacher/students" passHref><Button variant="secondary" className="w-full justify-start">Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø§Ø¨</Button></Link>
                        <Link href="/dashboard/teacher/submissions" passHref><Button variant="secondary" className="w-full justify-start">ØªØµØ­ÙŠØ­ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª</Button></Link>
                        <Link href="/messages" passHref><Button variant="secondary" className="w-full justify-start">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„</Button></Link>
                    </CardContent>
                </Card>
            </div>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/_components/DirecteurDashboard.tsx
// ==========================================


'use client';

import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Users, BookCopy, BarChart3, CheckCircle, Clock, XCircle, Eye, Database, Settings, Loader2 } from "lucide-react";
import Link from "next/link";
import { format } from "date-fns";
import { ar } from "date-fns/locale";
import { useSession } from "next-auth/react";
import { useEffect, useState } from "react";

export default function DirecteurDashboard() {
    const { data: session } = useSession();
    const [stats, setStats] = useState({
        teachers: 0,
        students: 0,
        lessons: 0,
        subjects: 0,
    });
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchStats = async () => {
            try {
                const [usersRes, lessonsRes, subjectsRes] = await Promise.all([
                    fetch('/api/users'),
                    fetch('/api/lessons'),
                    fetch('/api/subjects'),
                ]);

                const users = usersRes.ok ? await usersRes.json() : [];
                const lessons = lessonsRes.ok ? await lessonsRes.json() : [];
                const subjects = subjectsRes.ok ? await subjectsRes.json() : [];

                setStats({
                    teachers: users.filter((u: any) => u.role === 'teacher' || u.role === 'supervisor_specific').length,
                    students: users.filter((u: any) => u.role === 'student').length,
                    lessons: lessons.length,
                    subjects: subjects.length,
                });
            } catch (error) {
                console.error('Error fetching stats:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchStats();
    }, []);

    if (loading) {
        return (
            <div className="flex items-center justify-center h-64">
                <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
        );
    }

    const getStatusVariant = (status?: string) => {
        switch (status) {
            case 'pending': return 'secondary';
            case 'approved': return 'default';
            case 'rejected': return 'destructive';
            default: return 'default';
        }
    };

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">
                        Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ {session?.user?.name}!
                    </h1>
                    <p className="text-muted-foreground">
                        Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©.
                    </p>
                </div>
            </div>

            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ù…Ø¹Ù„Ù…ÙˆÙ†</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.teachers}</div>
                        <p className="text-xs text-muted-foreground">Ø§Ù„Ø·Ø§Ù‚Ù… Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ</p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø·Ù„Ø§Ø¨</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.students}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø§Ø¨</p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø¯Ø±ÙˆØ³</CardTitle>
                        <BookCopy className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.lessons}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ù…ÙˆØ§Ø¯</CardTitle>
                        <BarChart3 className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{stats.subjects}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…ÙˆØ§Ø¯</p>
                    </CardContent>
                </Card>
            </div>

            <div className="grid gap-6 grid-cols-1">
                <Card>
                     <CardHeader>
                        <CardTitle>Ø±ÙˆØ§Ø¨Ø· Ø³Ø±ÙŠØ¹Ø©</CardTitle>
                        <CardDescription>
                            Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø³Ø±ÙŠØ¹ Ø¥Ù„Ù‰ Ø§Ù„ØµÙØ­Ø§Øª Ø§Ù„Ù…Ù‡Ù…Ø©.
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <Button variant="secondary" className="justify-start w-full" asChild>
                            <Link href="/dashboard/directeur/users"><Users className="ml-2"/>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</Link>
                        </Button>
                        <Button variant="secondary" className="justify-start w-full" asChild>
                            <Link href="/dashboard/directeur/content"><BookCopy className="ml-2"/>Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰</Link>
                        </Button>
                        <Button variant="secondary" className="justify-start w-full" asChild>
                            <Link href="/dashboard/directeur/database"><Database className="ml-2"/>Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</Link>
                        </Button>
                         <Button variant="secondary" className="justify-start w-full" asChild>
                            <Link href="/dashboard/directeur/settings"><Settings className="ml-2"/>Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</Link>
                        </Button>
                    </CardContent>
                </Card>
            </div>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/my-code/page.tsx
// ==========================================

'use client';

import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";

export const dynamic = 'force-dynamic';
import { Button } from "@/components/ui/button";
import { getTeacher, getUserById } from "@/lib/mock-data";
import { Input } from "@/components/ui/input";
import { Copy, RefreshCw } from "lucide-react";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
    AlertDialogTrigger,
} from "@/components/ui/alert-dialog"
import { useToast } from "@/hooks/use-toast";

// Mock current user ID. This would come from auth.
const MOCK_TEACHER_ID = 2;

export default function MyCodePage() {
    const { toast } = useToast();
    // This could be a teacher (2) or a supervisor acting as a teacher (7)
    const teacher = getUserById(MOCK_TEACHER_ID); 
    if (!teacher || !teacher.teacher_code) return <div>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¹Ù„Ù….</div>;

    const handleCopy = () => {
        if(teacher.teacher_code) {
            navigator.clipboard.writeText(teacher.teacher_code);
            toast({
                title: "ØªÙ… Ø§Ù„Ù†Ø³Ø®!",
                description: "ØªÙ… Ù†Ø³Ø® ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©.",
            });
        }
    };

    return (
        <div className="flex flex-col gap-8 max-w-2xl mx-auto">
            <div className="grid gap-1">
                <h1 className="text-3xl font-bold tracking-tight">ÙƒÙˆØ¯ÙŠ Ø§Ù„Ø®Ø§Øµ</h1>
                <p className="text-muted-foreground">
                    Ø¥Ø¯Ø§Ø±Ø© ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ø¹ Ø·Ù„Ø§Ø¨Ùƒ.
                </p>
            </div>

            <Card>
                <CardHeader>
                    <CardTitle>ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ø­Ø§Ù„ÙŠ</CardTitle>
                    <CardDescription>
                        Ø´Ø§Ø±Ùƒ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¹ Ø·Ù„Ø§Ø¨Ùƒ Ù„ÙŠØªÙ…ÙƒÙ†ÙˆØ§ Ù…Ù† Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø­Ø³Ø§Ø¨Ùƒ ÙˆØ§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø¯Ø±ÙˆØ³Ùƒ Ø§Ù„Ø®Ø§ØµØ©.
                    </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                    <div className="flex items-center gap-2">
                        <Input readOnly defaultValue={teacher.teacher_code} className="text-2xl font-mono tracking-widest text-center" />
                        <Button variant="outline" size="icon" onClick={handleCopy} aria-label="Ù†Ø³Ø® Ø§Ù„ÙƒÙˆØ¯">
                            <Copy className="h-5 w-5" />
                        </Button>
                    </div>
                    <p className="text-sm text-muted-foreground">
                        ÙŠÙ…ÙƒÙ† Ù„Ù„Ø·Ù„Ø§Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ ÙÙŠ ØµÙØ­Ø© Ù…Ù„ÙÙ‡Ù… Ø§Ù„Ø´Ø®ØµÙŠ Ù„Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ùƒ.
                    </p>
                </CardContent>
            </Card>
            
            <Card className="border-destructive">
                <CardHeader>
                    <CardTitle>Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯</CardTitle>
                    <CardDescription>
                        Ø³ÙŠØ¤Ø¯ÙŠ Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯ Ø¥Ù„Ù‰ Ø¬Ø¹Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­ØŒ ÙˆØ³ÙŠØªÙ… ÙØµÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø­Ø§Ù„ÙŠÙ‹Ø§.
                    </CardDescription>
                </CardHeader>
                <CardContent>
                     <AlertDialog>
                        <AlertDialogTrigger asChild>
                            <Button variant="destructive">
                                <RefreshCw className="ml-2 h-4 w-4" />
                                <span>Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯</span>
                            </Button>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                            <AlertDialogHeader>
                            <AlertDialogTitle>Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ ØªÙ…Ø§Ù…Ø§Ù‹ØŸ</AlertDialogTitle>
                            <AlertDialogDescription>
                                Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡. Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø±Ø¨Ø· Ø¬Ø¯ÙŠØ¯ ÙˆØ³ÙŠØªÙ… ÙØµÙ„ Ø¬Ù…ÙŠØ¹ Ø·Ù„Ø§Ø¨Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠÙŠÙ†. Ø³ÙŠØ­ØªØ§Ø¬ÙˆÙ† Ø¥Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ùƒ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.
                            </AlertDialogDescription>
                            </AlertDialogHeader>
                            <AlertDialogFooter>
                            <AlertDialogCancel>Ø¥Ù„ØºØ§Ø¡</AlertDialogCancel>
                            <AlertDialogAction>Ù†Ø¹Ù…ØŒ Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯</AlertDialogAction>
                            </AlertDialogFooter>
                        </AlertDialogContent>
                    </AlertDialog>
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/students/page.tsx
// ==========================================

import { requireAuth } from "@/lib/api-auth";
import { prisma } from "@/lib/prisma";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";

export const dynamic = 'force-dynamic';

export default async function MyStudentsPage() {
  const session = await requireAuth();
  
  // ØªØ³Ø¬ÙŠÙ„ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù‡ÙˆÙŠØ© Ø§Ù„Ù…Ø¹Ù„Ù… ÙÙŠ Ø§Ù„Ø³Ø¬Ù„Ø§Øª (Server Logs)
  console.log(`[StudentsPage] Fetching for Teacher ID: ${session.user.id}`);

  // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (Server-Side)
  const students = await prisma.user.findMany({
    where: {
      studentLinks: {
        some: {
          teacherId: session.user.id,
        },
      },
    },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      email: true,
      image: true,
      userDetails: {
        select: {
          level: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      },
    },
  });

  console.log(`[StudentsPage] Found ${students.length} students`);

    return (
        <div className="flex flex-col gap-8">
            <div className="grid gap-1">
                <h1 className="text-3xl font-bold tracking-tight">ØªÙ„Ø§Ù…ÙŠØ°ÙŠ</h1>
                <p className="text-muted-foreground">
                    Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø¨Ùƒ ÙˆÙ…ØªØ§Ø¨Ø¹Ø© ØªÙ‚Ø¯Ù…Ù‡Ù….
                </p>
            </div>

            <Card>
                <CardHeader>
                    <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø·Ù„Ø§Ø¨</CardTitle>
                    <CardDescription>
                        Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ†: {students.length}
                    </CardDescription>
                </CardHeader>
                <CardContent>
                    <Table>
                        <TableHeader>
                            <TableRow>
                                <TableHead>Ø§Ù„Ø·Ø§Ù„Ø¨</TableHead>
                                <TableHead>Ø§Ù„Ù…Ø³ØªÙˆÙ‰</TableHead>
                                <TableHead>Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                        {students.length > 0 ? (
                            students.map((student) => (
                                <TableRow key={student.id}>
                                    <TableCell>
                                        <div className="flex items-center gap-3">
                                            <Avatar>
                                                <AvatarImage src={student.image || undefined} alt={`${student.firstName} ${student.lastName}`} />
                                                <AvatarFallback>{student.firstName.charAt(0)}</AvatarFallback>
                                            </Avatar>
                                            <span className="font-medium">{student.firstName} {student.lastName}</span>
                                        </div>
                                    </TableCell>
                                    <TableCell>
                                        {student.userDetails?.level?.name || '-'}
                                    </TableCell>
                                    <TableCell>{student.email}</TableCell>
                                </TableRow>
                            ))
                        ) : (
                             <TableRow>
                                <TableCell colSpan={3} className="text-center h-24">
                                    Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø·Ù„Ø§Ø¨ Ù…Ø±ØªØ¨Ø·ÙˆÙ† Ø¨Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ø¹Ø¯.
                                </TableCell>
                            </TableRow>
                        )}
                        </TableBody>
                    </Table>
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/submissions/[id]/page.tsx
// ==========================================


'use client';
import { useState, useEffect } from "react";
import { notFound } from "next/navigation";
import { useSubmission } from "@/hooks/use-submission";
import { useToast } from "@/hooks/use-toast";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import {
  FileQuestion,
  User,
  CheckCircle,
  MessageSquare,
  FileText,
  Paperclip,
  Save,
  Brain,
  Loader2,
  Sparkles
} from "lucide-react";
import Link from "next/link";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";

export default function ReviewSubmissionPage({ params }: { params: { id: string } }) {
  const { id } = params;
  const { submission, isLoading, error, refetch, updateSubmission } = useSubmission(id);
  const { toast } = useToast();

  const [teacherNotes, setTeacherNotes] = useState<string>("");
  const [finalScore, setFinalScore] = useState<number | null>(null);
  const [isSavingManualGrade, setIsSavingManualGrade] = useState(false);

  const [isEvaluatingAI, setIsEvaluatingAI] = useState(false);
  const [aiEvaluationResult, setAiEvaluationResult] = useState<any | null>(null);

  useEffect(() => {
    if (submission) {
      setTeacherNotes(submission.teacherNotes || "");
      // Prioritize finalScore, then aiScore, then null
      setFinalScore(submission.finalScore ?? submission.aiScore ?? null); 
      if (submission.aiFeedback && submission.aiScore) {
        setAiEvaluationResult({
          score: submission.aiScore,
          feedback: submission.aiFeedback,
          // If detailed strengths/weaknesses are stored, retrieve them here
        });
      }
    }
  }, [submission]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (error) {
    return <div className="text-destructive text-center mt-8">Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©: {error}</div>;
  }

  if (!submission) {
    notFound();
  }

  const exercise = submission.exercise;
  const student = submission.student;

  // Use aiEvaluationResult if available, otherwise submission's stored AI evaluation, otherwise null
  const displayedAiScore = aiEvaluationResult?.score ?? submission.aiScore;
  const displayedAiFeedback = aiEvaluationResult?.feedback ?? submission.aiFeedback;
  const displayedAiStrengths = aiEvaluationResult?.strengths;
  const displayedAiWeaknesses = aiEvaluationResult?.weaknesses;

  const getScoreVariant = (score: number | null) => {
    if (score === null) return 'secondary';
    // Use exercise.maxScore, default to 10 if not available
    const max = exercise?.maxScore || 10;
    if (score >= max * 0.8) return 'default'; // 80% or more
    if (score >= max * 0.5) return 'secondary'; // 50% or more
    return 'destructive'; // Less than 50%
  };

  const handleAutoEvaluate = async () => {
    if (!submission || !exercise || !student) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø£Ùˆ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø£Ùˆ Ø§Ù„Ø·Ø§Ù„Ø¨ ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©.",
        variant: "destructive",
      });
      return;
    }

    if (exercise.type !== 'main') {
      toast({
        title: "ØºÙŠØ± Ù…ØªØ§Ø­",
        description: "Ø§Ù„ØªØµØ­ÙŠØ­ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªØ§Ø­ ÙÙ‚Ø· Ù„Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.",
        variant: "info",
      });
      return;
    }

    if (!exercise.modelAnswer) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ù„ Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ù„ØªØªÙ…ÙƒÙ† AI Ù…Ù† ØªÙ‚ÙŠÙŠÙ…Ù‡.",
        variant: "destructive",
      });
      return;
    }

    if (!submission.answer) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¬Ø§Ø¨Ø© Ù…Ù† Ø§Ù„Ø·Ø§Ù„Ø¨ Ù„ØªÙ‚ÙŠÙŠÙ…Ù‡Ø§ Ø¨ÙˆØ§Ø³Ø·Ø© AI.",
        variant: "destructive",
      });
      return;
    }

    setIsEvaluatingAI(true);
    try {
      const response = await fetch('/api/ai/evaluate-answer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: exercise.questionRichContent,
          modelAnswer: exercise.modelAnswer,
          studentAnswer: submission.answer,
          maxScore: exercise.maxScore || 10, // Default to 10 if not set
          subject: exercise.lesson.subject.name,
          level: exercise.lesson.level.name,
        }),
      });

      const result = await response.json();

      if (response.ok && result.success) {
        setAiEvaluationResult(result.data); // Store AI's full evaluation
        setFinalScore(result.data.score); // Pre-fill final score with AI score

        // Update the submission in the database with AI results
        await updateSubmission({
          aiScore: result.data.score,
          aiFeedback: result.data.feedback,
          // Optionally save strengths/weaknesses if schema supports it
        });

        toast({
          title: "ØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ù†Ø¬Ø§Ø­",
          description: "ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ.",
        });
      } else {
        throw new Error(result.error || "ÙØ´Ù„ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ");
      }
    } catch (err: any) {
      toast({
        title: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
        description: err.message,
        variant: "destructive",
      });
    } finally {
      setIsEvaluatingAI(false);
    }
  };

  const handleSaveManualGrade = async () => {
    if (!submission) return;

    setIsSavingManualGrade(true);
    try {
      const { success, error: updateError } = await updateSubmission({
        finalScore: finalScore,
        teacherNotes: teacherNotes,
        gradedAt: new Date().toISOString(),
        gradedById: submission.gradedById, // Assuming the current user ID is handled on the API
      });

      if (success) {
        toast({
          title: "ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­",
          description: "ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¯Ø±Ø¬Ø© ÙˆØ§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª.",
        });
        refetch(); // Refetch to get the latest state including gradedById if it's set by API
      } else {
        throw new Error(updateError || "ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ÙŠØ¯ÙˆÙŠ.");
      }
    } catch (err: any) {
      toast({
        title: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸",
        description: err.message,
        variant: "destructive",
      });
    } finally {
      setIsSavingManualGrade(false);
    }
  };

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨</h1>
        <p className="text-muted-foreground">
          Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ "{student.name}" Ø¹Ù„Ù‰ ØªÙ…Ø±ÙŠÙ† "{exercise.questionRichContent}".
        </p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div className="lg:col-span-2 space-y-8">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2"><FileQuestion /> <span>Ø§Ù„ØªÙ…Ø±ÙŠÙ†</span></CardTitle>
            </CardHeader>
            <CardContent>
              <div dangerouslySetInnerHTML={{ __html: exercise.questionRichContent }} className="text-lg font-medium mb-2" />
              {/* <p className="text-lg font-medium">{exercise.questionRichContent}</p> */}
              {/* exercise.question_file_url should be exercise.fileUrl in the new schema */}
              {/* {exercise.fileUrl && (
                <div className="pt-4">
                  <Link href={exercise.fileUrl} target="_blank" passHref>
                    <Button variant="outline">
                      <Paperclip className="ml-2 h-4 w-4" />
                      <span>Ø¹Ø±Ø¶ Ù…Ù„Ù Ø§Ù„Ø³Ø¤Ø§Ù„</span>
                    </Button>
                  </Link>
                </div>
              )} */}
              <Separator className="my-4" />
              <Label className="text-sm text-muted-foreground">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©:</Label>
              {exercise.modelAnswer ? (
                 <div dangerouslySetInnerHTML={{ __html: exercise.modelAnswer }} className="text-sm" />
              ) : (
                <p className="text-sm text-muted-foreground">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ù„ Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ†.</p>
              )}
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2"><FileText /> <span>Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨</span></CardTitle>
            </CardHeader>
            <CardContent>
              {submission.answer ? (
                <div dangerouslySetInnerHTML={{ __html: submission.answer }} className="mb-4 p-4 bg-muted rounded-md" />
              ) : (
                <p className="text-muted-foreground">Ù„Ù… ÙŠÙ‚Ø¯Ù… Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¥Ø¬Ø§Ø¨Ø© Ù†ØµÙŠØ©.</p>
              )}
              {submission.fileUrl && ( // submission.fileUrl
                <Link href={submission.fileUrl} target="_blank" passHref>
                  <Button variant="secondary">
                    <Paperclip className="ml-2 h-4 w-4" />
                    <span>ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø±ÙÙ‚ Ù…Ù† Ø§Ù„Ø·Ø§Ù„Ø¨</span>
                  </Button>
                </Link>
              )}
              {!submission.answer && !submission.fileUrl && (
                <p className="text-muted-foreground">Ù„Ù… ÙŠÙ‚Ø¯Ù… Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¥Ø¬Ø§Ø¨Ø© Ù†ØµÙŠØ© Ø£Ùˆ Ù…Ù„Ù.</p>
              )}
            </CardContent>
          </Card>
        </div>

        <div className="lg:col-span-1 space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2"><User /><span>Ø§Ù„Ø·Ø§Ù„Ø¨</span></CardTitle>
            </CardHeader>
            <CardContent className="flex items-center gap-3">
              <Avatar>
                <AvatarImage src={student.image || ""} alt={student.name} /> {/* student.image */}
                <AvatarFallback>{student.name.charAt(0)}</AvatarFallback>
              </Avatar>
              <div>
                <p className="font-semibold">{student.name}</p>
                <p className="text-sm text-muted-foreground">{student.email}</p>
              </div>
            </CardContent>
          </Card>

          {exercise.type === 'main' && (
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0">
                <CardTitle className="flex items-center gap-2"><MessageSquare /><span>ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</span></CardTitle>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={handleAutoEvaluate}
                  disabled={isEvaluatingAI || !exercise.modelAnswer || !submission.answer}
                  className="shrink-0"
                >
                  {isEvaluatingAI ? (
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                  ) : (
                    <Brain className="ml-2 h-4 w-4" />
                  )}
                  ØªÙ‚ÙŠÙŠÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠ
                </Button>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <Label>Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø© Ù…Ù† AI</Label>
                  <Badge variant={getScoreVariant(displayedAiScore)} className="block w-fit text-lg mt-1">
                    {displayedAiScore !== null ? `${displayedAiScore} / ${exercise.maxScore || 10}` : 'N/A'}
                  </Badge>
                </div>
                <div>
                  <Label>Ù…Ù„Ø§Ø­Ø¸Ø§Øª AI</Label>
                  <div className="mt-1 text-sm text-muted-foreground">
                    {displayedAiFeedback ? (
                      <div dangerouslySetInnerHTML={{ __html: displayedAiFeedback }} />
                    ) : (
                      "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ."
                    )}
                  </div>
                </div>
                {displayedAiStrengths && displayedAiStrengths.length > 0 && (
                  <div>
                    <Label>Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ© (AI)</Label>
                    <ul className="list-disc pl-5 mt-1 text-sm text-muted-foreground">
                      {displayedAiStrengths.map((s: string, i: number) => <li key={i}>{s}</li>)}
                    </ul>
                  </div>
                )}
                {displayedAiWeaknesses && displayedAiWeaknesses.length > 0 && (
                  <div>
                    <Label>Ù†Ù‚Ø§Ø· Ø§Ù„Ø¶Ø¹Ù (AI)</Label>
                    <ul className="list-disc pl-5 mt-1 text-sm text-muted-foreground">
                      {displayedAiWeaknesses.map((w: string, i: number) => <li key={i}>{w}</li>)}
                    </ul>
                  </div>
                )}
              </CardContent>
            </Card>
          )}

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2"><CheckCircle /><span>Ø§Ù„ØªØµØ­ÙŠØ­ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ</span></CardTitle>
              <CardDescription>ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø¬Ø© ÙˆØ¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ Ø§Ù„Ø®Ø§ØµØ©.</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="final-score">Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© (Ù…Ù† {exercise.maxScore || 10})</Label>
                <Input
                  id="final-score"
                  type="number"
                  defaultValue={finalScore ?? undefined}
                  value={finalScore ?? ''}
                  onChange={(e) => setFinalScore(e.target.value === '' ? null : parseFloat(e.target.value))}
                  min="0"
                  max={exercise.maxScore || 10}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="teacher-notes">Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù…</Label>
                <Textarea
                  id="teacher-notes"
                  placeholder="Ø§ÙƒØªØ¨ Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ Ù„Ù„Ø·Ø§Ù„Ø¨ Ù‡Ù†Ø§..."
                  rows={4}
                  value={teacherNotes}
                  onChange={(e) => setTeacherNotes(e.target.value)}
                />
              </div>
              <Button className="w-full" onClick={handleSaveManualGrade} disabled={isSavingManualGrade}>
                {isSavingManualGrade ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸...
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    Ø­ÙØ¸ Ø§Ù„ØªØµØ­ÙŠØ­
                  </>
                )}
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/submissions/page.tsx
// ==========================================


'use client';

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { getSubmissionsForTeacher, getUserById, getExerciseById } from "@/lib/mock-data";
import { Eye, Clock } from "lucide-react";
import Link from "next/link";
import { formatDistanceToNow } from "date-fns";
import { ar } from "date-fns/locale";

// Mock current teacher ID
const MOCK_TEACHER_ID = 2;

export default function SubmissionsPage() {
    const submissions = getSubmissionsForTeacher(MOCK_TEACHER_ID);
    const pendingSubmissions = submissions.filter(s => s.status === 'pending');

    const getScoreVariant = (score: number) => {
        if (score >= 8) return 'default';
        if (score >= 5) return 'secondary';
        return 'destructive';
    }

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center gap-2">
                <h1 className="text-3xl font-bold tracking-tight">ØªØµØ­ÙŠØ­ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</h1>
                <Badge variant="destructive" className="flex gap-1">
                    <Clock className="h-4 w-4"/>
                    {pendingSubmissions.length} Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©
                </Badge>
            </div>

             <Card>
                <CardHeader>
                    <CardTitle>Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø©</CardTitle>
                    <CardDescription>
                       Ù…Ø±Ø§Ø¬Ø¹Ø© ÙˆØªØµØ­ÙŠØ­ Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†.
                    </CardDescription>
                </CardHeader>
                <CardContent>
                    <Table>
                        <TableHeader>
                            <TableRow>
                                <TableHead>Ø§Ù„Ø·Ø§Ù„Ø¨</TableHead>
                                <TableHead>Ø§Ù„ØªÙ…Ø±ÙŠÙ†</TableHead>
                                <TableHead>Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£ÙˆÙ„ÙŠ (AI)</TableHead>
                                <TableHead>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø±Ø³Ø§Ù„</TableHead>
                                <TableHead className="text-left">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                        {pendingSubmissions.length > 0 ? (
                            pendingSubmissions.map(submission => {
                                const student = getUserById(submission.student_id);
                                const exercise = getExerciseById(submission.exercise_id);
                                if (!student || !exercise) return null;

                                return (
                                <TableRow key={submission.id}>
                                    <TableCell className="font-medium">{student.name}</TableCell>
                                    <TableCell className="max-w-xs truncate">{exercise.question}</TableCell>
                                    <TableCell>
                                        <Badge variant={getScoreVariant(submission.score ?? 0)}>
                                            {submission.score ?? 'N/A'}/10
                                        </Badge>
                                    </TableCell>
                                    <TableCell>
                                        {formatDistanceToNow(new Date(submission.submitted_at), { addSuffix: true, locale: ar })}
                                    </TableCell>
                                    <TableCell className="text-left">
                                        <Link href={`/dashboard/teacher/submissions/${submission.id}`} passHref>
                                            <Button variant="outline" size="sm">
                                                <Eye className="ml-2 h-4 w-4" />
                                                Ù…Ø±Ø§Ø¬Ø¹Ø©
                                            </Button>
                                        </Link>
                                    </TableCell>
                                </TableRow>
                                )
                            })
                        ) : (
                             <TableRow>
                                <TableCell colSpan={5} className="text-center h-24">
                                    Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¬Ø§Ø¨Ø§Øª Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØµØ­ÙŠØ­ Ø­Ø§Ù„ÙŠØ§Ù‹.
                                </TableCell>
                            </TableRow>
                        )}
                        </TableBody>
                    </Table>
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/_components/TeacherDashboard.tsx
// ==========================================

'use client';

import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { getTeacher, getLessons, getExercisesForLesson, USERS } from "@/lib/mock-data";
import { Book, CheckCircle, ClipboardList, PlusCircle, Users, Link as LinkIcon, FileQuestion, MessageSquare, Copy } from "lucide-react";
import Link from "next/link";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";


export default function TeacherDashboard({ teacherId = 2 }: { teacherId?: number }) {
    const { toast } = useToast();
    const teacher = getTeacher(teacherId);
    if (!teacher) return <div>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ù„Ù….</div>;

    const lessons = getLessons().filter(l => l.author_id === teacher.id);
    const exercises = lessons.flatMap(l => getExercisesForLesson(l.id));
    const students = USERS.filter(u => u.role === 'student' && u.connected_teacher_code === teacher.teacher_code);

    const handleCopy = () => {
        navigator.clipboard.writeText(teacher.teacher_code);
        toast({
            title: "ØªÙ… Ø§Ù„Ù†Ø³Ø®!",
            description: "ØªÙ… Ù†Ø³Ø® ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©.",
        });
    };

    // Mock data for exercise grading stats
    const totalSubmissions = 15;
    const gradedSubmissions = 10;
    const pendingSubmissions = 5;
    const unreadMessages = 1; // Mock unread messages

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">
                        Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ Ø£Ø³ØªØ§Ø°ØŒ {teacher?.prenom}!
                    </h1>
                    <p className="text-muted-foreground">
                        Ù‡Ø°Ù‡ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ ÙˆØ§Ù„Ø·Ù„Ø§Ø¨.
                    </p>
                </div>
                <Link href="/dashboard/teacher/lessons/create" passHref>
                    <Button>
                        <PlusCircle className="ml-2 h-4 w-4" />
                        <span>Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯</span>
                    </Button>
                </Link>
            </div>

            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…Ø¶Ø§ÙØ©</CardTitle>
                        <Book className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{lessons.length}</div>
                        <p className="text-xs text-muted-foreground">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙˆÙ†</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{students.length}</div>
                        <p className="text-xs text-muted-foreground">Ø¹Ø¯Ø¯ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø¨Ùƒ</p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨</CardTitle>
                        <CheckCircle className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{totalSubmissions}</div>
                        <p className="text-xs text-muted-foreground">
                            <span className="text-green-600">{gradedSubmissions} Ù…ØµØ­Ø­Ø©</span>, <span className="text-yellow-600">{pendingSubmissions} Ø¨Ø§Ù†ØªØ¸Ø§Ø±</span>
                        </p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</CardTitle>
                        <MessageSquare className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{unreadMessages}</div>
                        <p className="text-xs text-muted-foreground">Ù„Ø¯ÙŠÙƒ Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±</p>
                    </CardContent>
                </Card>
            </div>
            
            <div className="grid gap-6 md:grid-cols-2">
                 <Card>
                    <CardHeader>
                        <CardTitle className="flex items-center gap-2">
                            <LinkIcon className="text-primary" />
                            <span>ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ</span>
                        </CardTitle>
                        <CardDescription>
                            Ø´Ø§Ø±Ùƒ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¹ Ø·Ù„Ø§Ø¨Ùƒ Ù„Ø±Ø¨Ø·Ù‡Ù… Ø¨Ø­Ø³Ø§Ø¨Ùƒ.
                        </CardDescription>
                    </CardHeader>
                    <CardContent className="flex items-center gap-4">
                        <Input readOnly defaultValue={teacher.teacher_code} className="text-lg font-mono tracking-widest text-center" />
                        <Button variant="outline" onClick={handleCopy}>
                            <Copy className="ml-2 h-4 w-4" />
                            Ù†Ø³Ø® Ø§Ù„ÙƒÙˆØ¯
                        </Button>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader>
                        <CardTitle>Ø±ÙˆØ§Ø¨Ø· Ø³Ø±ÙŠØ¹Ø©</CardTitle>
                    </CardHeader>
                    <CardContent className="grid grid-cols-2 gap-4">
                        <Link href="/dashboard/teacher/lessons" passHref><Button variant="secondary" className="w-full justify-start">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¯Ø±ÙˆØ³</Button></Link>
                        <Link href="/dashboard/teacher/students" passHref><Button variant="secondary" className="w-full justify-start">Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø§Ø¨</Button></Link>
                        <Link href="/dashboard/teacher/submissions" passHref><Button variant="secondary" className="w-full justify-start">ØªØµØ­ÙŠØ­ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª</Button></Link>
                        <Link href="/messages" passHref><Button variant="secondary" className="w-full justify-start">Ø§Ù„Ø±Ø³Ø§Ø¦Ù„</Button></Link>
                    </CardContent>
                </Card>
            </div>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/page.tsx
// ==========================================

'use client';

import TeacherDashboard from "../_components/TeacherDashboard";

export const dynamic = 'force-dynamic';

export default function TeacherDashboardPage() {
    return <TeacherDashboard />
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/lessons/[id]/edit/edit-lesson-client.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useStages, useLevels, useSubjects } from "@/hooks";
import { Save, Loader2, Paperclip } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { RichTextEditor } from "@/components/editor";
import { FileUpload } from "@/components/FileUpload";

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Google Drive Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¥Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· Proxy
const getProxiedUrl = (url: string) => {
  if (!url) return "";
  // Ø¥Ø¶Ø§ÙØ© Ù„Ø§Ø­Ù‚Ø© ÙˆÙ‡Ù…ÙŠØ© Ù„Ù„ØµÙˆØ±Ø© Ù„ÙƒÙŠ ÙŠØªØ¹Ø±Ù Ø¹Ù„ÙŠÙ‡Ø§ Ù…ÙƒÙˆÙ† FileUpload ÙˆØ§Ù„Ù…ØªØµÙØ­ ÙƒØµÙˆØ±Ø©
  const suffix = "&t=image.jpg";
  if (url.startsWith('/api/images/proxy')) return url.includes(suffix) ? url : `${url}${suffix}`;
  
  const idMatch = url.match(/id=([a-zA-Z0-9_-]+)/) || url.match(/\/d\/([a-zA-Z0-9_-]+)/);
  if ((url.includes('drive.google.com') || url.includes('googleusercontent.com')) && idMatch && idMatch[1]) {
    return `/api/images/proxy?fileId=${idMatch[1]}${suffix}`;
  }
  
  return url;
};

interface EditLessonClientProps {
  lessonId: string;
  googleDriveParentFolderId: string | null;
}

export default function EditLessonClient({ lessonId, googleDriveParentFolderId }: EditLessonClientProps) {
  const router = useRouter();
  const { toast } = useToast();
  const { data: session } = useSession();
  const { stages } = useStages();
  const { levels } = useLevels();
  const { subjects } = useSubjects();
  
  const [teacherSubject, setTeacherSubject] = useState<any>(null);
  const [teacherStage, setTeacherStage] = useState<any>(null);
  const [availableLevels, setAvailableLevels] = useState<any[]>([]);
  const [isLoadingData, setIsLoadingData] = useState(true);

  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [videoUrl, setVideoUrl] = useState("");
  const [imageUrl, setImageUrl] = useState("");
  const [pdfUrl, setPdfUrl] = useState("");
  const [pptUrl, setPptUrl] = useState("");
  const [levelId, setLevelId] = useState<string>("");
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Ø­Ø§Ù„Ø§Øª Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø¸Ù‡ÙˆØ± Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ø±ÙØ¹
  const [showImageUpload, setShowImageUpload] = useState(false);
  const [showPdfUpload, setShowPdfUpload] = useState(false);
  const [showPptUpload, setShowPptUpload] = useState(false);
  const [isFileUploading, setIsFileUploading] = useState(false);

  // 1. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù… (Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø±Ø­Ù„Ø©)
  useEffect(() => {
    const setTeacherInfo = async () => {
      if (!session?.user?.id || !subjects || !stages || !levels) return;
      if (subjects.length === 0 || stages.length === 0 || levels.length === 0) return;

      try {
        const response = await fetch(`/api/users/${session.user.id}`);
        const result = await response.json();

        if (result.success && result.data?.userDetails?.subjectId) {
          const userSubjectId = result.data.userDetails.subjectId;
          const subject = subjects.find((s: any) => s.id === userSubjectId);

          if (subject) {
            setTeacherSubject(subject);
            const stage = stages.find((st: any) => st.id === subject.stageId || st.id === subject.stage_id);
            
            if (stage) {
              setTeacherStage(stage);
              const stageLevels = levels.filter((l: any) => l.stageId === stage.id);
              setAvailableLevels(stageLevels);
            }
          }
        }
      } catch (error) {
        console.error('Error fetching teacher info:', error);
      }
    };

    setTeacherInfo();
  }, [session, subjects, stages, levels]);

  // 2. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆÙ…Ù„Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
  useEffect(() => {
    const fetchLesson = async () => {
      if (!lessonId) return;
      try {
        const response = await fetch(`/api/lessons/${lessonId}`);
        
        if (!response.ok) {
          throw new Error(`ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${response.statusText}`);
        }

        const result = await response.json();

        if (result.success && result.data) {
          const lesson = result.data;
          setTitle(lesson.title);
          setContent(lesson.content || "");
          setVideoUrl(lesson.videoUrl || "");
          // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ± Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¹Ø¨Ø± Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ
          setImageUrl(getProxiedUrl(lesson.imageUrl || ""));
          setPdfUrl(lesson.pdfUrl || "");
          // setPptUrl(lesson.pptUrl || ""); // ØªÙØ¹ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø± Ø¹Ù†Ø¯ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚Ù„ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
          
          if (lesson.levelId) {
            setLevelId(String(lesson.levelId));
          }

          // Ø¥Ø¸Ù‡Ø§Ø± Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø±ÙØ¹ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù…Ù„ÙØ§Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
          if (lesson.imageUrl) setShowImageUpload(true);
          if (lesson.pdfUrl) setShowPdfUpload(true);
          // if (lesson.pptUrl) setShowPptUpload(true);
        } else {
          toast({
            title: "Ø®Ø·Ø£",
            description: "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ø±Ø³",
            variant: "destructive",
          });
          router.push("/dashboard/teacher/lessons");
        }
      } catch (error) {
        console.error("Error fetching lesson:", error);
        toast({
          title: "Ø®Ø·Ø£",
          description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø³",
          variant: "destructive",
        });
      } finally {
        setIsLoadingData(false);
      }
    };

    fetchLesson();
  }, [lessonId, router, toast]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!title || !content || !teacherSubject || !levelId) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch(`/api/lessons/${lessonId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title,
          content,
          videoUrl: videoUrl || null,
          imageUrl: imageUrl || null,
          pdfUrl: pdfUrl || null,
          // pptUrl: pptUrl || null,
          subjectId: teacherSubject.id,
          levelId: parseInt(levelId),
        }),
      });

      const result = await response.json();

      if (response.ok && result.success) {
        toast({
          title: "ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«",
          description: "ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­",
        });
        router.push("/dashboard/teacher/lessons");
      } else {
        throw new Error(result.error || "ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯Ø±Ø³");
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoadingData) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="w-8 h-8 animate-spin text-primary" />
        <span className="mr-2">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø³...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³</h1>
        <p className="text-muted-foreground">
          Ù‚Ù… Ø¨ØªØ¹Ø¯ÙŠÙ„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ Ø£Ùˆ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ø£Ø¯Ù†Ø§Ù‡.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³</CardTitle>
          <CardDescription>
            {teacherSubject && teacherStage && `${teacherSubject.name} - ${teacherStage.name}`}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="title">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <Input 
                id="title" 
                placeholder="Ù…Ø«Ø§Ù„: Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¬Ø¨Ø±" 
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                required
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <Label htmlFor="subject">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                <Input 
                  id="subject" 
                  value={teacherSubject?.name || 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...'}
                  readOnly
                  disabled
                  className="bg-muted"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                <Input 
                  id="stage" 
                  value={teacherStage?.name || 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...'}
                  readOnly
                  disabled
                  className="bg-muted"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ *</Label>
              <Select value={levelId} onValueChange={setLevelId} disabled={!teacherStage || availableLevels.length === 0}>
                <SelectTrigger id="level">
                  <SelectValue placeholder={!teacherStage ? "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„..." : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰"} />
                </SelectTrigger>
                <SelectContent>
                  {availableLevels.map((level) => (
                    <SelectItem key={level.id} value={String(level.id)}>
                      {level.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="content">Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <RichTextEditor 
                content={content}
                onChange={(newContent) => setContent(newContent)}
                placeholder="Ø§ÙƒØªØ¨ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ Ù‡Ù†Ø§..."
                googleDriveParentFolderId={googleDriveParentFolderId || undefined}
              />
            </div>

            {/* Ù‚Ø³Ù… Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª - Ù…Ø·Ø§Ø¨Ù‚ Ù„ØµÙØ­Ø© Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ */}
            <div className="space-y-4 border rounded-lg p-4 bg-muted/20">
              <div className="flex items-center justify-between">
                <Label className="text-base font-semibold flex items-center gap-2">
                  <Paperclip className="w-4 h-4" />
                  Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª
                </Label>
                
                <Select 
                  disabled={isFileUploading || isSubmitting} 
                  onValueChange={(value) => {
                    if (value === 'image') setShowImageUpload(true);
                    if (value === 'pdf') setShowPdfUpload(true);
                    if (value === 'ppt') setShowPptUpload(true);
                  }}
                >
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="Ø¥Ø¶Ø§ÙØ© Ù…Ø±ÙÙ‚..." />
                  </SelectTrigger>
                  <SelectContent>
                    {!showImageUpload && <SelectItem value="image">ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³</SelectItem>}
                    {!showPdfUpload && <SelectItem value="pdf">Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)</SelectItem>}
                    {!showPptUpload && <SelectItem value="ppt" disabled>Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint) - Ù‚Ø±ÙŠØ¨Ø§Ù‹</SelectItem>}
                    <SelectItem value="video" disabled>ÙÙŠØ¯ÙŠÙˆ (Ù‚Ø±ÙŠØ¨Ø§Ù‹)</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="video-url">Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (ÙŠÙˆØªÙŠÙˆØ¨)</Label>
                  <Input 
                    id="video-url" 
                    placeholder="https://www.youtube.com/watch?v=..." 
                    value={videoUrl}
                    onChange={(e) => setVideoUrl(e.target.value)}
                    disabled={isSubmitting}
                  />
                </div>

                {showImageUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³"
                      accept="image/*"
                      maxSizeMB={5}
                      value={imageUrl}
                      onChange={(fileInfo) => {
                        setImageUrl(getProxiedUrl(fileInfo?.fileUrl || ""));
                      }}
                      onUploadStatusChange={setIsFileUploading}
                      parentFolderId={googleDriveParentFolderId || undefined}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù Ù„Ù„Ø¯Ø±Ø³ (JPG, PNG, GIF, Ø­ØªÙ‰ 5 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}

                {showPdfUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)"
                      accept=".pdf"
                      maxSizeMB={10}
                      value={pdfUrl}
                      onChange={(fileInfo) => setPdfUrl(fileInfo?.fileUrl || "")}
                      onUploadStatusChange={setIsFileUploading}
                      parentFolderId={googleDriveParentFolderId || undefined}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù PDF Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}

                {showPptUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint)"
                      accept=".ppt,.pptx"
                      maxSizeMB={10}
                      value={pptUrl}
                      onChange={(fileInfo) => {
                        setPptUrl(fileInfo?.fileUrl || "");
                      }}
                      onUploadStatusChange={setIsFileUploading}
                      parentFolderId={googleDriveParentFolderId || undefined}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint) Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}
              </div>
            </div>

            <div className="flex justify-end gap-4">
              <Button 
                type="button" 
                variant="outline"
                onClick={() => router.back()}
                disabled={isSubmitting}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
              <Button type="submit" disabled={isSubmitting || isFileUploading}>
                {isSubmitting || isFileUploading ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    <span>{isFileUploading ? "Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª..." : "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸..."}</span>
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    <span>Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª</span>
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

// ==========================================
// FILE: src/app/(main)/dashboard/teacher/lessons/[id]/edit/page.tsx
// ==========================================

'use client';

import { useState, useEffect, use } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useStages, useLevels, useSubjects } from "@/hooks";
import { Save, Loader2, Paperclip } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { RichTextEditor } from "@/components/editor";
import { FileUpload } from "@/components/FileUpload";

export default function EditLessonPage({ params }: { params: Promise<{ id: string }> }) {
  const { id: lessonId } = use(params);
  const router = useRouter();
  const { toast } = useToast();
  const { data: session } = useSession();
  const { stages } = useStages();
  const { levels } = useLevels();
  const { subjects } = useSubjects();
  
  const [teacherSubject, setTeacherSubject] = useState<any>(null);
  const [teacherStage, setTeacherStage] = useState<any>(null);
  const [availableLevels, setAvailableLevels] = useState<any[]>([]);
  const [isLoadingData, setIsLoadingData] = useState(true);

  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [videoUrl, setVideoUrl] = useState("");
  const [imageUrl, setImageUrl] = useState("");
  const [pdfUrl, setPdfUrl] = useState("");
  const [pptUrl, setPptUrl] = useState("");
  const [levelId, setLevelId] = useState<string>("");
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Ø­Ø§Ù„Ø§Øª Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø¸Ù‡ÙˆØ± Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ø±ÙØ¹
  const [showImageUpload, setShowImageUpload] = useState(false);
  const [showPdfUpload, setShowPdfUpload] = useState(false);
  const [showPptUpload, setShowPptUpload] = useState(false);
  const [isFileUploading, setIsFileUploading] = useState(false);

  // 1. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù… (Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø±Ø­Ù„Ø©)
  useEffect(() => {
    const setTeacherInfo = async () => {
      if (!session?.user?.id || !subjects || !stages || !levels) return;
      if (subjects.length === 0 || stages.length === 0 || levels.length === 0) return;

      try {
        const response = await fetch(`/api/users/${session.user.id}`);
        const result = await response.json();

        if (result.success && result.data?.userDetails?.subjectId) {
          const userSubjectId = result.data.userDetails.subjectId;
          const subject = subjects.find((s: any) => s.id === userSubjectId);

          if (subject) {
            setTeacherSubject(subject);
            const stage = stages.find((st: any) => st.id === subject.stageId || st.id === subject.stage_id);
            
            if (stage) {
              setTeacherStage(stage);
              const stageLevels = levels.filter((l: any) => l.stageId === stage.id);
              setAvailableLevels(stageLevels);
            }
          }
        }
      } catch (error) {
        console.error('Error fetching teacher info:', error);
      }
    };

    setTeacherInfo();
  }, [session, subjects, stages, levels]);

  // 2. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆÙ…Ù„Ø¡ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬
  useEffect(() => {
    const fetchLesson = async () => {
      if (!lessonId) return;
      try {
        const response = await fetch(`/api/lessons/${lessonId}`);
        
        if (!response.ok) {
          throw new Error(`ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${response.statusText}`);
        }

        const result = await response.json();

        if (result.success && result.data) {
          const lesson = result.data;
          setTitle(lesson.title);
          setContent(lesson.content || "");
          setVideoUrl(lesson.videoUrl || "");
          setImageUrl(lesson.imageUrl || "");
          setPdfUrl(lesson.pdfUrl || "");
          // setPptUrl(lesson.pptUrl || ""); // ØªÙØ¹ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø± Ø¹Ù†Ø¯ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚Ù„ Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
          
          if (lesson.levelId) {
            setLevelId(String(lesson.levelId));
          }

          // Ø¥Ø¸Ù‡Ø§Ø± Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø±ÙØ¹ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù…Ù„ÙØ§Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
          if (lesson.imageUrl) setShowImageUpload(true);
          if (lesson.pdfUrl) setShowPdfUpload(true);
          // if (lesson.pptUrl) setShowPptUpload(true);
        } else {
          toast({
            title: "Ø®Ø·Ø£",
            description: "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¯Ø±Ø³",
            variant: "destructive",
          });
          router.push("/dashboard/teacher/lessons");
        }
      } catch (error) {
        console.error("Error fetching lesson:", error);
        toast({
          title: "Ø®Ø·Ø£",
          description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø³",
          variant: "destructive",
        });
      } finally {
        setIsLoadingData(false);
      }
    };

    fetchLesson();
  }, [lessonId, router, toast]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!title || !content || !teacherSubject || !levelId) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch(`/api/lessons/${lessonId}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title,
          content,
          videoUrl: videoUrl || null,
          imageUrl: imageUrl || null,
          pdfUrl: pdfUrl || null,
          // pptUrl: pptUrl || null,
          subjectId: teacherSubject.id,
          levelId: parseInt(levelId),
        }),
      });

      const result = await response.json();

      if (response.ok && result.success) {
        toast({
          title: "ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«",
          description: "ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­",
        });
        router.push("/dashboard/teacher/lessons");
      } else {
        throw new Error(result.error || "ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯Ø±Ø³");
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoadingData) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="w-8 h-8 animate-spin text-primary" />
        <span className="mr-2">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø³...</span>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³</h1>
        <p className="text-muted-foreground">
          Ù‚Ù… Ø¨ØªØ¹Ø¯ÙŠÙ„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ Ø£Ùˆ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª Ø£Ø¯Ù†Ø§Ù‡.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³</CardTitle>
          <CardDescription>
            {teacherSubject && teacherStage && `${teacherSubject.name} - ${teacherStage.name}`}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="title">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <Input 
                id="title" 
                placeholder="Ù…Ø«Ø§Ù„: Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¬Ø¨Ø±" 
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                required
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <Label htmlFor="subject">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                <Input 
                  id="subject" 
                  value={teacherSubject?.name || 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...'}
                  readOnly
                  disabled
                  className="bg-muted"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                <Input 
                  id="stage" 
                  value={teacherStage?.name || 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...'}
                  readOnly
                  disabled
                  className="bg-muted"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ *</Label>
              <Select value={levelId} onValueChange={setLevelId} disabled={!teacherStage || availableLevels.length === 0}>
                <SelectTrigger id="level">
                  <SelectValue placeholder={!teacherStage ? "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„..." : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰"} />
                </SelectTrigger>
                <SelectContent>
                  {availableLevels.map((level) => (
                    <SelectItem key={level.id} value={String(level.id)}>
                      {level.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="content">Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <RichTextEditor 
                content={content}
                onChange={(newContent) => setContent(newContent)}
                placeholder="Ø§ÙƒØªØ¨ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ Ù‡Ù†Ø§..."
              />
            </div>

            {/* Ù‚Ø³Ù… Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª - Ù…Ø·Ø§Ø¨Ù‚ Ù„ØµÙØ­Ø© Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡ */}
            <div className="space-y-4 border rounded-lg p-4 bg-muted/20">
              <div className="flex items-center justify-between">
                <Label className="text-base font-semibold flex items-center gap-2">
                  <Paperclip className="w-4 h-4" />
                  Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª
                </Label>
                
                <Select 
                  disabled={isFileUploading || isSubmitting} 
                  onValueChange={(value) => {
                    if (value === 'image') setShowImageUpload(true);
                    if (value === 'pdf') setShowPdfUpload(true);
                    if (value === 'ppt') setShowPptUpload(true);
                  }}
                >
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="Ø¥Ø¶Ø§ÙØ© Ù…Ø±ÙÙ‚..." />
                  </SelectTrigger>
                  <SelectContent>
                    {!showImageUpload && <SelectItem value="image">ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³</SelectItem>}
                    {!showPdfUpload && <SelectItem value="pdf">Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)</SelectItem>}
                    {!showPptUpload && <SelectItem value="ppt" disabled>Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint) - Ù‚Ø±ÙŠØ¨Ø§Ù‹</SelectItem>}
                    <SelectItem value="video" disabled>ÙÙŠØ¯ÙŠÙˆ (Ù‚Ø±ÙŠØ¨Ø§Ù‹)</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="video-url">Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (ÙŠÙˆØªÙŠÙˆØ¨)</Label>
                  <Input 
                    id="video-url" 
                    placeholder="https://www.youtube.com/watch?v=..." 
                    value={videoUrl}
                    onChange={(e) => setVideoUrl(e.target.value)}
                    disabled={isSubmitting}
                  />
                </div>

                {showImageUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³"
                      accept="image/*"
                      maxSizeMB={5}
                      value={imageUrl}
                      onChange={(fileInfo) => {
                        setImageUrl(fileInfo?.fileUrl || "");
                      }}
                      onUploadStatusChange={setIsFileUploading}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù Ù„Ù„Ø¯Ø±Ø³ (JPG, PNG, GIF, Ø­ØªÙ‰ 5 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}

                {showPdfUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)"
                      accept=".pdf"
                      maxSizeMB={10}
                      value={pdfUrl}
                      onChange={(fileInfo) => setPdfUrl(fileInfo?.fileUrl || "")}
                      onUploadStatusChange={setIsFileUploading}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù PDF Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}

                {showPptUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint)"
                      accept=".ppt,.pptx"
                      maxSizeMB={10}
                      value={pptUrl}
                      onChange={(fileInfo) => {
                        setPptUrl(fileInfo?.fileUrl || "");
                      }}
                      onUploadStatusChange={setIsFileUploading}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint) Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}
              </div>
            </div>

            <div className="flex justify-end gap-4">
              <Button 
                type="button" 
                variant="outline"
                onClick={() => router.back()}
                disabled={isSubmitting}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
              <Button type="submit" disabled={isSubmitting || isFileUploading}>
                {isSubmitting || isFileUploading ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    <span>{isFileUploading ? "Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª..." : "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸..."}</span>
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    <span>Ø­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª</span>
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

// ==========================================
// FILE: src/app/(main)/dashboard/teacher/lessons/create/page_new.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Save, Loader2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { useRouter } from "next/navigation";
import { RichTextEditor } from "@/components/editor";
import { FileUpload } from "@/components/FileUpload";
import { useStages, useLevels } from "@/hooks";

interface TeacherInfo {
  subject: { id: number; name: string; stageId: number };
  stage: { id: number; name: string };
  levels: { id: number; name: string }[];
}

export default function CreateLessonPage() {
  const { toast } = useToast();
  const router = useRouter();
  const { data: session } = useSession();
  const { stages } = useStages();
  const { levels } = useLevels();
  
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [teacherInfo, setTeacherInfo] = useState<TeacherInfo | null>(null);
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    videoUrl: '',
    imageBase64: '',
    pdfBase64: '',
    levelId: '',
  });

  useEffect(() => {
    const fetchTeacherInfo = async () => {
      if (!session?.user?.id || stages.length === 0 || levels.length === 0) return;
      
      try {
        // Fetch teacher user data
        const userResponse = await fetch(`/api/users/${session.user.id}`);
        const userResult = await userResponse.json();
        
        if (!userResult.success || !userResult.data) {
          toast({
            title: 'Ø®Ø·Ø£',
            description: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù…',
            variant: 'destructive',
          });
          return;
        }

        const userData = userResult.data;
        const subjectId = userData.userDetails?.subjectId;

        if (!subjectId) {
          toast({
            title: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
            description: 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ± Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø§Ø¯Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ùƒ',
            variant: 'destructive',
          });
          return;
        }

        // Fetch subject details
        const subjectsResponse = await fetch('/api/subjects');
        const subjectsResult = await subjectsResponse.json();
        const subjects = subjectsResult.data?.subjects || subjectsResult.subjects || [];
        const subject = subjects.find((s: any) => s.id === subjectId);

        if (!subject) {
          toast({
            title: 'Ø®Ø·Ø£',
            description: 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø§Ø¯Ø©',
            variant: 'destructive',
          });
          return;
        }

        // Find stage
        const stage = stages.find((st: any) => st.id === subject.stageId || st.id === subject.stage_id);
        
        if (!stage) {
          toast({
            title: 'Ø®Ø·Ø£',
            description: 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±Ø­Ù„Ø©',
            variant: 'destructive',
          });
          return;
        }

        // Filter levels for this stage
        const stageLevels = levels.filter((l: any) => l.stageId === stage.id);

        setTeacherInfo({
          subject: {
            id: subject.id,
            name: subject.name,
            stageId: subject.stageId || subject.stage_id
          },
          stage: {
            id: stage.id,
            name: stage.name
          },
          levels: stageLevels.map((l: any) => ({
            id: l.id,
            name: l.name
          }))
        });
      } catch (error) {
        console.error('Error fetching teacher info:', error);
        toast({
          title: 'Ø®Ø·Ø£',
          description: 'ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…',
          variant: 'destructive',
        });
      } finally {
        setLoading(false);
      }
    };

    fetchTeacherInfo();
  }, [session, stages, levels]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validation
    if (!formData.title.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
      return;
    }

    if (!formData.content.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
      return;
    }

    if (!formData.levelId) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ',
        variant: 'destructive',
      });
      return;
    }

    if (!teacherInfo) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù…',
        variant: 'destructive',
      });
      return;
    }

    setSubmitting(true);

    try {
      const payload: any = {
        title: formData.title.trim(),
        content: formData.content,
        videoUrl: formData.videoUrl?.trim() || null,
        subjectId: teacherInfo.subject.id,
        levelId: parseInt(formData.levelId),
        type: 'private', // Teachers always create private lessons
      };

      // Only add base64 files if they exist
      if (formData.imageBase64) {
        payload.imageBase64 = formData.imageBase64;
      }
      if (formData.pdfBase64) {
        payload.pdfBase64 = formData.pdfBase64;
      }

      const response = await fetch('/api/lessons', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Server error:', errorText);
        throw new Error(`ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø­ÙØ¸: ${response.status}`);
      }

      const result = await response.json();

      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡',
          description: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­',
        });
        router.push('/dashboard/teacher/lessons');
      } else {
        throw new Error(result.error);
      }
    } catch (error: any) {
      console.error('Submit error:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
    } finally {
      setSubmitting(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯</h1>
        <p className="text-muted-foreground">
          Ø§Ù…Ù„Ø£ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¥Ø¶Ø§ÙØ© Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯. Ø³ØªÙƒÙˆÙ† ÙƒÙ„ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ ØªÙ†Ø´Ø¦Ù‡Ø§ Ø®Ø§ØµØ© Ø¨Ø·Ù„Ø§Ø¨Ùƒ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø¨Ùƒ.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³</CardTitle>
          <CardDescription>
            {teacherInfo && `${teacherInfo.subject.name} - ${teacherInfo.stage.name}`}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="title">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <Input 
                id="title" 
                placeholder="Ù…Ø«Ø§Ù„: Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¬Ø¨Ø±" 
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                required
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <Label htmlFor="subject">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                <Input 
                  id="subject" 
                  value={teacherInfo?.subject.name || ''} 
                  readOnly 
                  disabled 
                  className="bg-muted"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                <Input 
                  id="stage" 
                  value={teacherInfo?.stage.name || ''} 
                  readOnly 
                  disabled 
                  className="bg-muted"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ *</Label>
              <Select 
                value={formData.levelId} 
                onValueChange={(value) => setFormData({ ...formData, levelId: value })}
              >
                <SelectTrigger id="level">
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰" />
                </SelectTrigger>
                <SelectContent>
                  {teacherInfo?.levels.map((level) => (
                    <SelectItem key={level.id} value={String(level.id)}>
                      {level.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <p className="text-xs text-muted-foreground">
                Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¯Ø±Ø³
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="content">Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <RichTextEditor 
                content={formData.content}
                onChange={(content) => setFormData({ ...formData, content })}
                placeholder="Ø§ÙƒØªØ¨ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ Ù‡Ù†Ø§..."
              />
              <p className="text-xs text-muted-foreground">
                Ø§Ø³ØªØ®Ø¯Ù… Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ©
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="video-url">Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (ÙŠÙˆØªÙŠÙˆØ¨)</Label>
              <Input 
                id="video-url" 
                placeholder="https://www.youtube.com/watch?v=..." 
                value={formData.videoUrl}
                onChange={(e) => setFormData({ ...formData, videoUrl: e.target.value })}
              /> 
            </div>

            <FileUpload
              label="ØµÙˆØ±Ø© ØªÙˆØ¶ÙŠØ­ÙŠØ© Ù„Ù„Ø¯Ø±Ø³ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)"
              accept="image/*"
              maxSizeMB={2}
              value={formData.imageBase64}
              onChange={(base64) => setFormData({ ...formData, imageBase64: base64 || '' })}
              description="ÙŠÙ…ÙƒÙ†Ùƒ Ø±ÙØ¹ ØµÙˆØ±Ø© ØªÙˆØ¶ÙŠØ­ÙŠØ© Ù„Ù„Ø¯Ø±Ø³ (JPG, PNG, GIF - Ø­ØªÙ‰ 2 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
            />

            <FileUpload
              label="Ù…Ù„Ù PDF Ø¥Ø¶Ø§ÙÙŠ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)"
              accept=".pdf,application/pdf"
              maxSizeMB={5}
              value={formData.pdfBase64}
              onChange={(base64) => setFormData({ ...formData, pdfBase64: base64 || '' })}
              preview={false}
              description="ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±ÙØ§Ù‚ Ù…Ù„Ù PDF Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 5 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
            />

            <div className="flex justify-end gap-2">
              <Button 
                variant="outline" 
                type="button"
                onClick={() => router.back()}
                disabled={submitting}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
              <Button type="submit" disabled={submitting}>
                {submitting ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    <span>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...</span>
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    <span>Ø­ÙØ¸ Ø§Ù„Ø¯Ø±Ø³</span>
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/lessons/create/page.tsx
// ==========================================

import CreateLessonClient from './create-lesson-client';
import { getRootFolderId } from '@/lib/google-drive';

export default function CreateLessonPageServer() {
  const googleDriveParentFolderId = getRootFolderId();

  return (
    <CreateLessonClient googleDriveParentFolderId={googleDriveParentFolderId} />
  );
}

// ==========================================
// FILE: src/app/(main)/dashboard/teacher/lessons/create/create-lesson-client.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useStages, useLevels, useSubjects, useLessons } from "@/hooks";
import { Save, Loader2, Paperclip, Plus } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { RichTextEditor } from "@/components/editor";
import { FileUpload } from "@/components/FileUpload";

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Google Drive Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø£Ùˆ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© Ø¥Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· Proxy
// Ù‡Ø°Ø§ ÙŠØ¶Ù…Ù† Ø¸Ù‡ÙˆØ± Ø§Ù„ØµÙˆØ±Ø© Ø­ØªÙ‰ Ù„Ùˆ ÙØ´Ù„ Ø§Ù„Ø³ÙŠØ±ÙØ± ÙÙŠ ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù ÙƒØµÙˆØ±Ø©
const getProxiedUrl = (url: string) => {
  if (!url) return "";
  // Ø¥Ø¶Ø§ÙØ© Ù„Ø§Ø­Ù‚Ø© ÙˆÙ‡Ù…ÙŠØ© Ù„Ù„ØµÙˆØ±Ø© Ù„ÙƒÙŠ ÙŠØªØ¹Ø±Ù Ø¹Ù„ÙŠÙ‡Ø§ Ù…ÙƒÙˆÙ† FileUpload ÙˆØ§Ù„Ù…ØªØµÙØ­ ÙƒØµÙˆØ±Ø©
  const suffix = "&t=image.jpg";
  if (url.startsWith('/api/images/proxy')) return url.includes(suffix) ? url : `${url}${suffix}`;
  
  const idMatch = url.match(/id=([a-zA-Z0-9_-]+)/) || url.match(/\/d\/([a-zA-Z0-9_-]+)/);
  if ((url.includes('drive.google.com') || url.includes('googleusercontent.com')) && idMatch && idMatch[1]) {
    return `/api/images/proxy?fileId=${idMatch[1]}${suffix}`;
  }
  
  return url;
};

interface CreateLessonClientProps {
  googleDriveParentFolderId: string | null;
}

export default function CreateLessonClient({ googleDriveParentFolderId }: CreateLessonClientProps) {
  const router = useRouter();
  const { toast } = useToast();
  const { data: session } = useSession();
  const { stages, isLoading: stagesLoading } = useStages();
  const { levels, isLoading: levelsLoading } = useLevels();
  const { subjects, isLoading: subjectsLoading } = useSubjects();
  const { createLesson } = useLessons();
  
  const [teacherSubject, setTeacherSubject] = useState<any>(null);
  const [teacherStage, setTeacherStage] = useState<any>(null);
  const [availableLevels, setAvailableLevels] = useState<any[]>([]);

  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [videoUrl, setVideoUrl] = useState("");
  const [imageUrl, setImageUrl] = useState("");
  const [pdfUrl, setPdfUrl] = useState("");
  const [pptUrl, setPptUrl] = useState("");
  const [levelId, setLevelId] = useState<string>("");
  const [uploadedImageFileId, setUploadedImageFileId] = useState<string | null>(null);
  const [uploadedPdfFileId, setUploadedPdfFileId] = useState<string | null>(null);
  const [uploadedPptFileId, setUploadedPptFileId] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  // Ø­Ø§Ù„Ø§Øª Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø¸Ù‡ÙˆØ± Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ø±ÙØ¹
  const [showImageUpload, setShowImageUpload] = useState(false);
  const [showPdfUpload, setShowPdfUpload] = useState(false);
  const [showPptUpload, setShowPptUpload] = useState(false);
  const [isFileUploading, setIsFileUploading] = useState(false);

  // Set teacher's subject, stage and available levels
  useEffect(() => {
    const setTeacherInfo = async () => {
      if (!session?.user?.id || !subjects || !stages || !levels) return;
      if (subjects.length === 0 || stages.length === 0 || levels.length === 0) return;

      try {
        const response = await fetch(`/api/users/${session.user.id}`);
        const result = await response.json();

        if (result.success && result.data?.userDetails?.subjectId) {
          const userSubjectId = result.data.userDetails.subjectId;
          const subject = subjects.find((s: any) => s.id === userSubjectId);

          if (subject) {
            setTeacherSubject(subject);
            const stage = stages.find((st: any) => st.id === subject.stageId || st.id === subject.stage_id);
            
            if (stage) {
              setTeacherStage(stage);
              const stageLevels = levels.filter((l: any) => l.stageId === stage.id);
              setAvailableLevels(stageLevels);
            }
          }
        }
      } catch (error) {
        console.error('Error fetching teacher info:', error);
      }
    };

    setTeacherInfo();
  }, [session, subjects, stages, levels]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!title || !content || !teacherSubject || !levelId) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);
    const result = await createLesson({
      title,
      content,
      videoUrl: videoUrl || undefined,
      imageUrl: imageUrl || undefined,
      pdfUrl: pdfUrl || undefined,
      subjectId: teacherSubject.id,
      levelId: parseInt(levelId),
    });

    setIsSubmitting(false);

    if (result.success) {
      toast({
        title: "Ù†Ø¬Ø­",
        description: "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­",
      });
      router.push("/dashboard/teacher/lessons");
    } else {
      toast({
        title: "Ø®Ø·Ø£",
        description: result.error || "ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³",
        variant: "destructive",
      });
    }
  };

  // A teacher can only create private lessons, so we don't show the switch.
  // We assume the form submission will enforce this.

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯</h1>
        <p className="text-muted-foreground">
          Ø§Ù…Ù„Ø£ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¥Ø¶Ø§ÙØ© Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯. Ø³ØªÙƒÙˆÙ† ÙƒÙ„ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ ØªÙ†Ø´Ø¦Ù‡Ø§ Ø®Ø§ØµØ© Ø¨Ø·Ù„Ø§Ø¨Ùƒ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø¨Ùƒ.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³</CardTitle>
          <CardDescription>
            {teacherSubject && teacherStage && `${teacherSubject.name} - ${teacherStage.name}`}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="title">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <Input 
                id="title" 
                placeholder="Ù…Ø«Ø§Ù„: Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¬Ø¨Ø±" 
                value={title}
                onChange={(e) => setTitle(e.target.value)}
                required
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <Label htmlFor="subject">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                <Input 
                  id="subject" 
                  value={teacherSubject?.name || 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...'}
                  readOnly
                  disabled
                  className="bg-muted"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                <Input 
                  id="stage" 
                  value={teacherStage?.name || 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...'}
                  readOnly
                  disabled
                  className="bg-muted"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ *</Label>
              <Select value={levelId} onValueChange={setLevelId} disabled={!teacherStage || availableLevels.length === 0}>
                <SelectTrigger id="level">
                  <SelectValue placeholder={!teacherStage ? "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„..." : "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰"} />
                </SelectTrigger>
                <SelectContent>
                  {availableLevels.map((level) => (
                    <SelectItem key={level.id} value={String(level.id)}>
                      {level.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <p className="text-xs text-muted-foreground">
                Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¯Ø±Ø³
              </p>
            </div>

            <div className="space-y-2">
              <Label htmlFor="content">Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <RichTextEditor 
                content={content}
                onChange={(newContent) => setContent(newContent)}
                placeholder="Ø§ÙƒØªØ¨ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ Ù‡Ù†Ø§..."
                googleDriveParentFolderId={googleDriveParentFolderId || undefined}
              />
              <p className="text-xs text-muted-foreground">
                Ø§Ø³ØªØ®Ø¯Ù… Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ©
              </p>
            </div>

            {/* Ù‚Ø³Ù… Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª ÙˆØ§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†Ø³Ø¯Ù„Ø© */}
            <div className="space-y-4 border rounded-lg p-4 bg-muted/20">
              <div className="flex items-center justify-between">
                <Label className="text-base font-semibold flex items-center gap-2">
                  <Paperclip className="w-4 h-4" />
                  Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª
                </Label>
                
                <Select 
                  disabled={isFileUploading || isSubmitting} 
                  onValueChange={(value) => {
                    if (value === 'image') setShowImageUpload(true);
                    if (value === 'pdf') setShowPdfUpload(true);
                    if (value === 'ppt') setShowPptUpload(true);
                    if (value === 'video') { /* ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù‡Ù†Ø§ Ù…Ø³ØªÙ‚Ø¨Ù„Ø§Ù‹ */ }
                  }}
                >
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="Ø¥Ø¶Ø§ÙØ© Ù…Ø±ÙÙ‚..." />
                  </SelectTrigger>
                  <SelectContent>
                    {!showImageUpload && <SelectItem value="image">ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³</SelectItem>}
                    {!showPdfUpload && <SelectItem value="pdf">Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)</SelectItem>}
                    {!showPptUpload && <SelectItem value="ppt" disabled>Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint) - Ù‚Ø±ÙŠØ¨Ø§Ù‹</SelectItem>}
                    <SelectItem value="video" disabled>ÙÙŠØ¯ÙŠÙˆ (Ù‚Ø±ÙŠØ¨Ø§Ù‹)</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-4">
                {/* Ø­Ù‚Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ - ÙŠØ¸Ù‡Ø± Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ù„Ø£Ù†Ù‡ Ù…Ø¬Ø±Ø¯ Ø±Ø§Ø¨Ø· Ù†ØµÙŠ */}
                <div className="space-y-2">
                  <Label htmlFor="video-url">Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (ÙŠÙˆØªÙŠÙˆØ¨)</Label>
                  <Input 
                    id="video-url" 
                    placeholder="https://www.youtube.com/watch?v=..." 
                    value={videoUrl}
                    onChange={(e) => setVideoUrl(e.target.value)}
                    disabled={isSubmitting} // Ù„Ø§ ÙŠØªØ¹Ø·Ù„ Ø£Ø«Ù†Ø§Ø¡ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª
                  />
                </div>

                {showImageUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³"
                      accept="image/*"
                      maxSizeMB={5}
                      value={imageUrl}
                      onChange={(fileInfo) => {
                        setImageUrl(getProxiedUrl(fileInfo?.fileUrl || ""));
                      }}
                      onUploadStatusChange={setIsFileUploading}
                      parentFolderId={googleDriveParentFolderId || undefined}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù Ù„Ù„Ø¯Ø±Ø³ (JPG, PNG, GIF, Ø­ØªÙ‰ 5 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}

                {showPdfUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)"
                      accept=".pdf"
                      maxSizeMB={10}
                      value={pdfUrl}
                      onChange={(fileInfo) => setPdfUrl(fileInfo?.fileUrl || "")}
                      onUploadStatusChange={setIsFileUploading}
                      parentFolderId={googleDriveParentFolderId || undefined}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù PDF Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}

                {showPptUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint)"
                      accept=".ppt,.pptx"
                      maxSizeMB={10}
                      value={pptUrl}
                      onChange={(fileInfo) => {
                        setPptUrl(fileInfo?.fileUrl || "");
                      }}
                      onUploadStatusChange={setIsFileUploading}
                      parentFolderId={googleDriveParentFolderId || undefined}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint) Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={teacherStage?.name}
                      subject={teacherSubject?.name}
                      teacher={session?.user?.name || "Teacher"}
                      lesson={title}
                    />
                  </div>
                )}
              </div>
            </div>

            <div className="flex justify-end gap-4">
              <Button 
                type="button" 
                variant="outline"
                onClick={() => router.back()}
                disabled={isSubmitting}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
              <Button type="submit" disabled={isSubmitting || isFileUploading}>
                {isSubmitting || isFileUploading ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    <span>{isFileUploading ? "Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª..." : "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸..."}</span>
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    <span>Ø­ÙØ¸ Ø§Ù„Ø¯Ø±Ø³</span>
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}

// ==========================================
// FILE: src/app/(main)/dashboard/teacher/lessons/page.tsx
// ==========================================

'use client';

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { PlusCircle, FilePenLine, Eye, Trash2, Loader2 } from "lucide-react";
import Link from "next/link";
import { Badge } from "@/components/ui/badge";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { useLessons } from "@/hooks";
import { useSession } from "next-auth/react";
import { useToast } from "@/hooks/use-toast";

export default function MyLessonsPage() {
  const { data: session } = useSession();
  const { toast } = useToast();
  
  const { lessons, isLoading, deleteLesson } = useLessons({
    authorId: session?.user?.id,
  });

  const handleDelete = async (id: number) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø¯Ø±Ø³ØŸ')) return;
    
    const result = await deleteLesson(id);
    if (result.success) {
      toast({
        title: 'ØªÙ… Ø§Ù„Ø­Ø°Ù',
        description: 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­',
      });
    } else {
      toast({
        title: 'Ø®Ø·Ø£',
        description: result.error || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <div className="grid gap-1">
          <h1 className="text-3xl font-bold tracking-tight">Ø¯Ø±ÙˆØ³ÙŠ</h1>
          <p className="text-muted-foreground">
            Ù‚Ù… Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§.
          </p>
        </div>
        <Link href="/dashboard/teacher/lessons/create" passHref>
          <Button>
            <PlusCircle className="ml-2 h-4 w-4" />
            <span>Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯</span>
          </Button>
        </Link>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø±ÙˆØ³</CardTitle>
          <CardDescription>
            Ù‡Ø°Ù‡ Ù‡ÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø¥Ø¶Ø§ÙØªÙ‡Ø§ Ù„Ø·Ù„Ø§Ø¨Ùƒ.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³</TableHead>
                <TableHead>Ø§Ù„Ù…Ø§Ø¯Ø©</TableHead>
                <TableHead>Ø§Ù„Ù†ÙˆØ¹</TableHead>
                <TableHead className="text-center">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {lessons.length > 0 ? (
                lessons.map((lesson) => (
                  <TableRow key={lesson.id}>
                    <TableCell className="font-medium">{lesson.title}</TableCell>
                    <TableCell>{lesson.subject?.name || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</TableCell>
                    <TableCell>
                      <Badge variant="default">
                        Ù…Ø¹ØªÙ…Ø¯
                      </Badge>
                    </TableCell>
                    <TableCell className="text-center">
                      <div className="flex justify-center gap-2">
                        <Link href={`/lessons/${lesson.id}`} passHref>
                          <Button variant="ghost" size="icon" title="Ù…Ø¹Ø§ÙŠÙ†Ø©">
                            <Eye className="h-4 w-4" />
                          </Button>
                        </Link>
                        <Link href={`/dashboard/teacher/lessons/${lesson.id}/edit`} passHref>
                          <Button variant="ghost" size="icon" title="ØªØ¹Ø¯ÙŠÙ„">
                            <FilePenLine className="h-4 w-4" />
                          </Button>
                        </Link>
                        <Button 
                          variant="ghost" 
                          size="icon" 
                          title="Ø­Ø°Ù" 
                          className="text-destructive hover:text-destructive"
                          onClick={() => handleDelete(lesson.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={4} className="text-center h-24">
                    Ù„Ù… ØªÙ‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠ Ø¯Ø±ÙˆØ³ Ø¨Ø¹Ø¯.
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/exercises/[id]/edit/page.tsx
// ==========================================


'use client';

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useLessons, useExercises } from "@/hooks";
import { Save, UploadCloud, Loader2 } from "lucide-react";
import { notFound } from "next/navigation";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";

export default function EditExercisePage({ params }: { params: Promise<{ id: string }> }) {
  const router = useRouter();
  const { data: session } = useSession();
  const { toast } = useToast();
  const { lessons, isLoading: lessonsLoading } = useLessons({
    authorId: session?.user?.id,
  });
  const { updateExercise } = useExercises();

  const [exerciseId, setExerciseId] = useState<string>("");
  const [exercise, setExercise] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [lessonId, setLessonId] = useState<string>("");
  const [question, setQuestion] = useState("");
  const [modelAnswer, setModelAnswer] = useState("");
  const [questionFileUrl, setQuestionFileUrl] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  useEffect(() => {
    const fetchExercise = async () => {
      try {
        const resolvedParams = await params;
        const id = resolvedParams.id;
        setExerciseId(id);
        const response = await fetch(`/api/exercises/${id}`);
        if (!response.ok) {
          notFound();
          return;
        }
        const data = await response.json();
        const exerciseData = data.data;
        setExercise(exerciseData);
        setLessonId(String(exerciseData.lessonId));
        setQuestion(exerciseData.question);
        setModelAnswer(exerciseData.modelAnswer);
        setQuestionFileUrl(exerciseData.questionFileUrl || "");
      } catch (error) {
        console.error('Error fetching exercise:', error);
        notFound();
      } finally {
        setIsLoading(false);
      }
    };
    fetchExercise();
  }, [params]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!lessonId || !question || !modelAnswer) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);
    const result = await updateExercise(Number(exerciseId), {
      lessonId: parseInt(lessonId),
      question,
      modelAnswer,
      questionFileUrl: questionFileUrl || undefined,
    });

    setIsSubmitting(false);

    if (result.success) {
      toast({
        title: "Ù†Ø¬Ø­",
        description: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­",
      });
      router.push("/dashboard/teacher/exercises");
    } else {
      toast({
        title: "Ø®Ø·Ø£",
        description: result.error || "ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ…Ø±ÙŠÙ†",
        variant: "destructive",
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-96">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!exercise) {
    notFound();
    return null;
  }

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªÙ…Ø±ÙŠÙ†</h1>
        <p className="text-muted-foreground">
          Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø£Ø¯Ù†Ø§Ù‡.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªÙ…Ø±ÙŠÙ†</CardTitle>
          <CardDescription>
            Ù‚Ù… Ø¨ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„ØªÙ…Ø±ÙŠÙ†.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="lesson">Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„Ù…Ø±ØªØ¨Ø· *</Label>
              <Select value={lessonId} onValueChange={setLessonId} disabled={lessonsLoading}>
                <SelectTrigger id="lesson">
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ø¯Ø±Ø³" />
                </SelectTrigger>
                <SelectContent>
                  {Array.isArray(lessons) && lessons.filter(l => l && l.id).map((lesson) => (
                    <SelectItem key={lesson.id} value={String(lesson.id)}>
                      {lesson.title}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="question">Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ *</Label>
              <Textarea 
                id="question" 
                value={question} 
                onChange={(e) => setQuestion(e.target.value)}
                rows={5}
                required
              />
            </div>

            <div className="space-y-2">
                <Label>Ø¥Ø±ÙØ§Ù‚ Ù…Ù„Ù Ù„Ù„Ø³Ø¤Ø§Ù„ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</Label>
                <div className="flex items-center justify-center w-full">
                    <Label htmlFor="dropzone-file" className="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed rounded-lg cursor-pointer bg-muted hover:bg-muted/80">
                        <div className="flex flex-col items-center justify-center pt-5 pb-6">
                            <UploadCloud className="w-8 h-8 mb-4 text-muted-foreground" />
                            <p className="mb-2 text-sm text-muted-foreground"><span className="font-semibold">Ø§Ù†Ù‚Ø± Ù„Ù„Ø±ÙØ¹</span> Ø£Ùˆ Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ø§Ù„Ù…Ù„Ù</p>
                            <p className="text-xs text-muted-foreground">ØµÙˆØ±Ø© Ø£Ùˆ PDF</p>
                        </div>
                        <Input id="dropzone-file" type="file" className="hidden" />
                    </Label>
                </div> 
                {exercise.question_file_url && (
                    <div className="text-sm text-muted-foreground">
                        Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø­Ø§Ù„ÙŠ: <a href={exercise.question_file_url} target="_blank" rel="noopener noreferrer" className="text-primary underline">{exercise.question_file_url}</a>
                    </div>
                )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="question-file-url">Ø±Ø§Ø¨Ø· Ù…Ù„Ù Ø§Ù„Ø³Ø¤Ø§Ù„ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</Label>
              <Input 
                id="question-file-url" 
                placeholder="https://example.com/question.pdf" 
                value={questionFileUrl}
                onChange={(e) => setQuestionFileUrl(e.target.value)}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="model-answer">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ© *</Label>
              <Textarea 
                id="model-answer" 
                value={modelAnswer}
                onChange={(e) => setModelAnswer(e.target.value)}
                rows={5}
                required
              />
            </div>

            <div className="flex justify-end gap-4">
              <Button 
                type="button" 
                variant="outline"
                onClick={() => router.back()}
                disabled={isSubmitting}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    <span>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...</span>
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    <span>Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª</span>
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/exercises/create/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useLessons, Lesson } from "@/hooks/use-lessons";
import { useLevels } from "@/hooks/use-data";
import { Save, Loader2, Plus, Trash2, Sparkles } from "lucide-react";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { RichTextEditor } from "@/components/editor";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";

type ExerciseType = 'main' | 'support_with_results' | 'support_only';

interface ExpectedResult {
  question: string;
  result: string;
}

export default function CreateExercisePage() {
  const router = useRouter();
  const { data: session } = useSession();
  const { toast } = useToast();
  
  // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø­Ø³Ø¨ Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£Ø³ØªØ§Ø° (ÙÙ‚Ø· Ø¹Ù†Ø¯Ù…Ø§ ØªÙƒÙˆÙ† Ø§Ù„Ø¬Ù„Ø³Ø© Ø¬Ø§Ù‡Ø²Ø©)
  const { levels, isLoading: levelsLoading } = useLevels(
    session?.user?.stage_id ? { stageId: session.user.stage_id } : undefined
  );
  const [selectedLevelId, setSelectedLevelId] = useState<number | undefined>(undefined);
  
  // Ø¬Ù„Ø¨ Ø§Ù„Ø¯Ø±ÙˆØ³ Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø³ØªÙˆÙ‰
  const { lessons, isLoading: lessonsLoading } = useLessons({
    authorId: session?.user?.id,
    levelId: selectedLevelId,
    include: { subject: true, level: true },
  });

  const [lessonId, setLessonId] = useState<string>("");
  const [exerciseType, setExerciseType] = useState<ExerciseType>('main');
  const [questionContent, setQuestionContent] = useState("");
  const [questionFileUrl, setQuestionFileUrl] = useState("");
  const [modelAnswer, setModelAnswer] = useState("");
  const [modelAnswerImage, setModelAnswerImage] = useState("");
  const [maxScore, setMaxScore] = useState("20");
  const [allowRetry, setAllowRetry] = useState(true);
  const [maxAttempts, setMaxAttempts] = useState("3");
  const [expectedResults, setExpectedResults] = useState<ExpectedResult[]>([
    { question: "1", result: "" }
  ]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isGeneratingAnswer, setIsGeneratingAnswer] = useState(false);

  // 2. Improved function to generate AI answer with context
  const handleGenerateAnswer = async () => {
    if (!questionContent.trim()) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©.",
        variant: "destructive",
      });
      return;
    }

    if (!lessonId) {
      toast({
        title: "Ø§Ø®ØªØ± Ø§Ù„Ø¯Ø±Ø³ Ø£ÙˆÙ„Ø§Ù‹",
        description: "ÙŠØ¬Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯Ø±Ø³ Ù„ØªÙˆÙÙŠØ± Ø³ÙŠØ§Ù‚ Ø£ÙØ¶Ù„ Ù„Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ.",
        variant: "destructive",
      });
      return;
    }

    const selectedLesson = lessons.find(l => String(l.id) === lessonId);

    setIsGeneratingAnswer(true);
    try {
      const response = await fetch('/api/ai/generate-answer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: questionContent,
          subject: selectedLesson?.subject?.name, // Pass subject for context
          level: selectedLesson?.level?.name,     // Pass level for context
        }),
      });

      const result = await response.json();

      if (response.ok && result.success) {
        setModelAnswer(result.data.answer);
        toast({
          title: "ØªÙ… Ø¨Ù†Ø¬Ø§Ø­",
          description: "ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©. ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§ ÙˆØªØ¹Ø¯ÙŠÙ„Ù‡Ø§.",
        });
      } else {
        throw new Error(result.error || "ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ");
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setIsGeneratingAnswer(false);
    }
  };

  const handleAddResult = () => {
    setExpectedResults([
      ...expectedResults,
      { question: String(expectedResults.length + 1), result: "" }
    ]);
  };

  const handleRemoveResult = (index: number) => {
    setExpectedResults(expectedResults.filter((_, i) => i !== index));
  };

  const handleResultChange = (index: number, field: 'question' | 'result', value: string) => {
    const newResults = [...expectedResults];
    newResults[index][field] = value;
    setExpectedResults(newResults);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!lessonId || !questionContent) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯Ø±Ø³ ÙˆÙƒØªØ§Ø¨Ø© Ø§Ù„Ø³Ø¤Ø§Ù„",
        variant: "destructive",
      });
      return;
    }

    if (exerciseType === 'main' && !modelAnswer) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ¬Ø¨ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù„Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ",
        variant: "destructive",
      });
      return;
    }

    if (exerciseType === 'support_with_results') {
      const hasEmptyResults = expectedResults.some(r => !r.result.trim());
      if (hasEmptyResults) {
        toast({
          title: "Ø®Ø·Ø£",
          description: "ÙŠØ¬Ø¨ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©",
          variant: "destructive",
        });
        return;
      }
    }

    setIsSubmitting(true);

    try {
      const response = await fetch(`/api/exercises?lessonId=${lessonId}`);
      const result = await response.json();
      const existingExercises = result.success ? (result.data || []) : [];
      const displayOrder = existingExercises.length + 1;

      const exerciseData: any = {
        lessonId: parseInt(lessonId),
        type: exerciseType,
        questionRichContent: questionContent,
        questionFileUrl: questionFileUrl || null,
        displayOrder,
      };

      if (exerciseType === 'main') {
        exerciseData.modelAnswer = modelAnswer;
        if (modelAnswerImage) exerciseData.modelAnswerImage = modelAnswerImage;
        exerciseData.maxScore = parseFloat(maxScore);
        exerciseData.allowRetry = allowRetry;
        exerciseData.maxAttempts = parseInt(maxAttempts);
      } else if (exerciseType === 'support_with_results') {
        exerciseData.expectedResults = expectedResults;
      }

      const createResponse = await fetch('/api/exercises', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(exerciseData),
      });

      const createResult = await createResponse.json();

      if (createResult.success) {
        toast({
          title: "Ù†Ø¬Ø­",
          description: "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­",
        });
        router.push("/dashboard/teacher/lessons"); // Redirect to lessons list to see the new exercise within its lesson
      } else {
        throw new Error(createResult.error || "ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ†");
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message || "ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ†",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };
  
    const getExerciseTypeLabel = (type: ExerciseType) => {
    switch (type) {
      case 'main':
        return 'ØªÙ…Ø±ÙŠÙ† Ø±Ø¦ÙŠØ³ÙŠ (ØªØµØ­ÙŠØ­ Ø°ÙƒÙŠ)';
      case 'support_with_results':
        return 'ØªÙ…Ø±ÙŠÙ† Ø¯Ø¹Ù… + Ù†ØªØ§Ø¦Ø¬';
      case 'support_only':
        return 'ØªÙ…Ø±ÙŠÙ† Ø¯Ø¹Ù… ÙÙ‚Ø·';
    }
  };

  const getExerciseTypeDescription = (type: ExerciseType) => {
    switch (type) {
      case 'main':
        return 'ÙŠØªÙ… ØªØµØ­ÙŠØ­Ù‡ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙˆÙŠØ­ØµÙ„ Ø§Ù„ØªÙ„Ù…ÙŠØ° Ø¹Ù„Ù‰ Ù†Ù‚Ø·Ø© ÙˆÙ…Ù„Ø§Ø­Ø¸Ø§Øª';
      case 'support_with_results':
        return 'ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„ØªÙ„Ù…ÙŠØ° Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆÙ…Ù‚Ø§Ø±Ù†ØªÙ‡Ø§ Ù…Ø¹ Ø§Ù„Ø­Ù„ Ø§Ù„ØµØ­ÙŠØ­';
      case 'support_only':
        return 'Ø¹Ø±Ø¶ ÙÙ‚Ø· - Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù„Ù„ØªÙ„Ù…ÙŠØ° Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©';
    }
  };


  if (lessonsLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  };

  return (
    <div className="flex flex-col gap-8">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">Ø¥Ù†Ø´Ø§Ø¡ ØªÙ…Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯</h1>
        <p className="text-muted-foreground">
          Ø£Ø¶Ù ØªÙ…Ø±ÙŠÙ†Ø§Ù‹ Ø¬Ø¯ÙŠØ¯Ø§Ù‹ Ù„Ø·Ù„Ø§Ø¨Ùƒ Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨.
        </p>
      </div>

      <form onSubmit={handleSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙ…Ø±ÙŠÙ†</CardTitle>
            <CardDescription>
              Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªÙ…Ø±ÙŠÙ† ÙˆØ£Ø¯Ø®Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ - Ù„ØªØµÙÙŠØ© Ø§Ù„Ø¯Ø±ÙˆØ³)</Label>
              <Select 
                value={selectedLevelId?.toString() || "all"} 
                onValueChange={(value) => setSelectedLevelId(value === "all" ? undefined : parseInt(value))}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</SelectItem>
                  {levels && Array.isArray(levels) && levels.map((level) => (
                    <SelectItem key={level.id} value={String(level.id)}>
                      {level.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="lesson">Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <Select value={lessonId} onValueChange={setLessonId}>
                <SelectTrigger>
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ø¯Ø±Ø³" />
                </SelectTrigger>
                <SelectContent>
                  {lessons.length === 0 ? (
                    <SelectItem value="none" disabled>
                      {lessonsLoading ? "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„..." : "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¯Ø±ÙˆØ³ Ù…ØªØ§Ø­Ø©"}
                    </SelectItem>
                  ) : (
                    lessons.map((lesson) => (
                      <SelectItem key={lesson.id} value={String(lesson.id)}>
                        {lesson.title}
                        {lesson.subject && lesson.level && ` (${lesson.subject.name} - ${lesson.level.name})`}
                      </SelectItem>
                    ))
                  )}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-3">
              <Label>Ù†ÙˆØ¹ Ø§Ù„ØªÙ…Ø±ÙŠÙ† *</Label>
              <div className="grid gap-3">
                {(['main', 'support_with_results', 'support_only'] as ExerciseType[]).map((type) => (
                  <Card
                    key={type}
                    className={`cursor-pointer transition-all ${
                      exerciseType === type
                        ? 'border-primary bg-primary/5'
                        : 'hover:border-primary/50'
                    }`}
                    onClick={() => setExerciseType(type)}
                  >
                    <CardHeader className="p-4">
                      <div className="flex items-start justify-between">
                        <div className="space-y-1">
                          <CardTitle className="text-base">
                            {getExerciseTypeLabel(type)}
                          </CardTitle>
                          <CardDescription className="text-sm">
                            {getExerciseTypeDescription(type)}
                          </CardDescription>
                        </div>
                        {exerciseType === type && (
                          <Badge variant="default">Ù…Ø®ØªØ§Ø±</Badge>
                        )}
                      </div>
                    </CardHeader>
                  </Card>
                ))}
              </div>
            </div>

            <div className="space-y-2">
              <Label>Ø§Ù„Ø³Ø¤Ø§Ù„ / Ø§Ù„ØªÙ…Ø±ÙŠÙ† *</Label>
              <RichTextEditor
                content={questionContent}
                onChange={setQuestionContent}
                placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù‡Ù†Ø§... ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© ØµÙˆØ± ÙˆØ¬Ø¯Ø§ÙˆÙ„"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="questionFileUrl">Ø±Ø§Ø¨Ø· Ù…Ù„Ù Ø§Ù„Ø³Ø¤Ø§Ù„ (PDF Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</Label>
              <Input
                id="questionFileUrl"
                type="url"
                placeholder="https://example.com/question.pdf"
                value={questionFileUrl}
                onChange={(e) => setQuestionFileUrl(e.target.value)}
              />
            </div>

            {exerciseType === 'main' && (
              <>
                <div className="space-y-2">
                  <div className="flex items-center justify-between mb-2">
                    <Label>Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ *</Label>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={handleGenerateAnswer}
                      disabled={isGeneratingAnswer || !lessonId}
                    >
                      {isGeneratingAnswer ? (
                        <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                      ) : (
                        <Sparkles className="ml-2 h-4 w-4" />
                      )}
                      ØªÙˆÙ„ÙŠØ¯ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
                    </Button>
                  </div>
                  <RichTextEditor
                    content={modelAnswer}
                    onChange={setModelAnswer}
                    placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù‡Ù†Ø§ØŒ Ø£Ùˆ Ù‚Ù… Ø¨ØªÙˆÙ„ÙŠØ¯Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹..."
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="modelAnswerImage">ØµÙˆØ±Ø© Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</Label>
                  <Input
                    id="modelAnswerImage"
                    type="url"
                    placeholder="https://example.com/image.jpg"
                    value={modelAnswerImage}
                    onChange={(e) => setModelAnswerImage(e.target.value)}
                  />
                </div>

                <div className="grid gap-4 sm:grid-cols-3">
                  <div className="space-y-2">
                    <Label htmlFor="maxScore">Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ù‚ØµÙˆÙ‰</Label>
                    <Input
                      id="maxScore"
                      type="number"
                      step="0.5"
                      min="1"
                      max="100"
                      value={maxScore}
                      onChange={(e) => setMaxScore(e.target.value)}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="maxAttempts">Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª</Label>
                    <Input
                      id="maxAttempts"
                      type="number"
                      min="1"
                      max="10"
                      value={maxAttempts}
                      onChange={(e) => setMaxAttempts(e.target.value)}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="allowRetry">Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø©</Label>
                    <div className="flex items-center gap-2 h-10">
                      <Switch
                        id="allowRetry"
                        checked={allowRetry}
                        onCheckedChange={setAllowRetry}
                      />
                      <span className="text-sm">{allowRetry ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'}</span>
                    </div>
                  </div>
                </div>
              </>
            )}

            {exerciseType === 'support_with_results' && (
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <Label>Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© *</Label>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={handleAddResult}
                  >
                    <Plus className="h-4 w-4 ml-2" />
                    Ø¥Ø¶Ø§ÙØ© Ù†ØªÙŠØ¬Ø©
                  </Button>
                </div>

                <div className="space-y-3">
                  {expectedResults.map((result, index) => (
                    <Card key={index}>
                      <CardContent className="p-4">
                        <div className="flex gap-3">
                          <div className="flex-1 grid gap-3 sm:grid-cols-2">
                            <div className="space-y-2">
                              <Label>Ø±Ù‚Ù… Ø§Ù„Ø³Ø¤Ø§Ù„</Label>
                              <Input
                                placeholder="1"
                                value={result.question}
                                onChange={(e) =>
                                  handleResultChange(index, 'question', e.target.value)
                                }
                              />
                            </div>
                            <div className="space-y-2">
                              <Label>Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©</Label>
                              <Input
                                placeholder="Ù…Ø«Ø§Ù„: 45 Ø£Ùˆ 3x - 5"
                                value={result.result}
                                onChange={(e) =>
                                  handleResultChange(index, 'result', e.target.value)
                                }
                              />
                            </div>
                          </div>
                          {expectedResults.length > 1 && (
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              onClick={() => handleRemoveResult(index)}
                              className="text-destructive"
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          )}
                        </div>
                      </CardContent>
                    </Card>
                  ))}
                </div>
              </div>
            )}

            {exerciseType === 'support_only' && (
              <div className="rounded-lg border border-muted bg-muted/50 p-4">
                <p className="text-sm text-muted-foreground">
                  â„¹ï¸ Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ù„Ù„Ø¹Ø±Ø¶ ÙÙ‚Ø·. Ù„Ù† ÙŠØªÙ…ÙƒÙ† Ø§Ù„ØªÙ„Ø§Ù…ÙŠØ° Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø¥Ø¬Ø§Ø¨Ø§Øª.
                </p>
              </div>
            )}

            <div className="flex gap-3 pt-4">
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸...
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    Ø­ÙØ¸ Ø§Ù„ØªÙ…Ø±ÙŠÙ†
                  </>
                )}
              </Button>
              <Button
                type="button"
                variant="outline"
                onClick={() => router.back()}
                disabled={isSubmitting}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
            </div>
          </CardContent>
        </Card>
      </form>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/teacher/exercises/page.tsx
// ==========================================

'use client';

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { PlusCircle, FilePenLine, Trash2, Loader2 } from "lucide-react";
import Link from "next/link";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { useExercises, useLessons } from "@/hooks";
import { useSession } from "next-auth/react";
import { useToast } from "@/hooks/use-toast";

export default function MyExercisesPage() {
  const { data: session } = useSession();
  const { toast } = useToast();
  
  // Ø¬Ù„Ø¨ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø£Ø³ØªØ§Ø° Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† API
  const { exercises: myExercises, isLoading, deleteExercise } = useExercises({
    authorId: session?.user?.id,
  });
  
  // Ø¬Ù„Ø¨ Ø§Ù„Ø¯Ø±ÙˆØ³ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙØ§ØµÙŠÙ„Ù‡Ø§
  const { lessons } = useLessons({ authorId: session?.user?.id });

  const handleDelete = async (id: number) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ†ØŸ')) return;
    
    const result = await deleteExercise(id);
    if (result.success) {
      toast({
        title: 'ØªÙ… Ø§Ù„Ø­Ø°Ù',
        description: 'ØªÙ… Ø­Ø°Ù Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­',
      });
    } else {
      toast({
        title: 'Ø®Ø·Ø£',
        description: result.error || 'ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„ØªÙ…Ø±ÙŠÙ†',
        variant: 'destructive',
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <div className="grid gap-1">
          <h1 className="text-3xl font-bold tracking-tight">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</h1>
          <p className="text-muted-foreground">
            Ù‚Ù… Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§.
          </p>
        </div>
        <Link href="/dashboard/teacher/exercises/create" passHref>
          <Button>
            <PlusCircle className="ml-2 h-4 w-4" />
            <span>Ø¥Ø¶Ø§ÙØ© ØªÙ…Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯</span>
          </Button>
        </Link>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</CardTitle>
          <CardDescription>
            Ù‡Ø°Ù‡ Ù‡ÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø¥Ø¶Ø§ÙØªÙ‡Ø§ Ø¥Ù„Ù‰ Ø¯Ø±ÙˆØ³Ùƒ.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„</TableHead>
                <TableHead>Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„Ù…Ø±ØªØ¨Ø·</TableHead>
                <TableHead className="text-center">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {myExercises.length > 0 ? (
                myExercises.map((exercise) => {
                  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ù† HTML
                  const getPlainText = (html: string) => {
                    if (!html) return '';
                    return html.replace(/<[^>]*>/g, '').substring(0, 100);
                  };
                  const questionText = exercise.questionRichContent 
                    ? getPlainText(exercise.questionRichContent) + '...'
                    : (exercise.question || 'Ø³Ø¤Ø§Ù„ Ø¨Ø¯ÙˆÙ† Ù†Øµ').substring(0, 100) + '...';
                  
                  return (
                    <TableRow key={exercise.id}>
                      <TableCell className="font-medium truncate max-w-md">
                        {questionText}
                      </TableCell>
                      <TableCell>{exercise.lesson?.title || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}</TableCell>
                      <TableCell className="text-center">
                        <div className="flex justify-center gap-2">
                          <Link href={`/dashboard/teacher/exercises/${exercise.id}/edit`} passHref>
                            <Button variant="ghost" size="icon" title="ØªØ¹Ø¯ÙŠÙ„">
                              <FilePenLine className="h-4 w-4" />
                            </Button>
                          </Link>
                        <Button 
                          variant="ghost" 
                          size="icon" 
                          title="Ø­Ø°Ù" 
                          className="text-destructive hover:text-destructive"
                          onClick={() => handleDelete(exercise.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                  );
                })
              ) : (
                <TableRow>
                  <TableCell colSpan={3} className="text-center h-24">
                    Ù„Ù… ØªÙ‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠ ØªÙ…Ø§Ø±ÙŠÙ† Ø¨Ø¹Ø¯.
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/page.tsx
// ==========================================

import { redirect } from "next/navigation";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";

export const dynamic = 'force-dynamic';

export default async function DashboardPage() {
  const session = await getServerSession(authOptions);

  if (!session?.user) {
    redirect('/login');
  }

  const role = session.user.role;

  if (role === 'teacher') {
    redirect('/dashboard/teacher');
  } else if (role === 'student') {
    redirect('/dashboard/student');
  } else if (role === 'parent') {
    redirect('/dashboard/parent');
  } else if (role === 'supervisor_specific' || role === 'supervisor_general') {
    redirect('/dashboard/subject-supervisor');
  } else if (role === 'directeur') {
    redirect('/dashboard/directeur');
  } else {
    redirect('/login');
  }

  return <div>Loading...</div>;
}


// ==========================================
// FILE: src/app/(main)/dashboard/student/results/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Eye, BookOpen, Loader2 } from "lucide-react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { format } from "date-fns";
import { ar } from "date-fns/locale";

type Submission = {
  id: number;
  score: number | null;
  aiFeedback: string | null;
  submittedAt: string;
  exercise: {
    id: number;
    question: string;
    lesson: {
      id: number;
      title: string;
    };
  };
};

export default function MyResultsPage() {
    const { data: session } = useSession();
    const [submissions, setSubmissions] = useState<Submission[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
      const fetchResults = async () => {
        try {
          setIsLoading(true);
          const response = await fetch('/api/students/results');
          const result = await response.json();
          if (result.success) {
            setSubmissions(result.data.submissions);
          }
        } catch (error) {
          console.error('Error fetching results:', error);
        } finally {
          setIsLoading(false);
        }
      };

      if (session?.user) {
        fetchResults();
      }
    }, [session]);

    const getScoreVariant = (score: number) => {
        if (score >= 8) return 'default';
        if (score >= 5) return 'secondary';
        return 'destructive';
    };

    if (isLoading) {
      return (
        <div className="flex items-center justify-center min-h-[400px]">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </div>
      );
    }

    return (
        <div className="flex flex-col gap-8">
            <div className="grid gap-1">
                <h1 className="text-3xl font-bold tracking-tight">Ù†ØªØ§Ø¦Ø¬ÙŠ</h1>
                <p className="text-muted-foreground">
                    Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¹Ø±Ø¶ Ø¬Ù…ÙŠØ¹ Ø¥Ø¬Ø§Ø¨Ø§ØªÙƒ ÙˆÙ†ØªØ§Ø¦Ø¬Ùƒ ÙÙŠ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†.
                </p>
            </div>

            <Card>
                <CardHeader>
                    <CardTitle>Ø³Ø¬Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª</CardTitle>
                    <CardDescription>
                        Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø­Ù„Ù‡Ø§ ÙˆØ§Ù„Ø¯Ø±Ø¬Ø§Øª Ø§Ù„ØªÙŠ Ø­ØµÙ„Øª Ø¹Ù„ÙŠÙ‡Ø§.
                    </CardDescription>
                </CardHeader>
                <CardContent>
                    <Table>
                        <TableHeader>
                            <TableRow>
                                <TableHead>Ø§Ù„ØªÙ…Ø±ÙŠÙ†</TableHead>
                                <TableHead>Ø§Ù„Ø¯Ø±Ø¬Ø©</TableHead>
                                <TableHead className="hidden md:table-cell">Ø§Ù„ØªÙ‚ÙŠÙŠÙ…</TableHead>
                                <TableHead className="hidden md:table-cell text-center">ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©</TableHead>
                                <TableHead className="text-center">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                        {submissions.length > 0 ? (
                            submissions.map((submission) => {
                                return (
                                    <TableRow key={submission.id}>
                                        <TableCell className="font-medium max-w-sm truncate">
                                            <p>{submission.exercise.question}</p>
                                            <p className="text-xs text-muted-foreground mt-1 flex items-center gap-1">
                                                <BookOpen className="h-3 w-3" />
                                                {submission.exercise.lesson.title}
                                            </p>
                                        </TableCell>
                                        <TableCell>
                                            <Badge variant={getScoreVariant(submission.score ?? 0)}>
                                                {submission.score ?? 0}/10
                                            </Badge>
                                        </TableCell>
                                        <TableCell className="hidden md:table-cell text-muted-foreground max-w-xs truncate">
                                            {submission.aiFeedback || 'Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ø¹Ø¯'}
                                        </TableCell>
                                        <TableCell className="hidden md:table-cell text-center text-muted-foreground">
                                           {format(new Date(submission.submittedAt), "d MMMM yyyy", { locale: ar })}
                                        </TableCell>
                                        <TableCell className="text-center">
                                            <Link href={`/lessons/${submission.exercise.lesson.id}`} passHref>
                                                <Button variant="ghost" size="icon" title="Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ø±Ø³">
                                                    <Eye className="h-4 w-4" />
                                                </Button>
                                            </Link>
                                        </TableCell>
                                    </TableRow>
                                )
                            })
                        ) : (
                            <TableRow>
                                <TableCell colSpan={5} className="text-center">
                                    Ù„Ù… ØªÙ‚Ù… Ø¨Ø­Ù„ Ø£ÙŠ ØªÙ…Ø§Ø±ÙŠÙ† Ø¨Ø¹Ø¯.
                                </TableCell>
                            </TableRow>
                        )}
                        </TableBody>
                    </Table>
                </CardContent>
            </Card>
        </div>
    );
}



// ==========================================
// FILE: src/app/(main)/dashboard/student/page.tsx
// ==========================================

import StudentDashboard from "../_components/StudentDashboard";

export const dynamic = 'force-dynamic';

export default function StudentDashboardPage() {
    // We assume student ID is 1 for now
    return <StudentDashboard studentId={1} />
}


// ==========================================
// FILE: src/app/(main)/dashboard/student/progress/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { TrendingUp, Target, BookCheck, ClipboardList, Loader2 } from "lucide-react";
import {
  Bar,
  BarChart,
  ResponsiveContainer,
  XAxis,
  YAxis,
  Tooltip,
  Cell,
} from "recharts";

type SubjectProgress = {
  subject: string;
  score: number;
  color: string;
};

type RecentLesson = {
  id: number;
  title: string;
  progress: number;
};

export default function MyProgressPage() {
  const { data: session } = useSession();
  const [stats, setStats] = useState<any>(null);
  const [subjectsProgress, setSubjectsProgress] = useState<SubjectProgress[]>([]);
  const [recentLessons, setRecentLessons] = useState<RecentLesson[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchProgress = async () => {
      try {
        setIsLoading(true);
        
        // Fetch student stats
        const statsRes = await fetch('/api/students/stats');
        const statsData = await statsRes.json();
        if (statsData.success) {
          setStats(statsData.data.stats);
        }

        // Fetch subjects progress
        const progressRes = await fetch('/api/students/progress');
        const progressData = await progressRes.json();
        if (progressData.success) {
          setSubjectsProgress(progressData.data.subjectsProgress || []);
          setRecentLessons(progressData.data.recentLessons || []);
        }
      } catch (error) {
        console.error('Error fetching progress:', error);
      } finally {
        setIsLoading(false);
      }
    };

    if (session?.user) {
      fetchProgress();
    }
  }, [session]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  const completedLessonsCount = stats?.completedLessons || 0;
  const solvedExercisesCount = stats?.totalSubmissions || 0;
  const averageScore = stats?.averageScore || 0;

  return (
    <div className="flex flex-col gap-8">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">ØªÙ‚Ø¯Ù…ÙŠ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ</h1>
        <p className="text-muted-foreground">
          ØªØ§Ø¨Ø¹ Ø¥Ù†Ø¬Ø§Ø²Ø§ØªÙƒ ÙˆØ£Ø¯Ø§Ø¦Ùƒ ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©.
        </p>
      </div>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©</CardTitle>
            <BookCheck className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{completedLessonsCount}</div>
            <p className="text-xs text-muted-foreground">Ø¯Ø±Ø³ Ù…ÙƒØªÙ…Ù„</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙˆÙ„Ø©</CardTitle>
            <ClipboardList className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{solvedExercisesCount}</div>
            <p className="text-xs text-muted-foreground">ØªÙ… Ø­Ù„Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª</CardTitle>
            <Target className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{averageScore}%</div>
            <p className="text-xs text-muted-foreground">ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</p>
          </CardContent>
        </Card>
      </div>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-5">
        <Card className="lg:col-span-3">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <TrendingUp className="text-primary" />
              <span>Ø£Ø¯Ø§Ø¦ÙŠ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø§Ø¯Ø©</span>
            </CardTitle>
            <CardDescription>
              Ù…ØªÙˆØ³Ø· Ø¯Ø±Ø¬Ø§ØªÙƒ ÙÙŠ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù…Ø®ØªÙ„ÙØ©.
            </CardDescription>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={subjectsProgress} layout="vertical" margin={{ right: 20 }}>
                <XAxis type="number" hide />
                <YAxis
                  dataKey="subject"
                  type="category"
                  tickLine={false}
                  axisLine={false}
                  tick={{ fill: 'hsl(var(--muted-foreground))', fontSize: 12 }}
                  width={80}
                  dx={-5}
                />
                 <Tooltip
                    cursor={{ fill: 'hsl(var(--accent) / 0.2)' }}
                    content={({ active, payload }) => {
                        if (active && payload && payload.length) {
                            return (
                            <div className="rounded-lg border bg-background p-2 shadow-sm">
                                <div className="grid grid-cols-2 gap-2">
                                <div className="flex flex-col">
                                    <span className="text-muted-foreground text-sm">
                                    {payload[0].payload.subject}
                                    </span>
                                    <span className="font-bold text-lg">
                                    {payload[0].value}%
                                    </span>
                                </div>
                                </div>
                            </div>
                            )
                        }
                        return null
                        }}
                 />
                <Bar dataKey="score" radius={[0, 4, 4, 0]} barSize={30}>
                    {subjectsProgress.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={entry.color} />
                    ))}
                </Bar>
              </BarChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
        
        <Card className="lg:col-span-2">
          <CardHeader>
            <CardTitle>Ø¢Ø®Ø± Ø§Ù„Ø¯Ø±ÙˆØ³</CardTitle>
            <CardDescription>Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ Ø¹Ù…Ù„Øª Ø¹Ù„ÙŠÙ‡Ø§ Ù…Ø¤Ø®Ø±Ø§Ù‹.</CardDescription>
          </CardHeader>
          <CardContent>
            {recentLessons.length > 0 ? (
                <Table>
                    <TableHeader>
                        <TableRow>
                            <TableHead>Ø§Ù„Ø¯Ø±Ø³</TableHead>
                            <TableHead>Ø§Ù„ØªÙ‚Ø¯Ù…</TableHead>
                        </TableRow>
                    </TableHeader>
                    <TableBody>
                        {recentLessons.map(lesson => (
                            <TableRow key={lesson.id}>
                                <TableCell className="font-medium">{lesson.title}</TableCell>
                                <TableCell>
                                    <Progress value={lesson.progress} className="h-2" />
                                </TableCell>
                            </TableRow>
                        ))}
                    </TableBody>
                </Table>
            ) : (
                <p className="text-center text-muted-foreground pt-8">Ù„Ù… ØªØ¨Ø¯Ø£ Ø¨Ø£ÙŠ Ø¯Ø±Ø³ Ø¨Ø¹Ø¯.</p>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/my-code/page.tsx
// ==========================================

'use client';

import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";

export const dynamic = 'force-dynamic';
import { getTeacher, getUserById } from "@/lib/mock-data";
import { Input } from "@/components/ui/input";
import { Copy, RefreshCw } from "lucide-react";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
    AlertDialogTrigger,
} from "@/components/ui/alert-dialog"
import { useToast } from "@/hooks/use-toast";

// Mock current user ID. This would come from auth.
const MOCK_TEACHER_ID = 2;

export default function MyCodePage() {
    const { toast } = useToast();
    // This could be a teacher (2) or a supervisor acting as a teacher (7)
    const teacher = getUserById(MOCK_TEACHER_ID); 
    if (!teacher || !teacher.teacher_code) return <div>Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¹Ù„Ù….</div>;

    const handleCopy = () => {
        if(teacher.teacher_code) {
            navigator.clipboard.writeText(teacher.teacher_code);
            toast({
                title: "ØªÙ… Ø§Ù„Ù†Ø³Ø®!",
                description: "ØªÙ… Ù†Ø³Ø® ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©.",
            });
        }
    };

    return (
        <div className="flex flex-col gap-8 max-w-2xl mx-auto">
            <div className="grid gap-1">
                <h1 className="text-3xl font-bold tracking-tight">ÙƒÙˆØ¯ÙŠ Ø§Ù„Ø®Ø§Øµ</h1>
                <p className="text-muted-foreground">
                    Ø¥Ø¯Ø§Ø±Ø© ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ø¹ Ø·Ù„Ø§Ø¨Ùƒ.
                </p>
            </div>

            <Card>
                <CardHeader>
                    <CardTitle>ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ø­Ø§Ù„ÙŠ</CardTitle>
                    <CardDescription>
                        Ø´Ø§Ø±Ùƒ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù…Ø¹ Ø·Ù„Ø§Ø¨Ùƒ Ù„ÙŠØªÙ…ÙƒÙ†ÙˆØ§ Ù…Ù† Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø­Ø³Ø§Ø¨Ùƒ ÙˆØ§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø¯Ø±ÙˆØ³Ùƒ Ø§Ù„Ø®Ø§ØµØ©.
                    </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                    <div className="flex items-center gap-2">
                        <Input readOnly defaultValue={teacher.teacher_code} className="text-2xl font-mono tracking-widest text-center" />
                        <Button variant="outline" size="icon" onClick={handleCopy} aria-label="Ù†Ø³Ø® Ø§Ù„ÙƒÙˆØ¯">
                            <Copy className="h-5 w-5" />
                        </Button>
                    </div>
                    <p className="text-sm text-muted-foreground">
                        ÙŠÙ…ÙƒÙ† Ù„Ù„Ø·Ù„Ø§Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ ÙÙŠ ØµÙØ­Ø© Ù…Ù„ÙÙ‡Ù… Ø§Ù„Ø´Ø®ØµÙŠ Ù„Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ùƒ.
                    </p>
                </CardContent>
            </Card>
            
            <Card className="border-destructive">
                <CardHeader>
                    <CardTitle>Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯</CardTitle>
                    <CardDescription>
                        Ø³ÙŠØ¤Ø¯ÙŠ Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯ Ø¥Ù„Ù‰ Ø¬Ø¹Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø­Ø§Ù„ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­ØŒ ÙˆØ³ÙŠØªÙ… ÙØµÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø­Ø§Ù„ÙŠÙ‹Ø§.
                    </CardDescription>
                </CardHeader>
                <CardContent>
                     <AlertDialog>
                        <AlertDialogTrigger asChild>
                            <Button variant="destructive">
                                <RefreshCw className="ml-2 h-4 w-4" />
                                <span>Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯</span>
                            </Button>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                            <AlertDialogHeader>
                            <AlertDialogTitle>Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ ØªÙ…Ø§Ù…Ø§Ù‹ØŸ</AlertDialogTitle>
                            <AlertDialogDescription>
                                Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù†Ù‡. Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø±Ø¨Ø· Ø¬Ø¯ÙŠØ¯ ÙˆØ³ÙŠØªÙ… ÙØµÙ„ Ø¬Ù…ÙŠØ¹ Ø·Ù„Ø§Ø¨Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠÙŠÙ†. Ø³ÙŠØ­ØªØ§Ø¬ÙˆÙ† Ø¥Ù„Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ùƒ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.
                            </AlertDialogDescription>
                            </AlertDialogHeader>
                            <AlertDialogFooter>
                            <AlertDialogCancel>Ø¥Ù„ØºØ§Ø¡</AlertDialogCancel>
                            <AlertDialogAction>Ù†Ø¹Ù…ØŒ Ù‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯</AlertDialogAction>
                            </AlertDialogFooter>
                        </AlertDialogContent>
                    </AlertDialog>
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/submissions/[id]/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import { notFound } from "next/navigation";
import { useSubmission } from "@/hooks/use-submission";
import { useToast } from "@/hooks/use-toast";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import {
  FileQuestion,
  User,
  CheckCircle,
  MessageSquare,
  FileText,
  Paperclip,
  Save,
  Brain,
  Loader2,
  Sparkles
} from "lucide-react";
import Link from "next/link";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";

export default function ReviewSubmissionPage({ params }: { params: { id: string } }) {
  const { id } = params;
  const { submission, isLoading, error, refetch, updateSubmission } = useSubmission(id);
  const { toast } = useToast();

  const [teacherNotes, setTeacherNotes] = useState<string>("");
  const [finalScore, setFinalScore] = useState<number | null>(null);
  const [isSavingManualGrade, setIsSavingManualGrade] = useState(false);

  const [isEvaluatingAI, setIsEvaluatingAI] = useState(false);
  const [aiEvaluationResult, setAiEvaluationResult] = useState<any | null>(null);

  useEffect(() => {
    if (submission) {
      setTeacherNotes(submission.teacherNotes || "");
      // Prioritize finalScore, then aiScore, then null
      setFinalScore(submission.finalScore ?? submission.aiScore ?? null); 
      if (submission.aiFeedback && submission.aiScore) {
        setAiEvaluationResult({
          score: submission.aiScore,
          feedback: submission.aiFeedback,
          // If detailed strengths/weaknesses are stored, retrieve them here
        });
      }
    }
  }, [submission]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (error) {
    return <div className="text-destructive text-center mt-8">Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©: {error}</div>;
  }

  if (!submission) {
    notFound();
  }

  const exercise = submission.exercise;
  const student = submission.student;

  // Use aiEvaluationResult if available, otherwise submission's stored AI evaluation, otherwise null
  const displayedAiScore = aiEvaluationResult?.score ?? submission.aiScore;
  const displayedAiFeedback = aiEvaluationResult?.feedback ?? submission.aiFeedback;
  const displayedAiStrengths = aiEvaluationResult?.strengths;
  const displayedAiWeaknesses = aiEvaluationResult?.weaknesses;

  const getScoreVariant = (score: number | null) => {
    if (score === null) return 'secondary';
    // Use exercise.maxScore, default to 10 if not available
    const max = exercise?.maxScore || 10;
    if (score >= max * 0.8) return 'default'; // 80% or more
    if (score >= max * 0.5) return 'secondary'; // 50% or more
    return 'destructive'; // Less than 50%
  };

  const handleAutoEvaluate = async () => {
    if (!submission || !exercise || !student) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø£Ùˆ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø£Ùˆ Ø§Ù„Ø·Ø§Ù„Ø¨ ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©.",
        variant: "destructive",
      });
      return;
    }

    if (exercise.type !== 'main') {
      toast({
        title: "ØºÙŠØ± Ù…ØªØ§Ø­",
        description: "Ø§Ù„ØªØµØ­ÙŠØ­ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…ØªØ§Ø­ ÙÙ‚Ø· Ù„Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.",
        variant: "info",
      });
      return;
    }

    if (!exercise.modelAnswer) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ù„ Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ù„ØªØªÙ…ÙƒÙ† AI Ù…Ù† ØªÙ‚ÙŠÙŠÙ…Ù‡.",
        variant: "destructive",
      });
      return;
    }

    if (!submission.answer) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¬Ø§Ø¨Ø© Ù…Ù† Ø§Ù„Ø·Ø§Ù„Ø¨ Ù„ØªÙ‚ÙŠÙŠÙ…Ù‡Ø§ Ø¨ÙˆØ§Ø³Ø·Ø© AI.",
        variant: "destructive",
      });
      return;
    }

    setIsEvaluatingAI(true);
    try {
      const response = await fetch('/api/ai/evaluate-answer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: exercise.questionRichContent,
          modelAnswer: exercise.modelAnswer,
          studentAnswer: submission.answer,
          maxScore: exercise.maxScore || 10, // Default to 10 if not set
          subject: exercise.lesson.subject.name,
          level: exercise.lesson.level.name,
        }),
      });

      const result = await response.json();

      if (response.ok && result.success) {
        setAiEvaluationResult(result.data); // Store AI's full evaluation
        setFinalScore(result.data.score); // Pre-fill final score with AI score

        // Update the submission in the database with AI results
        await updateSubmission({
          aiScore: result.data.score,
          aiFeedback: result.data.feedback,
          // Optionally save strengths/weaknesses if schema supports it
        });

        toast({
          title: "ØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ù†Ø¬Ø§Ø­",
          description: "ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ.",
        });
      } else {
        throw new Error(result.error || "ÙØ´Ù„ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨ÙˆØ§Ø³Ø·Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ");
      }
    } catch (err: any) {
      toast({
        title: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
        description: err.message,
        variant: "destructive",
      });
    } finally {
      setIsEvaluatingAI(false);
    }
  };

  const handleSaveManualGrade = async () => {
    if (!submission) return;

    setIsSavingManualGrade(true);
    try {
      const { success, error: updateError } = await updateSubmission({
        finalScore: finalScore,
        teacherNotes: teacherNotes,
        gradedAt: new Date().toISOString(),
        gradedById: submission.gradedById, // Assuming the current user ID is handled on the API
      });

      if (success) {
        toast({
          title: "ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­",
          description: "ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¯Ø±Ø¬Ø© ÙˆØ§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª.",
        });
        refetch(); // Refetch to get the latest state including gradedById if it's set by API
      } else {
        throw new Error(updateError || "ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ÙŠØ¯ÙˆÙŠ.");
      }
    } catch (err: any) {
      toast({
        title: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­ÙØ¸",
        description: err.message,
        variant: "destructive",
      });
    } finally {
      setIsSavingManualGrade(false);
    }
  };

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨</h1>
        <p className="text-muted-foreground">
          Ù…Ø±Ø§Ø¬Ø¹Ø© Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ "{student.name}" Ø¹Ù„Ù‰ ØªÙ…Ø±ÙŠÙ† "{exercise.questionRichContent}".
        </p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div className="lg:col-span-2 space-y-8">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2"><FileQuestion /> <span>Ø§Ù„ØªÙ…Ø±ÙŠÙ†</span></CardTitle>
            </CardHeader>
            <CardContent>
              <div dangerouslySetInnerHTML={{ __html: exercise.questionRichContent }} className="text-lg font-medium mb-2" />
              {/* <p className="text-lg font-medium">{exercise.questionRichContent}</p> */}
              {/* exercise.question_file_url should be exercise.fileUrl in the new schema */}
              {/* {exercise.fileUrl && (
                <div className="pt-4">
                  <Link href={exercise.fileUrl} target="_blank" passHref>
                    <Button variant="outline">
                      <Paperclip className="ml-2 h-4 w-4" />
                      <span>Ø¹Ø±Ø¶ Ù…Ù„Ù Ø§Ù„Ø³Ø¤Ø§Ù„</span>
                    </Button>
                  </Link>
                </div>
              )} */}
              <Separator className="my-4" />
              <Label className="text-sm text-muted-foreground">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©:</Label>
              {exercise.modelAnswer ? (
                 <div dangerouslySetInnerHTML={{ __html: exercise.modelAnswer }} className="text-sm" />
              ) : (
                <p className="text-sm text-muted-foreground">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ù„ Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù„Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ†.</p>
              )}
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2"><FileText /> <span>Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨</span></CardTitle>
            </CardHeader>
            <CardContent>
              {submission.answer ? (
                <div dangerouslySetInnerHTML={{ __html: submission.answer }} className="mb-4 p-4 bg-muted rounded-md" />
              ) : (
                <p className="text-muted-foreground">Ù„Ù… ÙŠÙ‚Ø¯Ù… Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¥Ø¬Ø§Ø¨Ø© Ù†ØµÙŠØ©.</p>
              )}
              {submission.fileUrl && ( // submission.fileUrl
                <Link href={submission.fileUrl} target="_blank" passHref>
                  <Button variant="secondary">
                    <Paperclip className="ml-2 h-4 w-4" />
                    <span>ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø±ÙÙ‚ Ù…Ù† Ø§Ù„Ø·Ø§Ù„Ø¨</span>
                  </Button>
                </Link>
              )}
              {!submission.answer && !submission.fileUrl && (
                <p className="text-muted-foreground">Ù„Ù… ÙŠÙ‚Ø¯Ù… Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¥Ø¬Ø§Ø¨Ø© Ù†ØµÙŠØ© Ø£Ùˆ Ù…Ù„Ù.</p>
              )}
            </CardContent>
          </Card>
        </div>

        <div className="lg:col-span-1 space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2"><User /><span>Ø§Ù„Ø·Ø§Ù„Ø¨</span></CardTitle>
            </CardHeader>
            <CardContent className="flex items-center gap-3">
              <Avatar>
                <AvatarImage src={student.image || ""} alt={student.name} /> {/* student.image */}
                <AvatarFallback>{student.name.charAt(0)}</AvatarFallback>
              </Avatar>
              <div>
                <p className="font-semibold">{student.name}</p>
                <p className="text-sm text-muted-foreground">{student.email}</p>
              </div>
            </CardContent>
          </Card>

          {exercise.type === 'main' && (
            <Card>
              <CardHeader className="flex flex-row items-center justify-between space-y-0">
                <CardTitle className="flex items-center gap-2"><MessageSquare /><span>ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</span></CardTitle>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={handleAutoEvaluate}
                  disabled={isEvaluatingAI || !exercise.modelAnswer || !submission.answer}
                  className="shrink-0"
                >
                  {isEvaluatingAI ? (
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                  ) : (
                    <Brain className="ml-2 h-4 w-4" />
                  )}
                  ØªÙ‚ÙŠÙŠÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠ
                </Button>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <Label>Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø© Ù…Ù† AI</Label>
                  <Badge variant={getScoreVariant(displayedAiScore)} className="block w-fit text-lg mt-1">
                    {displayedAiScore !== null ? `${displayedAiScore} / ${exercise.maxScore || 10}` : 'N/A'}
                  </Badge>
                </div>
                <div>
                  <Label>Ù…Ù„Ø§Ø­Ø¸Ø§Øª AI</Label>
                  <div className="mt-1 text-sm text-muted-foreground">
                    {displayedAiFeedback ? (
                      <div dangerouslySetInnerHTML={{ __html: displayedAiFeedback }} />
                    ) : (
                      "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ."
                    )}
                  </div>
                </div>
                {displayedAiStrengths && displayedAiStrengths.length > 0 && (
                  <div>
                    <Label>Ù†Ù‚Ø§Ø· Ø§Ù„Ù‚ÙˆØ© (AI)</Label>
                    <ul className="list-disc pl-5 mt-1 text-sm text-muted-foreground">
                      {displayedAiStrengths.map((s: string, i: number) => <li key={i}>{s}</li>)}
                    </ul>
                  </div>
                )}
                {displayedAiWeaknesses && displayedAiWeaknesses.length > 0 && (
                  <div>
                    <Label>Ù†Ù‚Ø§Ø· Ø§Ù„Ø¶Ø¹Ù (AI)</Label>
                    <ul className="list-disc pl-5 mt-1 text-sm text-muted-foreground">
                      {displayedAiWeaknesses.map((w: string, i: number) => <li key={i}>{w}</li>)}
                    </ul>
                  </div>
                )}
              </CardContent>
            </Card>
          )}

          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2"><CheckCircle /><span>Ø§Ù„ØªØµØ­ÙŠØ­ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ</span></CardTitle>
              <CardDescription>ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø¬Ø© ÙˆØ¥Ø¶Ø§ÙØ© Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ Ø§Ù„Ø®Ø§ØµØ©.</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="final-score">Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© (Ù…Ù† {exercise.maxScore || 10})</Label>
                <Input
                  id="final-score"
                  type="number"
                  defaultValue={finalScore ?? undefined}
                  value={finalScore ?? ''}
                  onChange={(e) => setFinalScore(e.target.value === '' ? null : parseFloat(e.target.value))}
                  min="0"
                  max={exercise.maxScore || 10}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="teacher-notes">Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù…</Label>
                <Textarea
                  id="teacher-notes"
                  placeholder="Ø§ÙƒØªØ¨ Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ Ù„Ù„Ø·Ø§Ù„Ø¨ Ù‡Ù†Ø§..."
                  rows={4}
                  value={teacherNotes}
                  onChange={(e) => setTeacherNotes(e.target.value)}
                />
              </div>
              <Button className="w-full" onClick={handleSaveManualGrade} disabled={isSavingManualGrade}>
                {isSavingManualGrade ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸...
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    Ø­ÙØ¸ Ø§Ù„ØªØµØ­ÙŠØ­
                  </>
                )}
              </Button>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/submissions/page.tsx
// ==========================================


'use client';

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { getSubmissionsForTeacher, getUserById, getExerciseById } from "@/lib/mock-data";
import { Eye, Clock } from "lucide-react";
import Link from "next/link";
import { formatDistanceToNow } from "date-fns";
import { ar } from "date-fns/locale";

// Mock current teacher ID
const MOCK_TEACHER_ID = 2;

export default function SubmissionsPage() {
    const submissions = getSubmissionsForTeacher(MOCK_TEACHER_ID);
    const pendingSubmissions = submissions.filter(s => s.status === 'pending');

    const getScoreVariant = (score: number) => {
        if (score >= 8) return 'default';
        if (score >= 5) return 'secondary';
        return 'destructive';
    }

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center gap-2">
                <h1 className="text-3xl font-bold tracking-tight">ØªØµØ­ÙŠØ­ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</h1>
                <Badge variant="destructive" className="flex gap-1">
                    <Clock className="h-4 w-4"/>
                    {pendingSubmissions.length} Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©
                </Badge>
            </div>

             <Card>
                <CardHeader>
                    <CardTitle>Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø©</CardTitle>
                    <CardDescription>
                       Ù…Ø±Ø§Ø¬Ø¹Ø© ÙˆØªØµØ­ÙŠØ­ Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†.
                    </CardDescription>
                </CardHeader>
                <CardContent>
                    <Table>
                        <TableHeader>
                            <TableRow>
                                <TableHead>Ø§Ù„Ø·Ø§Ù„Ø¨</TableHead>
                                <TableHead>Ø§Ù„ØªÙ…Ø±ÙŠÙ†</TableHead>
                                <TableHead>Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£ÙˆÙ„ÙŠ (AI)</TableHead>
                                <TableHead>ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ø±Ø³Ø§Ù„</TableHead>
                                <TableHead className="text-left">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                        {pendingSubmissions.length > 0 ? (
                            pendingSubmissions.map(submission => {
                                const student = getUserById(submission.student_id);
                                const exercise = getExerciseById(submission.exercise_id);
                                if (!student || !exercise) return null;

                                return (
                                <TableRow key={submission.id}>
                                    <TableCell className="font-medium">{student.name}</TableCell>
                                    <TableCell className="max-w-xs truncate">{exercise.question}</TableCell>
                                    <TableCell>
                                        <Badge variant={getScoreVariant(submission.score ?? 0)}>
                                            {submission.score ?? 'N/A'}/10
                                        </Badge>
                                    </TableCell>
                                    <TableCell>
                                        {formatDistanceToNow(new Date(submission.submitted_at), { addSuffix: true, locale: ar })}
                                    </TableCell>
                                    <TableCell className="text-left">
                                        <Link href={`/dashboard/teacher/submissions/${submission.id}`} passHref>
                                            <Button variant="outline" size="sm">
                                                <Eye className="ml-2 h-4 w-4" />
                                                Ù…Ø±Ø§Ø¬Ø¹Ø©
                                            </Button>
                                        </Link>
                                    </TableCell>
                                </TableRow>
                                )
                            })
                        ) : (
                             <TableRow>
                                <TableCell colSpan={5} className="text-center h-24">
                                    Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø¬Ø§Ø¨Ø§Øª Ø¨Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªØµØ­ÙŠØ­ Ø­Ø§Ù„ÙŠØ§Ù‹.
                                </TableCell>
                            </TableRow>
                        )}
                        </TableBody>
                    </Table>
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/_components/SubjectSupervisorDashboard.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import {
    Card,
    CardContent,
    CardDescription,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { BookCopy, FileQuestion, PlusCircle, Eye, Loader2, Users } from "lucide-react";
import Link from "next/link";
import { formatDistanceToNow } from "date-fns";
import { ar } from "date-fns/locale";

interface DashboardData {
  supervisor: {
    id: string;
    name: string;
    email: string;
    subject: {
      id: number;
      name: string;
    };
    level: {
      id: number;
      name: string;
      stage: {
        id: number;
        name: string;
      };
    };
    allowMessaging: boolean;
    teacherCode: string | null;
  };
  stats: {
    lessons: number;
    exercises: number;
    teachers: number;
    students: number;
  };
  recentLessons: Array<{
    id: string;
    title: string;
    description: string | null;
    isPublic: boolean;
    levelName: string | null;
    stageName: string | null;
    exercisesCount: number;
    createdAt: string;
  }>;
}

export default function SubjectSupervisorDashboard() {
    const [data, setData] = useState<DashboardData | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchData = async () => {
            try {
                const response = await fetch('/api/subject-supervisor/dashboard');
                const result = await response.json();

                if (result.success) {
                    setData(result.data);
                } else {
                    setError(result.error || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
                }
            } catch (err) {
                setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, []);

    if (loading) {
        return (
            <div className="flex items-center justify-center min-h-[400px]">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
        );
    }

    if (error || !data) {
        return (
            <div className="flex items-center justify-center min-h-[400px]">
                <div className="text-center">
                    <p className="text-lg text-muted-foreground">{error || 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ Ø§Ù„Ù…Ø§Ø¯Ø©'}</p>
                </div>
            </div>
        );
    }

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">
                        Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… Ù…Ø´Ø±Ù Ù…Ø§Ø¯Ø© "{data.supervisor.subject.name}"
                    </h1>
                    <p className="text-muted-foreground">
                        Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨ÙƒØŒ {data.supervisor.name}! Ù…Ø´Ø±Ù {data.supervisor.level.name} - {data.supervisor.level.stage.name}
                    </p>
                </div>
                 <Link href="/dashboard/subject-supervisor/lessons/create" passHref>
                    <Button>
                        <PlusCircle className="ml-2 h-4 w-4" />
                        <span>Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¹Ø§Ù… Ø¬Ø¯ÙŠØ¯</span>
                    </Button>
                </Link>
            </div>

            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³</CardTitle>
                        <BookCopy className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{data.stats.lessons}</div>
                        <p className="text-xs text-muted-foreground">Ø¯Ø±ÙˆØ³ Ù‚Ù…Øª Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§</p>
                    </CardContent>
                </Card>
                 <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</CardTitle>
                        <FileQuestion className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{data.stats.exercises}</div>
                        <p className="text-xs text-muted-foreground">ÙÙŠ Ø¯Ø±ÙˆØ³Ùƒ</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ù…Ø¹Ù„Ù…ÙˆÙ†</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{data.stats.teachers}</div>
                        <p className="text-xs text-muted-foreground">ÙŠØ¯Ø±Ù‘Ø³ÙˆÙ† Ø§Ù„Ù…Ø§Ø¯Ø©</p>
                    </CardContent>
                </Card>
                <Card>
                    <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <CardTitle className="text-sm font-medium">Ø§Ù„Ø·Ù„Ø§Ø¨</CardTitle>
                        <Users className="h-4 w-4 text-muted-foreground" />
                    </CardHeader>
                    <CardContent>
                        <div className="text-2xl font-bold">{data.stats.students}</div>
                        <p className="text-xs text-muted-foreground">ÙŠØ¯Ø±Ø³ÙˆÙ† Ø§Ù„Ù…Ø§Ø¯Ø©</p>
                    </CardContent>
                </Card>
            </div>
            
            <Card>
                <CardHeader>
                    <div className="flex justify-between items-center">
                        <div>
                            <CardTitle>Ø£Ø­Ø¯Ø« Ø§Ù„Ø¯Ø±ÙˆØ³</CardTitle>
                            <CardDescription>Ù‡Ø°Ù‡ Ù‡ÙŠ Ø£Ø­Ø¯Ø« Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø¥Ø¶Ø§ÙØªÙ‡Ø§</CardDescription>
                        </div>
                        <Link href="/dashboard/subject-supervisor/lessons">
                            <Button variant="outline" size="sm">
                                Ø¹Ø±Ø¶ Ø§Ù„ÙƒÙ„
                            </Button>
                        </Link>
                    </div>
                </CardHeader>
                <CardContent>
                    <Table>
                        <TableHeader>
                            <TableRow>
                                <TableHead>Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³</TableHead>
                                <TableHead>Ø§Ù„Ù…Ø³ØªÙˆÙ‰</TableHead>
                                <TableHead>Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</TableHead>
                                <TableHead>Ø§Ù„Ù†ÙˆØ¹</TableHead>
                                <TableHead className="text-center">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</TableHead>
                            </TableRow>
                        </TableHeader>
                        <TableBody>
                        {data.recentLessons.length > 0 ? (
                            data.recentLessons.map(lesson => (
                                <TableRow key={lesson.id}>
                                    <TableCell className="font-medium">{lesson.title}</TableCell>
                                    <TableCell>
                                        {lesson.levelName && lesson.stageName 
                                            ? `${lesson.stageName} - ${lesson.levelName}`
                                            : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'
                                        }
                                    </TableCell>
                                    <TableCell>{lesson.exercisesCount}</TableCell>
                                    <TableCell>
                                        <Badge variant={lesson.isPublic ? "default" : "outline"}>
                                            {lesson.isPublic ? 'Ø¹Ø§Ù…' : 'Ø®Ø§Øµ'}
                                        </Badge>
                                    </TableCell>
                                    <TableCell className="text-center">
                                        <Link href={`/lessons/${lesson.id}`}>
                                            <Button variant="ghost" size="sm">
                                                <Eye className="ml-2 h-4 w-4" />
                                                Ù…Ø¹Ø§ÙŠÙ†Ø©
                                            </Button>
                                        </Link>
                                    </TableCell>
                                </TableRow>
                            ))
                        ) : (
                            <TableRow>
                                <TableCell colSpan={5} className="text-center h-24">
                                    Ù„Ù… ØªÙ‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠ Ø¯Ø±ÙˆØ³ Ø¨Ø¹Ø¯.
                                </TableCell>
                            </TableRow>
                        )}
                        </TableBody>
                    </Table>
                </CardContent>
            </Card>
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/page.tsx
// ==========================================

'use client';

import SubjectSupervisorDashboard from "./_components/SubjectSupervisorDashboard";

export const dynamic = 'force-dynamic';

export default function SubjectSupervisorDashboardPage() {
    return <SubjectSupervisorDashboard />
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/statistics/page.tsx
// ==========================================


'use client';

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  BarChart,
  BookCopy,
  FileQuestion,
  Users,
  Loader2,
} from "lucide-react";
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip, Legend } from 'recharts';

interface StatisticsData {
  supervisor: {
    id: string;
    name: string;
    email: string;
    subject: {
      id: number;
      name: string;
    };
    level: {
      id: number;
      name: string;
      stage: {
        id: number;
        name: string;
      };
    };
  };
  stats: {
    lessons: number;
    exercises: number;
    teachers: number;
    students: number;
  };
  topTeachers: Array<{
    id: string;
    name: string;
    email: string;
    image: string | null;
    lessonCount: number;
  }>;
}

export default function StatisticsPage() {
  const [data, setData] = useState<StatisticsData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStatistics = async () => {
      try {
        const response = await fetch('/api/subject-supervisor/statistics');
        const result = await response.json();

        if (result.success) {
          setData(result.data);
        } else {
          setError(result.error || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
        }
      } catch (err) {
        setError('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª');
        console.error('Error fetching statistics:', err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchStatistics();
  }, []);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (error || !data) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <div className="text-center">
          <p className="text-lg text-muted-foreground">{error || 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª'}</p>
        </div>
      </div>
    );
  }

  const lessonTypeData = [
    { name: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³', value: data.stats.lessons, color: 'hsl(var(--chart-1))' },
    { name: 'Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†', value: data.stats.exercises, color: 'hsl(var(--chart-2))' },
  ];


  return (
    <div className="flex flex-col gap-8">
       <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight flex items-center gap-2">
            <BarChart className="h-7 w-7 text-primary" />
            <span>Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ø§Ø¯Ø© "{data.supervisor.subject.name}"</span>
        </h1>
        <p className="text-muted-foreground">
          {data.supervisor.level.name} - {data.supervisor.level.stage.name} | Ù†Ø¸Ø±Ø© Ø´Ø§Ù…Ù„Ø© Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ ÙˆÙ†Ø´Ø§Ø· Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ† ÙˆØ§Ù„Ø·Ù„Ø§Ø¨.
        </p>
      </div>

       <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³</CardTitle>
            <BookCopy className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{data.stats.lessons}</div>
            <p className="text-xs text-muted-foreground">ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø§Ø¯Ø©</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</CardTitle>
            <FileQuestion className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{data.stats.exercises}</div>
            <p className="text-xs text-muted-foreground">ØªÙ… Ø¥Ù†Ø´Ø§Ø¤Ù‡Ø§ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø§Ø¯Ø©</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ†</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{data.stats.teachers}</div>
            <p className="text-xs text-muted-foreground">ÙŠØ¯Ø±Ø³ÙˆÙ† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø§Ø¯Ø©</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø§Ø¨</CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{data.stats.students}</div>
            <p className="text-xs text-muted-foreground">ÙŠØ¯Ø±Ø³ÙˆÙ† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø§Ø¯Ø©</p>
          </CardContent>
        </Card>
      </div>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹</CardTitle>
            <CardDescription>
                Ø§Ù„Ù†Ø³Ø¨Ø© Ø¨ÙŠÙ† Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ø¹Ø§Ù…Ø© ÙˆØ§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ø®Ø§ØµØ©.
            </CardDescription>
          </CardHeader>
          <CardContent>
             <ResponsiveContainer width="100%" height={300}>
              <PieChart>
                <Pie data={lessonTypeData} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={100} label>
                  {lessonTypeData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={entry.color} />
                  ))}
                </Pie>
                <Tooltip />
                <Legend />
              </PieChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
         <Card>
          <CardHeader>
            <CardTitle>Ø§Ù„Ù†Ø´Ø§Ø· Ø§Ù„Ø´Ù‡Ø±ÙŠ</CardTitle>
             <CardDescription>
                (Ù…ÙŠØ²Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±)
            </CardDescription>
          </CardHeader>
          <CardContent className="flex items-center justify-center text-muted-foreground h-[300px]">
            <p>Ø³ÙŠØªÙ… Ø¹Ø±Ø¶ Ù…Ø®Ø·Ø· Ø§Ù„Ù†Ø´Ø§Ø· Ø§Ù„Ø´Ù‡Ø±ÙŠ Ù‡Ù†Ø§ Ù‚Ø±ÙŠØ¨Ø§Ù‹.</p>
          </CardContent>
        </Card>
      </div>

       <Card>
        <CardHeader>
          <CardTitle>Ø£ÙØ¶Ù„ Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ† Ø£Ø¯Ø§Ø¡Ù‹</CardTitle>
          <CardDescription>Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ† Ø§Ù„Ø£ÙƒØ«Ø± Ù†Ø´Ø§Ø·Ø§Ù‹ ÙÙŠ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¯Ø±ÙˆØ³.</CardDescription>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Ø§Ù„Ù…Ø¹Ù„Ù…</TableHead>
                <TableHead>Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³</TableHead>
                <TableHead>Ø¯Ø±ÙˆØ³ Ø¹Ø§Ù…Ø©</TableHead>
                <TableHead>Ø¯Ø±ÙˆØ³ Ø®Ø§ØµØ©</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.topTeachers.length > 0 ? data.topTeachers.map(teacher => (
                <TableRow key={teacher.id}>
                    <TableCell>
                        <div className="flex items-center gap-3">
                            <Avatar>
                                <AvatarImage src={teacher.image || undefined} alt={teacher.name} />
                                <AvatarFallback>{teacher.name.charAt(0)}</AvatarFallback>
                            </Avatar>
                            <span className="font-medium">{teacher.name}</span>
                        </div>
                    </TableCell>
                    <TableCell className="font-bold">{teacher.lessonCount}</TableCell>
                    <TableCell>-</TableCell>
                    <TableCell>-</TableCell>
                </TableRow>
              )) : (
                 <TableRow>
                    <TableCell colSpan={4} className="h-24 text-center">
                      Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ù„Ù…ÙˆÙ† ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ø¹Ø¯.
                    </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/lessons/[id]/edit/page.tsx
// ==========================================


'use client';

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Save, Loader2, Paperclip } from "lucide-react";
import { notFound, useRouter } from "next/navigation";
import { Switch } from "@/components/ui/switch";
import { useToast } from "@/hooks/use-toast";
import { RichTextEditor } from "@/components/editor";
import { FileUpload } from "@/components/FileUpload";

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Google Drive Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¥Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· Proxy
const getProxiedUrl = (url: string) => {
  if (!url) return "";
  // Ø¥Ø¶Ø§ÙØ© Ù„Ø§Ø­Ù‚Ø© ÙˆÙ‡Ù…ÙŠØ© Ù„Ù„ØµÙˆØ±Ø© Ù„ÙƒÙŠ ÙŠØªØ¹Ø±Ù Ø¹Ù„ÙŠÙ‡Ø§ Ù…ÙƒÙˆÙ† FileUpload ÙˆØ§Ù„Ù…ØªØµÙØ­ ÙƒØµÙˆØ±Ø©
  const suffix = "&t=image.jpg";
  if (url.startsWith('/api/images/proxy')) return url.includes(suffix) ? url : `${url}${suffix}`;
  
  const idMatch = url.match(/id=([a-zA-Z0-9_-]+)/) || url.match(/\/d\/([a-zA-Z0-9_-]+)/);
  if ((url.includes('drive.google.com') || url.includes('googleusercontent.com')) && idMatch && idMatch[1]) {
    return `/api/images/proxy?fileId=${idMatch[1]}${suffix}`;
  }
  
  return url;
};

interface Lesson {
  id: string;
  title: string;
  content: string;
  videoUrl: string | null;
  type: 'public' | 'private';
  subject: { id: number; name: string };
  level: { id: number; name: string };
}

export default function EditSupervisorLessonPage({ params }: { params: Promise<{ id: string }> }) {
  const { toast } = useToast();
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [lesson, setLesson] = useState<Lesson | null>(null);
  const [lessonId, setLessonId] = useState<string>('');
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    videoUrl: '',
    imageUrl: '',
    pdfBase64: '',
    pdfUrl: '',
    isPublic: false,
  });

  const [showImageUpload, setShowImageUpload] = useState(false);
  const [showPdfUpload, setShowPdfUpload] = useState(false);
  const [showPptUpload, setShowPptUpload] = useState(false);
  const [isFileUploading, setIsFileUploading] = useState(false);

  useEffect(() => {
    const fetchLesson = async () => {
      const resolvedParams = await params;
      setLessonId(resolvedParams.id);
      
      try {
        const response = await fetch(`/api/lessons/${resolvedParams.id}`);
        const result = await response.json();
        
        if (result.success && result.data) {
          setLesson(result.data);
          setFormData({
            title: result.data.title,
            content: result.data.content || '',
            videoUrl: result.data.videoUrl || '',
            imageUrl: getProxiedUrl(result.data.imageUrl || ''),
            pdfBase64: result.data.pdfUrl || '',
            pdfUrl: result.data.pdfUrl || '',
            isPublic: result.data.type === 'public',
          });

          if (result.data.imageUrl) setShowImageUpload(true);
          if (result.data.pdfUrl) setShowPdfUpload(true);
        } else {
          notFound();
        }
      } catch (error) {
        console.error('Error fetching lesson:', error);
        notFound();
      } finally {
        setLoading(false);
      }
    };

    fetchLesson();
  }, [params]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validation
    if (!formData.title.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
      return;
    }

    if (!formData.content.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
      return;
    }

    setSubmitting(true);

    try {
      const payload: any = {
        title: formData.title.trim(),
        content: formData.content,
        videoUrl: formData.videoUrl?.trim() || null,
        imageUrl: formData.imageUrl?.trim() || null, // Ø³ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯
        pdfUrl: formData.pdfUrl?.trim() || null,
        type: formData.isPublic ? 'public' : 'private',
      };

      console.log('Sending payload size:', JSON.stringify(payload).length, 'bytes');

      const response = await fetch(`/api/lessons/${lessonId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Server error:', errorText);
        throw new Error(`ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø­ÙØ¸: ${response.status}`);
      }

      const result = await response.json();

      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«',
          description: 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­',
        });
        router.push('/dashboard/subject-supervisor/lessons');
      } else {
        throw new Error(result.error);
      }
    } catch (error: any) {
      console.error('Submit error:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯Ø±Ø³. Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ±Ø§Ù‹ Ø¬Ø¯Ø§Ù‹',
        variant: 'destructive',
      });
    } finally {
      setSubmitting(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!lesson) {
    notFound();
  }

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³: {lesson.title}</h1>
        <p className="text-muted-foreground">
          Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³</CardTitle>
          <CardDescription>
            {lesson.subject.name} - {lesson.level.name}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="title">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <Input 
                id="title" 
                placeholder="Ù…Ø«Ø§Ù„: Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¬Ø¨Ø±" 
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                required
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <Label htmlFor="subject">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                <Input 
                  id="subject" 
                  value={lesson.subject.name} 
                  readOnly 
                  disabled 
                  className="bg-muted"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</Label>
                <Input 
                  id="level" 
                  value={lesson.level.name} 
                  readOnly 
                  disabled 
                  className="bg-muted"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="content">Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <RichTextEditor 
                content={formData.content}
                onChange={(content) => setFormData({ ...formData, content })}
                placeholder="Ø§ÙƒØªØ¨ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ Ù‡Ù†Ø§..."
              />
              <p className="text-xs text-muted-foreground">
                Ø§Ø³ØªØ®Ø¯Ù… Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ©
              </p>
            </div>

            <div className="flex items-center space-x-2 space-x-reverse">
              <Switch 
                id="lesson-type" 
                checked={formData.isPublic}
                onCheckedChange={(checked) => setFormData({ ...formData, isPublic: checked })}
              />
              <Label htmlFor="lesson-type">Ø¬Ø¹Ù„Ù‡ Ø¯Ø±Ø³Ù‹Ø§ Ø¹Ø§Ù…Ù‹Ø§ (Ù…ØªØ§Ø­ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªÙˆÙ‰)</Label>
            </div>

            {/* Ù‚Ø³Ù… Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª ÙˆØ§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†Ø³Ø¯Ù„Ø© */}
            <div className="space-y-4 border rounded-lg p-4 bg-muted/20">
              <div className="flex items-center justify-between">
                <Label className="text-base font-semibold flex items-center gap-2">
                  <Paperclip className="w-4 h-4" />
                  Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª
                </Label>
                
                <Select 
                  disabled={isFileUploading || submitting} 
                  onValueChange={(value) => {
                    if (value === 'image') setShowImageUpload(true);
                    if (value === 'pdf') setShowPdfUpload(true);
                    if (value === 'ppt') setShowPptUpload(true);
                  }}
                >
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="Ø¥Ø¶Ø§ÙØ© Ù…Ø±ÙÙ‚..." />
                  </SelectTrigger>
                  <SelectContent>
                    {!showImageUpload && <SelectItem value="image">ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³</SelectItem>}
                    {!showPdfUpload && <SelectItem value="pdf">Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)</SelectItem>}
                    {!showPptUpload && <SelectItem value="ppt" disabled>Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint) - Ù‚Ø±ÙŠØ¨Ø§Ù‹</SelectItem>}
                    <SelectItem value="video" disabled>ÙÙŠØ¯ÙŠÙˆ (Ù‚Ø±ÙŠØ¨Ø§Ù‹)</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="video-url">Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (ÙŠÙˆØªÙŠÙˆØ¨)</Label>
                  <Input 
                    id="video-url" 
                    placeholder="https://www.youtube.com/watch?v=..." 
                    value={formData.videoUrl}
                    onChange={(e) => setFormData({ ...formData, videoUrl: e.target.value })}
                    disabled={submitting}
                  />
                </div>

                {showImageUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³"
                      accept="image/*"
                      maxSizeMB={5}
                      value={formData.imageUrl}
                      onChange={(fileInfo) => {
                        setFormData({ ...formData, imageUrl: getProxiedUrl(fileInfo?.fileUrl || "") });
                      }}
                      onUploadStatusChange={setIsFileUploading}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù Ù„Ù„Ø¯Ø±Ø³ (JPG, PNG, GIF, Ø­ØªÙ‰ 5 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={lesson.level.name} // Using level name as stage info is nested or implied
                      subject={lesson.subject.name}
                      teacher="Supervisor"
                      lesson={formData.title}
                    />
                  </div>
                )}

                {showPdfUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)"
                      accept=".pdf"
                      maxSizeMB={10}
                      value={formData.pdfUrl}
                      onChange={(fileInfo) => setFormData({ ...formData, pdfUrl: fileInfo?.fileUrl || "" })}
                      onUploadStatusChange={setIsFileUploading}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù PDF Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={lesson.level.name}
                      subject={lesson.subject.name}
                      teacher="Supervisor"
                      lesson={formData.title}
                    />
                  </div>
                )}
              </div>
            </div>

            <div className="flex justify-end gap-2">
              <Button 
                variant="outline" 
                type="button"
                onClick={() => router.back()}
                disabled={submitting || isFileUploading}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
              <Button type="submit" disabled={submitting || isFileUploading}>
                {submitting || isFileUploading ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    <span>{isFileUploading ? "Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª..." : "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸..."}</span>
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    <span>Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª</span>
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/lessons/create/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Save, Loader2, Paperclip } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { useRouter } from "next/navigation";
import { RichTextEditor } from "@/components/editor";
import { FileUpload } from "@/components/FileUpload";

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Google Drive Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø£Ùˆ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø© Ø¥Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· Proxy
const getProxiedUrl = (url: string) => {
  if (!url) return "";
  // Ø¥Ø¶Ø§ÙØ© Ù„Ø§Ø­Ù‚Ø© ÙˆÙ‡Ù…ÙŠØ© Ù„Ù„ØµÙˆØ±Ø© Ù„ÙƒÙŠ ÙŠØªØ¹Ø±Ù Ø¹Ù„ÙŠÙ‡Ø§ Ù…ÙƒÙˆÙ† FileUpload ÙˆØ§Ù„Ù…ØªØµÙØ­ ÙƒØµÙˆØ±Ø©
  const suffix = "&t=image.jpg";
  if (url.startsWith('/api/images/proxy')) return url.includes(suffix) ? url : `${url}${suffix}`;
  
  const idMatch = url.match(/id=([a-zA-Z0-9_-]+)/) || url.match(/\/d\/([a-zA-Z0-9_-]+)/);
  if ((url.includes('drive.google.com') || url.includes('googleusercontent.com')) && idMatch && idMatch[1]) {
    return `/api/images/proxy?fileId=${idMatch[1]}${suffix}`;
  }
  
  return url;
};

interface SupervisorInfo {
  subject: { id: number; name: string };
  level: { id: number; name: string; stage: { name: string } };
}

export default function CreateLessonPage() {
  const { toast } = useToast();
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [supervisorInfo, setSupervisorInfo] = useState<SupervisorInfo | null>(null);
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    videoUrl: '',
    imageUrl: '',
    pdfUrl: '',
    isPublic: false,
  });

  // Ø­Ø§Ù„Ø§Øª Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø¸Ù‡ÙˆØ± Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ø±ÙØ¹
  const [showImageUpload, setShowImageUpload] = useState(false);
  const [showPdfUpload, setShowPdfUpload] = useState(false);
  const [showPptUpload, setShowPptUpload] = useState(false);
  const [isFileUploading, setIsFileUploading] = useState(false);

  useEffect(() => {
    const fetchSupervisorInfo = async () => {
      try {
        const response = await fetch('/api/subject-supervisor/dashboard');
        const result = await response.json();
        
        console.log('Supervisor API Response:', result);
        
        if (result.success && result.data?.supervisor) {
          const { subject, level } = result.data.supervisor;
          
          if (!subject || !level) {
            toast({
              title: 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
              description: 'ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¯ÙŠØ± Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ',
              variant: 'destructive',
            });
            return;
          }
          
          setSupervisorInfo({
            subject,
            level,
          });
        } else {
          toast({
            title: 'Ø®Ø·Ø£',
            description: result.error || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø´Ø±Ù',
            variant: 'destructive',
          });
        }
      } catch (error) {
        console.error('Error fetching supervisor info:', error);
        toast({
          title: 'Ø®Ø·Ø£',
          description: 'ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…',
          variant: 'destructive',
        });
      } finally {
        setLoading(false);
      }
    };

    fetchSupervisorInfo();
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validation
    if (!formData.title.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
      return;
    }

    if (!formData.content.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
      return;
    }

    if (!supervisorInfo) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø´Ø±Ù',
        variant: 'destructive',
      });
      return;
    }

    setSubmitting(true);

    try {
      const payload: any = {
        title: formData.title.trim(),
        content: formData.content,
        videoUrl: formData.videoUrl?.trim() || null,
        imageUrl: formData.imageUrl?.trim() || null,
        pdfUrl: formData.pdfUrl?.trim() || null,
        subjectId: supervisorInfo.subject.id,
        levelId: supervisorInfo.level.id,
        type: formData.isPublic ? 'public' : 'private',
      };

      console.log('Sending payload size:', JSON.stringify(payload).length, 'bytes');

      const response = await fetch('/api/lessons', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Server error:', errorText);
        throw new Error(`ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø­ÙØ¸: ${response.status} - ${errorText.substring(0, 100)}`);
      }

      const result = await response.json();

      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡',
          description: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­',
        });
        router.push('/dashboard/subject-supervisor/lessons');
      } else {
        throw new Error(result.error);
      }
    } catch (error: any) {
      console.error('Submit error:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³. Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ±Ø§Ù‹ Ø¬Ø¯Ø§Ù‹',
        variant: 'destructive',
      });
    } finally {
      setSubmitting(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯</h1>
        <p className="text-muted-foreground">
          Ø§Ù…Ù„Ø£ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø£Ø¯Ù†Ø§Ù‡ Ù„Ø¥Ø¶Ø§ÙØ© Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯. ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¯Ø±Ø³ Ø¹Ø§Ù…Ù‹Ø§ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø£Ùˆ Ø®Ø§ØµÙ‹Ø§ Ø¨Ø·Ù„Ø§Ø¨Ùƒ.
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ø±Ø³</CardTitle>
          <CardDescription>
            {supervisorInfo && `${supervisorInfo.subject.name} - ${supervisorInfo.level.name} (${supervisorInfo.level.stage.name})`}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="title">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <Input 
                id="title" 
                placeholder="Ù…Ø«Ø§Ù„: Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¬Ø¨Ø±" 
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                required
              />
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <Label htmlFor="subject">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                <Input 
                  id="subject" 
                  value={supervisorInfo?.subject.name || ''} 
                  readOnly 
                  disabled 
                  className="bg-muted"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰</Label>
                <Input 
                  id="level" 
                  value={supervisorInfo ? `${supervisorInfo.level.name} (${supervisorInfo.level.stage.name})` : ''} 
                  readOnly 
                  disabled 
                  className="bg-muted"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="content">Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <RichTextEditor 
                content={formData.content}
                onChange={(content) => setFormData({ ...formData, content })}
                placeholder="Ø§ÙƒØªØ¨ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³ Ù‡Ù†Ø§..."
              />
              <p className="text-xs text-muted-foreground">
                Ø§Ø³ØªØ®Ø¯Ù… Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Øµ ÙˆØ¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ©
              </p>
            </div>
            
            <div className="flex items-center space-x-2 space-x-reverse">
              <Switch 
                id="lesson-type" 
                checked={formData.isPublic}
                onCheckedChange={(checked) => setFormData({ ...formData, isPublic: checked })}
              />
              <Label htmlFor="lesson-type">Ø¬Ø¹Ù„Ù‡ Ø¯Ø±Ø³Ù‹Ø§ Ø¹Ø§Ù…Ù‹Ø§ (Ù…ØªØ§Ø­ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªÙˆÙ‰)</Label>
            </div>

            {/* Ù‚Ø³Ù… Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª ÙˆØ§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†Ø³Ø¯Ù„Ø© */}
            <div className="space-y-4 border rounded-lg p-4 bg-muted/20">
              <div className="flex items-center justify-between">
                <Label className="text-base font-semibold flex items-center gap-2">
                  <Paperclip className="w-4 h-4" />
                  Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª
                </Label>
                
                <Select 
                  disabled={isFileUploading || submitting} 
                  onValueChange={(value) => {
                    if (value === 'image') setShowImageUpload(true);
                    if (value === 'pdf') setShowPdfUpload(true);
                    if (value === 'ppt') setShowPptUpload(true);
                  }}
                >
                  <SelectTrigger className="w-[180px]">
                    <SelectValue placeholder="Ø¥Ø¶Ø§ÙØ© Ù…Ø±ÙÙ‚..." />
                  </SelectTrigger>
                  <SelectContent>
                    {!showImageUpload && <SelectItem value="image">ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³</SelectItem>}
                    {!showPdfUpload && <SelectItem value="pdf">Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)</SelectItem>}
                    {!showPptUpload && <SelectItem value="ppt" disabled>Ù…Ù„Ù Ø¹Ø±Ø¶ ØªÙ‚Ø¯ÙŠÙ…ÙŠ (PowerPoint) - Ù‚Ø±ÙŠØ¨Ø§Ù‹</SelectItem>}
                    <SelectItem value="video" disabled>ÙÙŠØ¯ÙŠÙˆ (Ù‚Ø±ÙŠØ¨Ø§Ù‹)</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="video-url">Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (ÙŠÙˆØªÙŠÙˆØ¨)</Label>
                  <Input 
                    id="video-url" 
                    placeholder="https://www.youtube.com/watch?v=..." 
                    value={formData.videoUrl}
                    onChange={(e) => setFormData({ ...formData, videoUrl: e.target.value })}
                    disabled={submitting}
                  /> 
                </div>

                {showImageUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³"
                      accept="image/*"
                      maxSizeMB={5}
                      value={formData.imageUrl}
                      onChange={(fileInfo) => {
                        setFormData({ ...formData, imageUrl: getProxiedUrl(fileInfo?.fileUrl || "") });
                      }}
                      onUploadStatusChange={setIsFileUploading}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù Ù„Ù„Ø¯Ø±Ø³ (JPG, PNG, GIF, Ø­ØªÙ‰ 5 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={supervisorInfo?.level.stage.name}
                      subject={supervisorInfo?.subject.name}
                      teacher="Supervisor"
                      lesson={formData.title}
                    />
                  </div>
                )}

                {showPdfUpload && (
                  <div className="space-y-2 animate-in fade-in slide-in-from-top-2">
                    <FileUpload
                      label="Ù…Ù„Ù Ø§Ù„Ø¯Ø±Ø³ (PDF)"
                      accept=".pdf"
                      maxSizeMB={10}
                      value={formData.pdfUrl}
                      onChange={(fileInfo) => setFormData({ ...formData, pdfUrl: fileInfo?.fileUrl || "" })}
                      onUploadStatusChange={setIsFileUploading}
                      description="Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù PDF Ù„Ù„Ø¯Ø±Ø³ (Ø­ØªÙ‰ 10 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)"
                      stage={supervisorInfo?.level.stage.name}
                      subject={supervisorInfo?.subject.name}
                      teacher="Supervisor"
                      lesson={formData.title}
                    />
                  </div>
                )}
              </div>
            </div>

            <div className="flex justify-end gap-2">
              <Button 
                variant="outline" 
                type="button"
                onClick={() => router.back()}
                disabled={submitting || isFileUploading}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
              <Button type="submit" disabled={submitting || isFileUploading}>
                {submitting || isFileUploading ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    <span>{isFileUploading ? "Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª..." : "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸..."}</span>
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    <span>Ø­ÙØ¸ Ø§Ù„Ø¯Ø±Ø³</span>
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/lessons/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { PlusCircle, FilePenLine, Eye, Trash2, FileQuestion, Loader2, Search } from "lucide-react";
import Link from "next/link";
import { Badge } from "@/components/ui/badge";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { useToast } from "@/hooks/use-toast";
import { useSession } from "next-auth/react";

interface Lesson {
  id: string;
  title: string;
  description: string | null;
  type: 'public' | 'private';
  subject?: {
    id: number;
    name: string;
  };
  level?: {
    id: number;
    name: string;
  };
  _count?: {
    exercises: number;
  };
  createdAt: string;
}

export default function SupervisorLessonsPage() {
  const { toast } = useToast();
  const { data: session } = useSession();
  const [lessons, setLessons] = useState<Lesson[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [supervisorInfo, setSupervisorInfo] = useState<{ subject: string; level: string } | null>(null);

  useEffect(() => {
    const fetchLessons = async () => {
      try {
        // Ø¬Ù„Ø¨ Ø§Ù„Ø¯Ø±ÙˆØ³ - Ø§Ù„Ù€ API Ø³ÙŠØµÙÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø´Ø±Ù
        const response = await fetch('/api/lessons');
        const result = await response.json();

        if (result.success) {
          // API returns lessons in result.data.lessons
          const lessonsData = result.data?.lessons || result.lessons || [];
          setLessons(lessonsData);
          
          // Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø´Ø±Ù Ù„Ù„Ø¹Ø±Ø¶
          if (lessonsData.length > 0 && lessonsData[0].subject && lessonsData[0].level) {
            setSupervisorInfo({
              subject: lessonsData[0].subject.name,
              level: lessonsData[0].level.name,
            });
          }
        }
      } catch (error) {
        console.error('Error fetching lessons:', error);
      } finally {
        setLoading(false);
      }
    };

    if (session?.user) {
      fetchLessons();
    }
  }, [session]);

  const handleDelete = async (lessonId: string) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø¯Ø±Ø³ØŸ')) return;

    try {
      const response = await fetch(`/api/lessons/${lessonId}`, {
        method: 'DELETE',
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø­Ø°Ù',
          description: 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­',
        });
        setLessons(lessons.filter(l => l.id !== lessonId));
      } else {
        throw new Error(result.error);
      }
    } catch (error: any) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø¯Ø±Ø³',
        variant: 'destructive',
      });
    }
  };

  const filteredLessons = lessons.filter(lesson =>
    lesson.title.toLowerCase().includes(searchTerm.toLowerCase())
  );

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <div className="grid gap-1">
          <h1 className="text-3xl font-bold tracking-tight">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¯Ø±ÙˆØ³</h1>
          <p className="text-muted-foreground">
            {supervisorInfo 
              ? `Ø¯Ø±ÙˆØ³ ${supervisorInfo.subject} - ${supervisorInfo.level}` 
              : 'Ù‚Ù… Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ø¥Ù†Ø´Ø§Ø¦Ù‡Ø§'}
          </p>
        </div>
        <Link href="/dashboard/subject-supervisor/lessons/create">
          <Button>
            <PlusCircle className="ml-2 h-4 w-4" />
            <span>Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯</span>
          </Button>
        </Link>
      </div>

      <Card>
        <CardHeader>
          <div className="flex justify-between items-center">
            <div>
              <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø±ÙˆØ³</CardTitle>
              <CardDescription>
                Ø¯Ø±ÙˆØ³Ùƒ ÙÙ‚Ø· ({filteredLessons.length})
              </CardDescription>
            </div>
            <div className="relative w-64">
              <Search className="absolute right-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Ø§Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø¯Ø±ÙˆØ³..."
                className="pr-10"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³</TableHead>
                <TableHead>Ø§Ù„Ù…Ø³ØªÙˆÙ‰</TableHead>
                <TableHead>Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</TableHead>
                <TableHead>Ø§Ù„Ù†ÙˆØ¹</TableHead>
                <TableHead className="text-center">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredLessons.length > 0 ? (
                filteredLessons.map((lesson) => (
                  <TableRow key={lesson.id}>
                    <TableCell className="font-medium">{lesson.title}</TableCell>
                    <TableCell>
                      {lesson.level?.name || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'}
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center gap-1">
                        <FileQuestion className="h-4 w-4 text-muted-foreground" />
                        {lesson._count?.exercises || 0}
                      </div>
                    </TableCell>
                    <TableCell>
                      <Badge variant={lesson.type === 'public' ? 'default' : 'outline'}>
                        {lesson.type === 'public' ? 'Ø¹Ø§Ù…' : 'Ø®Ø§Øµ'}
                      </Badge>
                    </TableCell>
                    <TableCell className="text-center">
                      <div className="flex justify-center gap-2">
                        <Link href={`/lessons/${lesson.id}`}>
                          <Button variant="ghost" size="icon" title="Ù…Ø¹Ø§ÙŠÙ†Ø©">
                            <Eye className="h-4 w-4" />
                          </Button>
                        </Link>
                        <Link href={`/dashboard/subject-supervisor/lessons/${lesson.id}/edit`}>
                          <Button variant="ghost" size="icon" title="ØªØ¹Ø¯ÙŠÙ„">
                            <FilePenLine className="h-4 w-4" />
                          </Button>
                        </Link>
                        <Button 
                          variant="ghost" 
                          size="icon" 
                          title="Ø­Ø°Ù" 
                          className="text-destructive hover:text-destructive"
                          onClick={() => handleDelete(lesson.id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    </TableCell>
                  </TableRow>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={5} className="text-center h-24">
                    {searchTerm ? 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¯Ø±ÙˆØ³' : 'Ù„Ù… ØªÙ‚Ù… Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø£ÙŠ Ø¯Ø±ÙˆØ³ Ø¨Ø¹Ø¯'}
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/exercises/[id]/edit/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Save, Loader2, Sparkles } from "lucide-react";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { RichTextEditor } from "@/components/editor";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";
import { notFound } from "next/navigation";

type ExerciseType = 'main' | 'support_with_results' | 'support_only';

interface ExpectedResult {
  question: string;
  result: string;
}

interface Exercise {
  id: number;
  type: ExerciseType;
  questionRichContent: string;
  modelAnswer: string | null;
  modelAnswerImage: string | null;
  expectedResults: any;
  maxScore: number;
  allowRetry: boolean;
  maxAttempts: number;
  lesson: {
    id: number;
    title: string;
  };
}

export default function EditExercisePage({ params }: { params: Promise<{ id: string }> }) {
  const router = useRouter();
  const { data: session } = useSession();
  const { toast } = useToast();
  
  const [exerciseId, setExerciseId] = useState<string>('');
  const [loading, setLoading] = useState(true);
  const [exercise, setExercise] = useState<Exercise | null>(null);
  const [exerciseType, setExerciseType] = useState<ExerciseType>('main');
  const [questionContent, setQuestionContent] = useState("");
  const [modelAnswer, setModelAnswer] = useState("");
  const [modelAnswerImage, setModelAnswerImage] = useState("");
  const [maxScore, setMaxScore] = useState("20");
  const [allowRetry, setAllowRetry] = useState(true);
  const [maxAttempts, setMaxAttempts] = useState("3");
  const [expectedResults, setExpectedResults] = useState<ExpectedResult[]>([
    { question: "1", result: "" }
  ]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isGeneratingAnswer, setIsGeneratingAnswer] = useState(false);

  useEffect(() => {
    const fetchExercise = async () => {
      const resolvedParams = await params;
      setExerciseId(resolvedParams.id);

      try {
        const response = await fetch(`/api/exercises/${resolvedParams.id}`);
        const result = await response.json();

        if (result.success && result.data) {
          const ex = result.data;
          setExercise(ex);
          setExerciseType(ex.type);
          setQuestionContent(ex.questionRichContent || '');
          setModelAnswer(ex.modelAnswer || '');
          setModelAnswerImage(ex.modelAnswerImage || '');
          setMaxScore(ex.maxScore?.toString() || '20');
          setAllowRetry(ex.allowRetry !== false);
          setMaxAttempts(ex.maxAttempts?.toString() || '3');
          
          if (ex.expectedResults && typeof ex.expectedResults === 'object') {
            const results = Array.isArray(ex.expectedResults) 
              ? ex.expectedResults 
              : Object.entries(ex.expectedResults).map(([q, r]) => ({ question: q, result: r as string }));
            setExpectedResults(results.length > 0 ? results : [{ question: "1", result: "" }]);
          }
        } else {
          notFound();
        }
      } catch (error) {
        console.error('Error fetching exercise:', error);
        notFound();
      } finally {
        setLoading(false);
      }
    };

    fetchExercise();
  }, [params]);

  const handleGenerateAnswer = async () => {
    if (!questionContent.trim()) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©.",
        variant: "destructive",
      });
      return;
    }

    setIsGeneratingAnswer(true);
    try {
      const response = await fetch('/api/ai/generate-answer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: questionContent,
          subject: exercise?.lesson?.title || '',
          level: '',
        }),
      });

      const result = await response.json();

      if (response.ok && result.success) {
        setModelAnswer(result.data.answer);
        toast({
          title: "ØªÙ… Ø¨Ù†Ø¬Ø§Ø­",
          description: "ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©. ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§ ÙˆØªØ¹Ø¯ÙŠÙ„Ù‡Ø§.",
        });
      } else {
        throw new Error(result.error || "ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ");
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setIsGeneratingAnswer(false);
    }
  };

  const handleAddResult = () => {
    setExpectedResults([
      ...expectedResults,
      { question: String(expectedResults.length + 1), result: "" }
    ]);
  };

  const handleRemoveResult = (index: number) => {
    setExpectedResults(expectedResults.filter((_, i) => i !== index));
  };

  const handleResultChange = (index: number, field: 'question' | 'result', value: string) => {
    const newResults = [...expectedResults];
    newResults[index][field] = value;
    setExpectedResults(newResults);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!questionContent) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø³Ø¤Ø§Ù„",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);
    try {
      const payload: any = {
        type: exerciseType,
        questionRichContent: questionContent,
        modelAnswer: exerciseType !== 'support_only' ? modelAnswer : null,
        modelAnswerImage: modelAnswerImage || null,
        maxScore: Number(maxScore),
        allowRetry,
        maxAttempts: Number(maxAttempts),
      };

      if (exerciseType === 'support_with_results') {
        payload.expectedResults = expectedResults.reduce((acc: any, item) => {
          acc[item.question] = item.result;
          return acc;
        }, {});
      }

      const response = await fetch(`/api/exercises/${exerciseId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: "ØªÙ… Ø¨Ù†Ø¬Ø§Ø­",
          description: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­",
        });
        router.push('/dashboard/subject-supervisor/exercises');
      } else {
        throw new Error(result.error || "ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ…Ø±ÙŠÙ†");
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center h-96">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  if (!exercise) {
    return notFound();
  }

  return (
    <div className="flex flex-col gap-8 max-w-4xl mx-auto">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØªÙ…Ø±ÙŠÙ†</h1>
        <p className="text-muted-foreground">
          Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ« ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø£Ø¯Ù†Ø§Ù‡
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØªÙ…Ø±ÙŠÙ†</CardTitle>
          <CardDescription>
            Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„Ù…Ø±ØªØ¨Ø·: {exercise.lesson.title}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="space-y-2">
              <Label>Ù†ÙˆØ¹ Ø§Ù„ØªÙ…Ø±ÙŠÙ†</Label>
              <Select value={exerciseType} onValueChange={(v) => setExerciseType(v as ExerciseType)}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="main">
                    <div className="flex items-center gap-2">
                      <Badge variant="default">Ø±Ø¦ÙŠØ³ÙŠ</Badge>
                      <span>ØªÙ…Ø±ÙŠÙ† Ø±Ø¦ÙŠØ³ÙŠ Ø¨Ø¥Ø¬Ø§Ø¨Ø© Ù†Ù…ÙˆØ°Ø¬ÙŠØ©</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="support_with_results">
                    <div className="flex items-center gap-2">
                      <Badge variant="secondary">Ø¯Ø§Ø¹Ù… Ø¨Ù†ØªØ§Ø¦Ø¬</Badge>
                      <span>ØªÙ…Ø±ÙŠÙ† Ø¯Ø§Ø¹Ù… Ù…Ø¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="support_only">
                    <div className="flex items-center gap-2">
                      <Badge variant="outline">Ø¯Ø§Ø¹Ù… ÙÙ‚Ø·</Badge>
                      <span>ØªÙ…Ø±ÙŠÙ† Ø¯Ø§Ø¹Ù… Ø¨Ø¯ÙˆÙ† Ø¥Ø¬Ø§Ø¨Ø© Ù†Ù…ÙˆØ°Ø¬ÙŠØ©</span>
                    </div>
                  </SelectItem>
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label>Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„</Label>
              <RichTextEditor 
                content={questionContent}
                onChange={setQuestionContent}
              />
            </div>

            {exerciseType !== 'support_only' && (
              <>
                <div className="space-y-2">
                  <div className="flex items-center justify-between">
                    <Label>Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©</Label>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={handleGenerateAnswer}
                      disabled={isGeneratingAnswer || !questionContent}
                    >
                      {isGeneratingAnswer ? (
                        <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                      ) : (
                        <Sparkles className="ml-2 h-4 w-4" />
                      )}
                      <span>ØªÙˆÙ„ÙŠØ¯ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</span>
                    </Button>
                  </div>
                  <RichTextEditor 
                    content={modelAnswer}
                    onChange={setModelAnswer}
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="model-answer-image">Ø±Ø§Ø¨Ø· ØµÙˆØ±Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</Label>
                  <Input 
                    id="model-answer-image"
                    placeholder="https://example.com/answer.jpg"
                    value={modelAnswerImage}
                    onChange={(e) => setModelAnswerImage(e.target.value)}
                  />
                </div>
              </>
            )}

            {exerciseType === 'support_with_results' && (
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <Label>Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©</Label>
                  <Button type="button" variant="outline" size="sm" onClick={handleAddResult}>
                    Ø¥Ø¶Ø§ÙØ© Ù†ØªÙŠØ¬Ø©
                  </Button>
                </div>
                {expectedResults.map((result, index) => (
                  <div key={index} className="flex gap-2 items-start">
                    <div className="flex-1 space-y-2">
                      <Input
                        placeholder="Ø±Ù‚Ù… Ø§Ù„Ø³Ø¤Ø§Ù„"
                        value={result.question}
                        onChange={(e) => handleResultChange(index, 'question', e.target.value)}
                      />
                      <Input
                        placeholder="Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©"
                        value={result.result}
                        onChange={(e) => handleResultChange(index, 'result', e.target.value)}
                      />
                    </div>
                    {expectedResults.length > 1 && (
                      <Button
                        type="button"
                        variant="ghost"
                        size="icon"
                        onClick={() => handleRemoveResult(index)}
                      >
                        Ã—
                      </Button>
                    )}
                  </div>
                ))}
              </div>
            )}

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="max-score">Ø§Ù„Ø¯Ø±Ø¬Ø© Ø§Ù„Ù‚ØµÙˆÙ‰</Label>
                <Input
                  id="max-score"
                  type="number"
                  value={maxScore}
                  onChange={(e) => setMaxScore(e.target.value)}
                  min="1"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="max-attempts">Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©</Label>
                <Input
                  id="max-attempts"
                  type="number"
                  value={maxAttempts}
                  onChange={(e) => setMaxAttempts(e.target.value)}
                  min="1"
                  disabled={!allowRetry}
                />
              </div>
            </div>

            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label>Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©</Label>
                <p className="text-sm text-muted-foreground">
                  Ù‡Ù„ ÙŠÙ…ÙƒÙ† Ù„Ù„Ø·Ø§Ù„Ø¨ Ø­Ù„ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø£ÙƒØ«Ø± Ù…Ù† Ù…Ø±Ø©ØŸ
                </p>
              </div>
              <Switch checked={allowRetry} onCheckedChange={setAllowRetry} />
            </div>

            <div className="flex justify-end gap-2">
              <Button
                type="button"
                variant="outline"
                onClick={() => router.push('/dashboard/subject-supervisor/exercises')}
                disabled={isSubmitting}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? (
                  <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                ) : (
                  <Save className="ml-2 h-4 w-4" />
                )}
                <span>Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª</span>
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/exercises/create/page.tsx
// ==========================================

'use client';

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useSession } from "next-auth/react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useLessons, Lesson } from "@/hooks/use-lessons";
import { useLevels } from "@/hooks/use-data";
import { Save, Loader2, Plus, Trash2, Sparkles } from "lucide-react";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { RichTextEditor } from "@/components/editor";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";

type ExerciseType = 'main' | 'support_with_results' | 'support_only';

interface ExpectedResult {
  question: string;
  result: string;
}

export default function CreateExercisePage() {
  const router = useRouter();
  const { data: session } = useSession();
  const { toast } = useToast();
  
  // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø­Ø³Ø¨ Ù…Ø±Ø­Ù„Ø© Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø© (ÙÙ‚Ø· Ø¹Ù†Ø¯Ù…Ø§ ØªÙƒÙˆÙ† Ø§Ù„Ø¬Ù„Ø³Ø© Ø¬Ø§Ù‡Ø²Ø©)
  const { levels, isLoading: levelsLoading } = useLevels(
    session?.user?.stage_id ? { stageId: session.user.stage_id } : undefined
  );
  const [selectedLevelId, setSelectedLevelId] = useState<number | undefined>(undefined);
  const { lessons, isLoading: lessonsLoading } = useLessons({
    authorId: session?.user?.id,
    levelId: selectedLevelId,
    include: { subject: true, level: true },
  });

  const [lessonId, setLessonId] = useState<string>("");
  const [exerciseType, setExerciseType] = useState<ExerciseType>('main');
  const [questionContent, setQuestionContent] = useState("");
  const [questionFileUrl, setQuestionFileUrl] = useState("");
  const [modelAnswer, setModelAnswer] = useState("");
  const [modelAnswerImage, setModelAnswerImage] = useState("");
  const [maxScore, setMaxScore] = useState("20");
  const [allowRetry, setAllowRetry] = useState(true);
  const [maxAttempts, setMaxAttempts] = useState("3");
  const [expectedResults, setExpectedResults] = useState<ExpectedResult[]>([
    { question: "1", result: "" }
  ]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isGeneratingAnswer, setIsGeneratingAnswer] = useState(false);

  const handleGenerateAnswer = async () => {
    if (!questionContent.trim()) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©.",
        variant: "destructive",
      });
      return;
    }

    if (!lessonId) {
      toast({
        title: "Ø§Ø®ØªØ± Ø§Ù„Ø¯Ø±Ø³ Ø£ÙˆÙ„Ø§Ù‹",
        description: "ÙŠØ¬Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯Ø±Ø³ Ù„ØªÙˆÙÙŠØ± Ø³ÙŠØ§Ù‚ Ø£ÙØ¶Ù„ Ù„Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ.",
        variant: "destructive",
      });
      return;
    }

    const selectedLesson = lessons.find(l => String(l.id) === lessonId);

    setIsGeneratingAnswer(true);
    try {
      const response = await fetch('/api/ai/generate-answer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          question: questionContent,
          subject: selectedLesson?.subject?.name,
          level: selectedLesson?.level?.name,
        }),
      });

      const result = await response.json();

      if (response.ok && result.success) {
        setModelAnswer(result.data.answer);
        toast({
          title: "ØªÙ… Ø¨Ù†Ø¬Ø§Ø­",
          description: "ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©. ÙŠÙ…ÙƒÙ†Ùƒ Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§ ÙˆØªØ¹Ø¯ÙŠÙ„Ù‡Ø§.",
        });
      } else {
        throw new Error(result.error || "ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ");
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
        description: error.message,
        variant: "destructive",
      });
    } finally {
      setIsGeneratingAnswer(false);
    }
  };

  const handleAddResult = () => {
    setExpectedResults([
      ...expectedResults,
      { question: String(expectedResults.length + 1), result: "" }
    ]);
  };

  const handleRemoveResult = (index: number) => {
    setExpectedResults(expectedResults.filter((_, i) => i !== index));
  };

  const handleResultChange = (index: number, field: 'question' | 'result', value: string) => {
    const newResults = [...expectedResults];
    newResults[index][field] = value;
    setExpectedResults(newResults);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!lessonId || !questionContent) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø¯Ø±Ø³ ÙˆÙƒØªØ§Ø¨Ø© Ø§Ù„Ø³Ø¤Ø§Ù„",
        variant: "destructive",
      });
      return;
    }

    if (exerciseType === 'main' && !modelAnswer) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ¬Ø¨ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù„Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ",
        variant: "destructive",
      });
      return;
    }

    if (exerciseType === 'support_with_results') {
      const hasEmptyResults = expectedResults.some(r => !r.result.trim());
      if (hasEmptyResults) {
        toast({
          title: "Ø®Ø·Ø£",
          description: "ÙŠØ¬Ø¨ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©",
          variant: "destructive",
        });
        return;
      }
    }

    setIsSubmitting(true);

    try {
      const response = await fetch(`/api/exercises?lessonId=${lessonId}`);
      const result = await response.json();
      const existingExercises = result.success ? (result.exercises || []) : [];
      const displayOrder = existingExercises.length + 1;

      const exerciseData: any = {
        lessonId: parseInt(lessonId),
        type: exerciseType,
        questionRichContent: questionContent,
        questionFileUrl: questionFileUrl || null,
        displayOrder,
      };

      if (exerciseType === 'main') {
        exerciseData.modelAnswer = modelAnswer;
        if (modelAnswerImage) exerciseData.modelAnswerImage = modelAnswerImage;
        exerciseData.maxScore = parseFloat(maxScore);
        exerciseData.allowRetry = allowRetry;
        exerciseData.maxAttempts = parseInt(maxAttempts);
      } else if (exerciseType === 'support_with_results') {
        exerciseData.expectedResults = expectedResults;
      }

      const createResponse = await fetch('/api/exercises', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(exerciseData),
      });

      const createResult = await createResponse.json();

      if (createResult.success) {
        toast({
          title: "Ù†Ø¬Ø­",
          description: "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­",
        });
        router.push("/dashboard/subject-supervisor/exercises");
      } else {
        throw new Error(createResult.error || "ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ†");
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message || "ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ†",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const getExerciseTypeLabel = (type: ExerciseType) => {
    switch (type) {
      case 'main':
        return 'ØªÙ…Ø±ÙŠÙ† Ø±Ø¦ÙŠØ³ÙŠ (ØªØµØ­ÙŠØ­ Ø°ÙƒÙŠ)';
      case 'support_with_results':
        return 'ØªÙ…Ø±ÙŠÙ† Ø¯Ø¹Ù… + Ù†ØªØ§Ø¦Ø¬';
      case 'support_only':
        return 'ØªÙ…Ø±ÙŠÙ† Ø¯Ø¹Ù… ÙÙ‚Ø·';
    }
  };

  const getExerciseTypeDescription = (type: ExerciseType) => {
    switch (type) {
      case 'main':
        return 'ÙŠØªÙ… ØªØµØ­ÙŠØ­Ù‡ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ÙˆÙŠØ­ØµÙ„ Ø§Ù„ØªÙ„Ù…ÙŠØ° Ø¹Ù„Ù‰ Ù†Ù‚Ø·Ø© ÙˆÙ…Ù„Ø§Ø­Ø¸Ø§Øª';
      case 'support_with_results':
        return 'ÙŠØ³ØªØ·ÙŠØ¹ Ø§Ù„ØªÙ„Ù…ÙŠØ° Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆÙ…Ù‚Ø§Ø±Ù†ØªÙ‡Ø§ Ù…Ø¹ Ø§Ù„Ø­Ù„ Ø§Ù„ØµØ­ÙŠØ­';
      case 'support_only':
        return 'Ø¹Ø±Ø¶ ÙÙ‚Ø· - Ù„Ø§ ÙŠÙ…ÙƒÙ† Ù„Ù„ØªÙ„Ù…ÙŠØ° Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©';
    }
  };

  if (lessonsLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  };

  return (
    <div className="flex flex-col gap-8">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">Ø¥Ù†Ø´Ø§Ø¡ ØªÙ…Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯</h1>
        <p className="text-muted-foreground">
          Ø£Ø¶Ù ØªÙ…Ø±ÙŠÙ†Ø§Ù‹ Ø¬Ø¯ÙŠØ¯Ø§Ù‹ Ù„Ø·Ù„Ø§Ø¨Ùƒ Ù…Ø¹ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨.
        </p>
      </div>

      <form onSubmit={handleSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ØªÙ…Ø±ÙŠÙ†</CardTitle>
            <CardDescription>
              Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„ØªÙ…Ø±ÙŠÙ† ÙˆØ£Ø¯Ø®Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="space-y-2">
              <Label htmlFor="level">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ - Ù„ØªØµÙÙŠØ© Ø§Ù„Ø¯Ø±ÙˆØ³)</Label>
              <Select 
                value={selectedLevelId?.toString() || "all"} 
                onValueChange={(value) => setSelectedLevelId(value === "all" ? undefined : parseInt(value))}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</SelectItem>
                  {levels && Array.isArray(levels) && levels.map((level) => (
                    <SelectItem key={level.id} value={String(level.id)}>
                      {level.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-2">
              <Label htmlFor="lesson">Ø§Ù„Ø¯Ø±Ø³ *</Label>
              <Select value={lessonId} onValueChange={setLessonId}>
                <SelectTrigger>
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ø¯Ø±Ø³" />
                </SelectTrigger>
                <SelectContent>
                  {lessons.length === 0 ? (
                    <SelectItem value="none" disabled>
                      {lessonsLoading ? "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„..." : "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¯Ø±ÙˆØ³ Ù…ØªØ§Ø­Ø©"}
                    </SelectItem>
                  ) : (
                    lessons.map((lesson) => (
                      <SelectItem key={lesson.id} value={String(lesson.id)}>
                        {lesson.title}
                        {lesson.subject && lesson.level && ` (${lesson.subject.name} - ${lesson.level.name})`}
                      </SelectItem>
                    ))
                  )}
                </SelectContent>
              </Select>
            </div>

            <div className="space-y-3">
              <Label>Ù†ÙˆØ¹ Ø§Ù„ØªÙ…Ø±ÙŠÙ† *</Label>
              <div className="grid gap-3">
                {(['main', 'support_with_results', 'support_only'] as ExerciseType[]).map((type) => (
                  <Card
                    key={type}
                    className={`cursor-pointer transition-all ${
                      exerciseType === type
                        ? 'border-primary bg-primary/5'
                        : 'hover:border-primary/50'
                    }`}
                    onClick={() => setExerciseType(type)}
                  >
                    <CardHeader className="p-4">
                      <div className="flex items-start justify-between">
                        <div className="space-y-1">
                          <CardTitle className="text-base">
                            {getExerciseTypeLabel(type)}
                          </CardTitle>
                          <CardDescription className="text-sm">
                            {getExerciseTypeDescription(type)}
                          </CardDescription>
                        </div>
                        {exerciseType === type && (
                          <Badge variant="default">Ù…Ø®ØªØ§Ø±</Badge>
                        )}
                      </div>
                    </CardHeader>
                  </Card>
                ))}
              </div>
            </div>

            <div className="space-y-2">
              <Label>Ø§Ù„Ø³Ø¤Ø§Ù„ / Ø§Ù„ØªÙ…Ø±ÙŠÙ† *</Label>
              <RichTextEditor
                content={questionContent}
                onChange={setQuestionContent}
                placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù‡Ù†Ø§... ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© ØµÙˆØ± ÙˆØ¬Ø¯Ø§ÙˆÙ„"
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="questionFileUrl">Ø±Ø§Ø¨Ø· Ù…Ù„Ù Ø§Ù„Ø³Ø¤Ø§Ù„ (PDF Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</Label>
              <Input
                id="questionFileUrl"
                type="url"
                placeholder="https://example.com/question.pdf"
                value={questionFileUrl}
                onChange={(e) => setQuestionFileUrl(e.target.value)}
              />
            </div>

            {exerciseType === 'main' && (
              <>
                <div className="space-y-2">
                  <div className="flex items-center justify-between mb-2">
                    <Label>Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ *</Label>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={handleGenerateAnswer}
                      disabled={isGeneratingAnswer || !lessonId}
                    >
                      {isGeneratingAnswer ? (
                        <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                      ) : (
                        <Sparkles className="ml-2 h-4 w-4" />
                      )}
                      ØªÙˆÙ„ÙŠØ¯ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
                    </Button>
                  </div>
                  <RichTextEditor
                    content={modelAnswer}
                    onChange={setModelAnswer}
                    placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù‡Ù†Ø§ØŒ Ø£Ùˆ Ù‚Ù… Ø¨ØªÙˆÙ„ÙŠØ¯Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹..."
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="modelAnswerImage">ØµÙˆØ±Ø© Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</Label>
                  <Input
                    id="modelAnswerImage"
                    type="url"
                    placeholder="https://example.com/image.jpg"
                    value={modelAnswerImage}
                    onChange={(e) => setModelAnswerImage(e.target.value)}
                  />
                </div>

                <div className="grid gap-4 sm:grid-cols-3">
                  <div className="space-y-2">
                    <Label htmlFor="maxScore">Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ù‚ØµÙˆÙ‰</Label>
                    <Input
                      id="maxScore"
                      type="number"
                      step="0.5"
                      min="1"
                      max="100"
                      value={maxScore}
                      onChange={(e) => setMaxScore(e.target.value)}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="maxAttempts">Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª</Label>
                    <Input
                      id="maxAttempts"
                      type="number"
                      min="1"
                      max="10"
                      value={maxAttempts}
                      onChange={(e) => setMaxAttempts(e.target.value)}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="allowRetry">Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø©</Label>
                    <div className="flex items-center gap-2 h-10">
                      <Switch
                        id="allowRetry"
                        checked={allowRetry}
                        onCheckedChange={setAllowRetry}
                      />
                      <span className="text-sm">{allowRetry ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'}</span>
                    </div>
                  </div>
                </div>
              </>
            )}

            {exerciseType === 'support_with_results' && (
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <Label>Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© *</Label>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={handleAddResult}
                  >
                    <Plus className="h-4 w-4 ml-2" />
                    Ø¥Ø¶Ø§ÙØ© Ù†ØªÙŠØ¬Ø©
                  </Button>
                </div>

                <div className="space-y-3">
                  {expectedResults.map((result, index) => (
                    <Card key={index}>
                      <CardContent className="p-4">
                        <div className="flex gap-3">
                          <div className="flex-1 grid gap-3 sm:grid-cols-2">
                            <div className="space-y-2">
                              <Label>Ø±Ù‚Ù… Ø§Ù„Ø³Ø¤Ø§Ù„</Label>
                              <Input
                                placeholder="1"
                                value={result.question}
                                onChange={(e) =>
                                  handleResultChange(index, 'question', e.target.value)
                                }
                              />
                            </div>
                            <div className="space-y-2">
                              <Label>Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©</Label>
                              <Input
                                placeholder="Ù…Ø«Ø§Ù„: 45 Ø£Ùˆ 3x - 5"
                                value={result.result}
                                onChange={(e) =>
                                  handleResultChange(index, 'result', e.target.value)
                                }
                              />
                            </div>
                          </div>
                          {expectedResults.length > 1 && (
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              onClick={() => handleRemoveResult(index)}
                              className="text-destructive"
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          )}
                        </div>
                      </CardContent>
                    </Card>
                  ))}
                </div>
              </div>
            )}

            {exerciseType === 'support_only' && (
              <div className="rounded-lg border border-muted bg-muted/50 p-4">
                <p className="text-sm text-muted-foreground">
                  â„¹ï¸ Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ù„Ù„Ø¹Ø±Ø¶ ÙÙ‚Ø·. Ù„Ù† ÙŠØªÙ…ÙƒÙ† Ø§Ù„ØªÙ„Ø§Ù…ÙŠØ° Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø¥Ø¬Ø§Ø¨Ø§Øª.
                </p>
              </div>
            )}

            <div className="flex gap-3 pt-4">
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸...
                  </>
                ) : (
                  <>
                    <Save className="ml-2 h-4 w-4" />
                    Ø­ÙØ¸ Ø§Ù„ØªÙ…Ø±ÙŠÙ†
                  </>
                )}
              </Button>
              <Button
                type="button"
                variant="outline"
                onClick={() => router.back()}
                disabled={isSubmitting}
              >
                Ø¥Ù„ØºØ§Ø¡
              </Button>
            </div>
          </CardContent>
        </Card>
      </form>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/subject-supervisor/exercises/page.tsx
// ==========================================


'use client';

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { PlusCircle, FilePenLine, Trash2, Search, Loader2 } from "lucide-react";
import Link from "next/link";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { useToast } from "@/hooks/use-toast";

interface Exercise {
  id: number;
  question: string;
  lesson: {
    id: number;
    title: string;
  };
}

export default function SupervisorExercisesPage() {
  const [exercises, setExercises] = useState<Exercise[]>([]);
  const [filteredExercises, setFilteredExercises] = useState<Exercise[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState("");
  const { toast } = useToast();

  useEffect(() => {
    fetchExercises();
  }, []);

  useEffect(() => {
    if (searchQuery) {
      const filtered = exercises.filter(
        (ex) =>
          ex.question.toLowerCase().includes(searchQuery.toLowerCase()) ||
          ex.lesson.title.toLowerCase().includes(searchQuery.toLowerCase())
      );
      setFilteredExercises(filtered);
    } else {
      setFilteredExercises(exercises);
    }
  }, [searchQuery, exercises]);

  const fetchExercises = async () => {
    try {
      const response = await fetch('/api/subject-supervisor/exercises');
      const result = await response.json();

      console.log('ğŸ“¥ Exercises API response:', result);

      if (result.success) {
        // Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¢Ù† Ù…Ø¨Ø§Ø´Ø±Ø© ÙÙŠ result.data
        const exercisesData = Array.isArray(result.data) ? result.data : [];
        console.log('âœ… Exercises data:', exercisesData);
        setExercises(exercisesData);
        setFilteredExercises(exercisesData);
      } else {
        console.error('âŒ API returned error:', result.error);
        toast({
          title: 'Ø®Ø·Ø£',
          description: result.error || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†',
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('âŒ Error fetching exercises:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleDelete = async (id: number) => {
    if (!confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ†ØŸ')) return;

    try {
      const response = await fetch(`/api/exercises/${id}`, {
        method: 'DELETE',
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø­Ø°Ù',
          description: 'ØªÙ… Ø­Ø°Ù Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­',
        });
        fetchExercises();
      } else {
        toast({
          title: 'Ø®Ø·Ø£',
          description: result.error || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„ØªÙ…Ø±ÙŠÙ†',
          variant: 'destructive',
        });
      }
    } catch (error) {
      console.error('Error deleting exercise:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„ØªÙ…Ø±ÙŠÙ†',
        variant: 'destructive',
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <div className="grid gap-1">
          <h1 className="text-3xl font-bold tracking-tight">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</h1>
          <p className="text-muted-foreground">
            Ù‚Ù… Ø¨Ø¥Ø¯Ø§Ø±Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† ÙÙŠ Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…Ø§Ø¯Ø©.
          </p>
        </div>
        <Link href="/dashboard/subject-supervisor/exercises/create">
          <Button>
            <PlusCircle className="ml-2 h-4 w-4" />
            Ø¥Ø¶Ø§ÙØ© ØªÙ…Ø±ÙŠÙ† Ø¬Ø¯ÙŠØ¯
          </Button>
        </Link>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</CardTitle>
          <CardDescription>
            Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© ÙÙŠ Ø¯Ø±ÙˆØ³ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø§Ø¯Ø©.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="mb-4">
            <div className="relative">
              <Search className="absolute right-3 top-3 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Ø§Ø¨Ø­Ø« ÙÙŠ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø£Ùˆ Ø§Ù„Ø¯Ø±ÙˆØ³..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pr-10"
              />
            </div>
          </div>

          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„</TableHead>
                <TableHead>Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„Ù…Ø±ØªØ¨Ø·</TableHead>
                <TableHead className="text-center">Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredExercises.length > 0 ? (
                filteredExercises.map((exercise) => (
                    <TableRow key={exercise.id}>
                        <TableCell className="font-medium max-w-md">
                          <div className="truncate">{exercise.question}</div>
                        </TableCell>
                        <TableCell>{exercise.lesson.title}</TableCell>
                        <TableCell className="text-center">
                            <div className="flex justify-center gap-2">
                                <Link href={`/dashboard/subject-supervisor/exercises/${exercise.id}/edit`}>
                                    <Button variant="ghost" size="icon" title="ØªØ¹Ø¯ÙŠÙ„">
                                        <FilePenLine className="h-4 w-4" />
                                    </Button>
                                </Link>
                                <Button 
                                  variant="ghost" 
                                  size="icon" 
                                  title="Ø­Ø°Ù" 
                                  className="text-destructive hover:text-destructive"
                                  onClick={() => handleDelete(exercise.id)}
                                >
                                    <Trash2 className="h-4 w-4" />
                                </Button>
                            </div>
                        </TableCell>
                    </TableRow>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={3} className="text-center h-24">
                    {searchQuery ? 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù„Ø¨Ø­Ø«' : 'Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ…Ø§Ø±ÙŠÙ† ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ø¹Ø¯.'}
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/parent/notifications/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Bell, CheckCircle2, AlertTriangle, AlertCircle, Loader2 } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { ar } from "date-fns/locale";
import { cn } from "@/lib/utils";
import Link from "next/link";
import { Button } from "@/components/ui/button";

type Notification = {
  id: number;
  student: {
    id: string;
    firstName: string;
    lastName: string;
    image: string | null;
  };
  exercise: {
    question: string;
  };
  lesson: {
    title: string;
  };
  subject: {
    name: string;
  };
  score: number;
  status: 'excellent' | 'good' | 'needs_improvement';
  attemptNumber: number;
  submittedAt: Date;
};

export default function NotificationsPage() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchNotifications();
  }, []);

  const fetchNotifications = async () => {
    try {
      setIsLoading(true);
      const response = await fetch('/api/parents/notifications');
      const result = await response.json();
      if (result.success) {
        setNotifications(result.data.notifications);
      }
    } catch (error) {
      console.error('Error fetching notifications:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const getNotificationDetails = (status: string) => {
    if (status === 'excellent') {
      return { 
        icon: CheckCircle2, 
        color: "text-green-600 dark:text-green-400", 
        title: "Ø¥Ù†Ø¬Ø§Ø² Ø±Ø§Ø¦Ø¹!",
        bgClassName: "bg-green-50 border-green-200 dark:bg-green-950 dark:border-green-800"
      };
    }
    if (status === 'good') {
      return { 
        icon: AlertTriangle, 
        color: "text-yellow-600 dark:text-yellow-400", 
        title: "Ø£Ø¯Ø§Ø¡ Ø¬ÙŠØ¯ØŒ ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ†Ù‡",
        bgClassName: "bg-yellow-50 border-yellow-200 dark:bg-yellow-950 dark:border-yellow-800"
      };
    }
    return { 
      icon: AlertCircle, 
      color: "text-red-600 dark:text-red-400", 
      title: "ÙŠØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø©",
      bgClassName: "bg-red-50 border-red-200 dark:bg-red-950 dark:border-red-800"
    };
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }
  
  return (
    <div className="flex flex-col gap-8">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª</h1>
        <p className="text-muted-foreground">
          Ø¢Ø®Ø± Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª ÙˆØ§Ù„Ø£Ù†Ø´Ø·Ø© Ø§Ù„Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ø£Ø¨Ù†Ø§Ø¦Ùƒ.
        </p>
      </div>
      
      <Card>
        <CardHeader>
          <CardTitle>Ø¢Ø®Ø± Ø§Ù„Ø£Ù†Ø´Ø·Ø©</CardTitle>
          <CardDescription>
            Ù„Ø¯ÙŠÙƒ {notifications.length} Ø¥Ø´Ø¹Ø§Ø± Ø¨Ø®ØµÙˆØµ Ù†Ø´Ø§Ø· Ø£Ø¨Ù†Ø§Ø¦Ùƒ.
          </CardDescription>
        </CardHeader>
        <CardContent>
          {notifications.length > 0 ? (
            <div className="space-y-4">
              {notifications.map(notification => {
                const studentName = `${notification.student.firstName} ${notification.student.lastName}`;
                const details = getNotificationDetails(notification.status);
                const Icon = details.icon;

                return (
                  <div key={notification.id} className={cn("flex gap-4 items-start p-4 rounded-lg border", details.bgClassName)}>
                    <Avatar className="h-11 w-11 border-2 border-primary/20 mt-1">
                      <AvatarImage src={notification.student.image || ''} alt={studentName} />
                      <AvatarFallback>{notification.student.firstName.charAt(0)}</AvatarFallback>
                    </Avatar>
                    <div className="flex-1">
                      <div className="flex justify-between items-start">
                        <p className="leading-relaxed text-sm">
                          Ù‚Ø§Ù… Ø§Ø¨Ù†Ùƒ <span className="font-bold">{studentName}</span> Ø¨Ø¥ÙƒÙ…Ø§Ù„ Ø¯Ø±Ø³ "{notification.lesson.title}" Ù…Ù† Ù…Ø§Ø¯Ø© "{notification.subject.name}".
                          ÙˆØ­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù„Ø§Ù…Ø© <span className="font-bold text-primary">{notification.score}/10</span> ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø±Ù‚Ù… <span className="font-bold">{notification.attemptNumber}</span>.
                        </p>
                        <span className="text-xs text-muted-foreground whitespace-nowrap pt-1">
                          {formatDistanceToNow(new Date(notification.submittedAt), { addSuffix: true, locale: ar })}
                        </span>
                      </div>
                      <div className="mt-3 flex items-center gap-4">
                        <div className={cn("flex items-center gap-2", details.color)}>
                          <Icon className="h-5 w-5" />
                          <span className="font-semibold text-sm">{details.title}</span>
                        </div>
                        <Link href={`/dashboard/parent/children/${notification.student.id}`} passHref>
                          <Button variant="link" size="sm" className="px-0 h-auto text-foreground/80 hover:text-foreground">
                            Ø¹Ø±Ø¶ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„ÙƒØ§Ù…Ù„
                          </Button>
                        </Link>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>
          ) : (
            <div className="text-center text-muted-foreground py-12 flex flex-col items-center gap-4">
              <Bell className="h-16 w-16 text-muted-foreground/50" />
              <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©. Ø³ÙŠØªÙ… Ø¹Ø±Ø¶Ù‡Ø§ Ù‡Ù†Ø§ Ø¹Ù†Ø¯ ØªÙˆÙØ±Ù‡Ø§.</p>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/parent/page.tsx
// ==========================================

'use client';

import ParentDashboard from "../_components/ParentDashboard";

export const dynamic = 'force-dynamic';

export default function ParentDashboardPage() {
    return <ParentDashboard />
}


// ==========================================
// FILE: src/app/(main)/dashboard/parent/children/[id]/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { TrendingUp, Target, BookCheck, ArrowLeft, MessageSquare, Mail, BookOpen, FileQuestion, Loader2 } from "lucide-react";
import Link from "next/link";
import { useToast } from "@/hooks/use-toast";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";

type Subject = {
  id: number;
  name: string;
  teacher: {
    id: string;
    firstName: string;
    lastName: string;
    allowMessaging: boolean;
  } | null;
  stats: {
    totalLessons: number;
    totalExercises: number;
    totalSubmissions: number;
    gradedSubmissions: number;
    averageScore: number;
  };
};

type ChildDetails = {
  id: string;
  firstName: string;
  lastName: string;
  email: string;
  image: string | null;
  level: {
    id: number;
    name: string;
    stage: {
      id: number;
      name: string;
    };
  } | null;
  stats: {
    completedLessons: number;
    averageScore: number;
    submissionCount: number;
  };
};

export default function ChildDetailsPage({ params }: { params: Promise<{ id: string }> | { id: string } }) {
  const { toast } = useToast();
  const [childId, setChildId] = useState<string>('');
  const [child, setChild] = useState<ChildDetails | null>(null);
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [messageDialog, setMessageDialog] = useState<{ open: boolean; teacher: { id: string; name: string } | null }>({ open: false, teacher: null });
  const [messageContent, setMessageContent] = useState('');
  const [isSending, setIsSending] = useState(false);

  useEffect(() => {
    const initializeParams = async () => {
      const resolvedParams = await Promise.resolve(params);
      setChildId(resolvedParams.id);
    };
    initializeParams();
  }, [params]);

  useEffect(() => {
    if (childId) {
      fetchChildDetails();
      fetchSubjects();
    }
  }, [childId]);

  const fetchChildDetails = async () => {
    try {
      const response = await fetch(`/api/parents/children/${childId}`);
      const result = await response.json();
      if (result.success) {
        setChild(result.data.child);
      }
    } catch (error) {
      console.error('Error fetching child details:', error);
    }
  };

  const fetchSubjects = async () => {
    try {
      setIsLoading(true);
      const response = await fetch(`/api/parents/children/${childId}/subjects`);
      const result = await response.json();
      console.log('Subjects data:', result.data);
      if (result.success) {
        setSubjects(result.data.subjects);
      }
    } catch (error) {
      console.error('Error fetching subjects:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleOpenMessageDialog = (teacherId: string, teacherName: string, allowMessaging: boolean) => {
    if (!allowMessaging) {
      toast({
        title: 'ØºÙŠØ± Ù…ØªØ§Ø­',
        description: 'Ø§Ù„Ù…Ø¹Ù„Ù… ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„ØªÙˆØ§ØµÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹',
        variant: 'destructive',
      });
      return;
    }
    setMessageDialog({ open: true, teacher: { id: teacherId, name: teacherName } });
    setMessageContent('');
  };

  const handleSendMessage = async () => {
    if (!messageContent.trim() || !messageDialog.teacher) return;

    setIsSending(true);
    try {
      // Check if teacher still allows messaging
      const teacherCheck = await fetch(`/api/teachers/${messageDialog.teacher.id}/messaging-status`);
      const checkResult = await teacherCheck.json();
      
      if (!checkResult.success || !checkResult.data.allowMessaging) {
        toast({
          title: 'ØºÙŠØ± Ù…ØªØ§Ø­',
          description: 'Ø§Ù„Ù…Ø¹Ù„Ù… Ù‚Ø§Ù… Ø¨ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªÙˆØ§ØµÙ„. Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.',
          variant: 'destructive',
        });
        setMessageDialog({ open: false, teacher: null });
        setIsSending(false);
        return;
      }

      const response = await fetch('/api/messages', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          recipientId: messageDialog.teacher.id,
          subject: `Ø±Ø³Ø§Ù„Ø© Ù…Ù† ÙˆÙ„ÙŠ Ø£Ù…Ø± ${child?.firstName}`,
          content: messageContent,
        }),
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„',
          description: `ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„ØªÙƒ Ø¥Ù„Ù‰ ${messageDialog.teacher.name}`,
        });
        
        setMessageDialog({ open: false, teacher: null });
        setMessageContent('');
      } else {
        throw new Error(result.error);
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©',
        variant: 'destructive',
      });
    } finally {
      setIsSending(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!child) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <p className="text-muted-foreground">Ø§Ù„Ø·Ø§Ù„Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯</p>
      </div>
    );
  }

  return (
    <>
      <div className="flex flex-col gap-8">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Avatar className="h-20 w-20">
              <AvatarImage src={child.image || ''} alt={`${child.firstName} ${child.lastName}`} />
              <AvatarFallback>{child.firstName.charAt(0)}</AvatarFallback>
            </Avatar>
            <div className="grid gap-1">
              <h1 className="text-3xl font-bold tracking-tight">
                ØªÙ‚Ø±ÙŠØ± Ø£Ø¯Ø§Ø¡ {child.firstName} {child.lastName}
              </h1>
              <p className="text-muted-foreground">
                Ù†Ø¸Ø±Ø© Ø´Ø§Ù…Ù„Ø© Ø¹Ù„Ù‰ ØªÙ‚Ø¯Ù… {child.firstName} Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ
              </p>
            </div>
          </div>
          <Link href="/dashboard/parent/children">
            <Button variant="outline">
              <ArrowLeft className="h-4 w-4" />
              <span className="mr-2">Ø§Ù„Ø±Ø¬ÙˆØ¹</span>
            </Button>
          </Link>
        </div>

        {/* Statistics Cards */}
        <div className="grid gap-6 md:grid-cols-3">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©</CardTitle>
              <BookCheck className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{child.stats?.completedLessons || 0}</div>
              <p className="text-xs text-muted-foreground">Ø¯Ø±ÙˆØ³ Ù…ÙƒØªÙ…Ù„Ø©</p>
            </CardContent>
          </Card>
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ù…Ø­Ù„ÙˆÙ„Ø©</CardTitle>
              <TrendingUp className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{child.stats?.submissionCount || 0}</div>
              <p className="text-xs text-muted-foreground">ØªÙ…Ø§Ø±ÙŠÙ† Ù…Ø­Ù„ÙˆÙ„Ø©</p>
            </CardContent>
          </Card>
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª</CardTitle>
              <Target className="h-4 w-4 text-muted-foreground" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{child.stats?.averageScore || 0}/10</div>
              <p className="text-xs text-muted-foreground">ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†</p>
            </CardContent>
          </Card>
        </div>

        {/* Subjects Cards with Messaging */}
        <Card>
          <CardHeader>
            <CardTitle>Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</CardTitle>
            <CardDescription>
              Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„ØªÙŠ ÙŠØ¯Ø±Ø³Ù‡Ø§ {child.firstName} Ù…Ø¹ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ¥Ù…ÙƒØ§Ù†ÙŠØ© Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ†
            </CardDescription>
          </CardHeader>
          <CardContent>
            {subjects.length > 0 ? (
              <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                {subjects.map((subject) => {
                  const teacherName = subject.teacher
                    ? `${subject.teacher.firstName} ${subject.teacher.lastName}`
                    : 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ù„Ù…';

                  return (
                    <Card key={subject.id} className="relative">
                      <CardHeader className="pb-3">
                        <div className="flex items-start justify-between gap-2">
                          <div className="flex-1 min-w-0">
                            <CardTitle className="text-lg mb-2">{subject.name}</CardTitle>
                            {subject.teacher ? (
                              <CardDescription className="flex items-center gap-2">
                                <Avatar className="h-5 w-5">
                                  <AvatarFallback className="text-xs">
                                    {subject.teacher.firstName.charAt(0)}
                                  </AvatarFallback>
                                </Avatar>
                                <span className="text-xs truncate">{teacherName}</span>
                              </CardDescription>
                            ) : (
                              <CardDescription className="text-xs">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ù„Ù…</CardDescription>
                            )}
                          </div>
                          {subject.teacher && (
                            <div className="flex-shrink-0">
                              {subject.teacher.allowMessaging ? (
                                <Button
                                  size="icon"
                                  variant="default"
                                  className="h-9 w-9"
                                  onClick={() => handleOpenMessageDialog(subject.teacher!.id, teacherName, subject.teacher!.allowMessaging)}
                                  title="Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù…Ø¹Ù„Ù…"
                                >
                                  <MessageSquare className="h-5 w-5" />
                                </Button>
                              ) : (
                                <Button
                                  size="icon"
                                  variant="outline"
                                  className="h-9 w-9"
                                  disabled
                                  title="Ø§Ù„Ù…Ø¹Ù„Ù… ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„ØªÙˆØ§ØµÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹"
                                >
                                  <Mail className="h-5 w-5 text-muted-foreground" />
                                </Button>
                              )}
                            </div>
                          )}
                        </div>
                      </CardHeader>
                      <CardContent className="space-y-3">
                        <div className="grid grid-cols-2 gap-2">
                          <div className="flex items-center gap-2 p-2 bg-muted rounded text-center">
                            <BookOpen className="h-4 w-4 text-primary" />
                            <div className="flex-1">
                              <p className="text-lg font-bold">{subject.stats.totalLessons}</p>
                              <p className="text-xs text-muted-foreground">Ø¯Ø±ÙˆØ³</p>
                            </div>
                          </div>
                          <div className="flex items-center gap-2 p-2 bg-muted rounded text-center">
                            <FileQuestion className="h-4 w-4 text-primary" />
                            <div className="flex-1">
                              <p className="text-lg font-bold">{subject.stats.totalExercises}</p>
                              <p className="text-xs text-muted-foreground">ØªÙ…Ø§Ø±ÙŠÙ†</p>
                            </div>
                          </div>
                        </div>

                        <div className="space-y-1.5 text-sm">
                          <div className="flex justify-between items-center">
                            <span className="text-muted-foreground">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª</span>
                            <Badge variant="secondary" className="text-xs">
                              {subject.stats.totalSubmissions}
                            </Badge>
                          </div>
                          <div className="flex justify-between items-center">
                            <span className="text-muted-foreground">ØªÙ… Ø§Ù„ØªØµØ­ÙŠØ­</span>
                            <Badge variant="default" className="text-xs">
                              {subject.stats.gradedSubmissions}
                            </Badge>
                          </div>
                          <div className="flex justify-between items-center pt-1 border-t">
                            <span className="text-muted-foreground font-medium">Ø§Ù„Ù…ØªÙˆØ³Ø·</span>
                            <div className="flex items-center gap-1">
                              <TrendingUp className="h-3 w-3 text-primary" />
                              <span className="font-bold text-primary">
                                {subject.stats.averageScore}/10
                              </span>
                            </div>
                          </div>
                        </div>
                      </CardContent>
                    </Card>
                  );
                })}
              </div>
            ) : (
              <p className="text-center text-muted-foreground py-8">
                Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¯ Ù…Ø³Ø¬Ù„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø·Ø§Ù„Ø¨
              </p>
            )}
          </CardContent>
        </Card>
      </div>

      {/* Message Dialog */}
      <Dialog open={messageDialog.open} onOpenChange={(open) => setMessageDialog({ open, teacher: null })}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø©</DialogTitle>
            <DialogDescription>
              Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ {messageDialog.teacher?.name}
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="message">Ø§Ù„Ø±Ø³Ø§Ù„Ø©</Label>
              <Textarea
                id="message"
                placeholder="Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ Ù‡Ù†Ø§..."
                value={messageContent}
                onChange={(e) => setMessageContent(e.target.value)}
                rows={5}
                className="resize-none"
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setMessageDialog({ open: false, teacher: null })}>
              Ø¥Ù„ØºØ§Ø¡
            </Button>
            <Button onClick={handleSendMessage} disabled={!messageContent.trim() || isSending}>
              {isSending ? (
                <>
                  <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                  <span>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...</span>
                </>
              ) : (
                <>
                  <MessageSquare className="ml-2 h-4 w-4" />
                  <span>Ø¥Ø±Ø³Ø§Ù„</span>
                </>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/parent/children/[id]/subjects/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { MessageSquare, BookOpen, FileQuestion, TrendingUp, ArrowLeft, Loader2, Mail } from "lucide-react";
import Link from "next/link";
import { useToast } from "@/hooks/use-toast";

type Subject = {
  id: number;
  name: string;
  teacher: {
    id: string;
    firstName: string;
    lastName: string;
    allowMessaging: boolean;
  } | null;
  stats: {
    totalLessons: number;
    totalExercises: number;
    totalSubmissions: number;
    gradedSubmissions: number;
    averageScore: number;
  };
};

export default function ChildSubjectsPage({ params }: { params: { id: string } }) {
  const { toast } = useToast();
  const [child, setChild] = useState<any>(null);
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchSubjects();
  }, []);

  const fetchSubjects = async () => {
    try {
      setIsLoading(true);
      const response = await fetch(`/api/parents/children/${params.id}/subjects`);
      const result = await response.json();
      
      if (result.success) {
        setChild(result.data.child);
        setSubjects(result.data.subjects);
      }
    } catch (error) {
      console.error('Error fetching subjects:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleMessageTeacher = (teacherId: string, teacherName: string) => {
    window.location.href = `/messages?recipient=${teacherId}&name=${encodeURIComponent(teacherName)}`;
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-8">
      <div className="flex items-center justify-between">
        <div className="grid gap-1">
          <h1 className="text-3xl font-bold tracking-tight">
            Ù…ÙˆØ§Ø¯ {child?.firstName} {child?.lastName}
          </h1>
          <p className="text-muted-foreground">
            Ø¹Ø±Ø¶ ØªÙØ§ØµÙŠÙ„ Ø£Ø¯Ø§Ø¡ {child?.firstName} ÙÙŠ ÙƒÙ„ Ù…Ø§Ø¯Ø© ÙˆØ§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ†
          </p>
        </div>
        <Link href={`/dashboard/parent/children/${params.id}`}>
          <Button variant="outline">
            <ArrowLeft className="h-4 w-4" />
            <span className="mr-2">Ø§Ù„Ø±Ø¬ÙˆØ¹</span>
          </Button>
        </Link>
      </div>

      {subjects.length > 0 ? (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
          {subjects.map((subject) => {
            const teacherName = subject.teacher
              ? `${subject.teacher.firstName} ${subject.teacher.lastName}`
              : 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø¹Ù„Ù…';
            
            return (
              <Card key={subject.id} className="relative">
                <CardHeader>
                  <div className="flex items-start justify-between">
                    <div>
                      <CardTitle className="text-xl">{subject.name}</CardTitle>
                      {subject.teacher && (
                        <CardDescription className="mt-2 flex items-center gap-2">
                          <Avatar className="h-6 w-6">
                            <AvatarFallback className="text-xs">
                              {subject.teacher.firstName.charAt(0)}
                            </AvatarFallback>
                          </Avatar>
                          <span>{teacherName}</span>
                        </CardDescription>
                      )}
                    </div>
                    {subject.teacher && (
                      <div>
                        {subject.teacher.allowMessaging ? (
                          <Button
                            size="icon"
                            variant="default"
                            onClick={() => handleMessageTeacher(subject.teacher!.id, teacherName)}
                            title="Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù…Ø¹Ù„Ù…"
                          >
                            <MessageSquare className="h-4 w-4" />
                          </Button>
                        ) : (
                          <Button
                            size="icon"
                            variant="outline"
                            disabled
                            title="Ø§Ù„Ù…Ø¹Ù„Ù… ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„ØªÙˆØ§ØµÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹"
                          >
                            <Mail className="h-4 w-4 text-muted-foreground" />
                          </Button>
                        )}
                      </div>
                    )}
                  </div>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="grid grid-cols-2 gap-4">
                    <div className="flex items-center gap-2 p-3 bg-muted rounded-lg">
                      <BookOpen className="h-5 w-5 text-primary" />
                      <div>
                        <p className="text-2xl font-bold">{subject.stats.totalLessons}</p>
                        <p className="text-xs text-muted-foreground">Ø¯Ø±ÙˆØ³</p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2 p-3 bg-muted rounded-lg">
                      <FileQuestion className="h-5 w-5 text-primary" />
                      <div>
                        <p className="text-2xl font-bold">{subject.stats.totalExercises}</p>
                        <p className="text-xs text-muted-foreground">ØªÙ…Ø§Ø±ÙŠÙ†</p>
                      </div>
                    </div>
                  </div>

                  <div className="space-y-2">
                    <div className="flex justify-between items-center">
                      <span className="text-sm text-muted-foreground">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª</span>
                      <Badge variant="secondary">
                        {subject.stats.totalSubmissions}
                      </Badge>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-sm text-muted-foreground">ØªÙ… Ø§Ù„ØªØµØ­ÙŠØ­</span>
                      <Badge variant="default">
                        {subject.stats.gradedSubmissions}
                      </Badge>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-sm text-muted-foreground">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª</span>
                      <div className="flex items-center gap-2">
                        <TrendingUp className="h-4 w-4 text-primary" />
                        <span className="text-lg font-bold text-primary">
                          {subject.stats.averageScore}/10
                        </span>
                      </div>
                    </div>
                  </div>

                  {!subject.teacher?.allowMessaging && subject.teacher && (
                    <div className="text-xs text-muted-foreground bg-muted p-2 rounded">
                      ğŸ’¡ Ø§Ù„Ù…Ø¹Ù„Ù… ØºÙŠØ± Ù…ØªØ§Ø­ Ù„Ù„ØªÙˆØ§ØµÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹
                    </div>
                  )}
                </CardContent>
              </Card>
            );
          })}
        </div>
      ) : (
        <Card>
          <CardContent className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¯ Ù…Ø³Ø¬Ù„Ø© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø·Ø§Ù„Ø¨</p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/dashboard/parent/children/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { TrendingUp, BookCheck, Target, ArrowLeft, Loader2 } from "lucide-react";
import Link from "next/link";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";

type Child = {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    image: string | null;
    level: {
        id: number;
        name: string;
        stage: {
            id: number;
            name: string;
        };
    } | null;
    stats: {
        completedLessons: number;
        averageScore: number;
        submissionCount: number;
    };
};

export default function MyChildrenPage() {
    const [children, setChildren] = useState<Child[]>([]);
    const [isLoading, setIsLoading] = useState(true);

    useEffect(() => {
        fetchChildren();
    }, []);

    const fetchChildren = async () => {
        try {
            setIsLoading(true);
            const response = await fetch('/api/parents/children');
            const result = await response.json();
            if (result.success) {
                setChildren(result.data.children);
            }
        } catch (error) {
            console.error('Error fetching children:', error);
        } finally {
            setIsLoading(false);
        }
    };

    if (isLoading) {
        return (
            <div className="flex items-center justify-center min-h-[400px]">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
        );
    }

    return (
        <div className="flex flex-col gap-8">
            <div className="flex items-center justify-between">
                <div className="grid gap-1">
                    <h1 className="text-3xl font-bold tracking-tight">Ø£Ø¨Ù†Ø§Ø¦ÙŠ</h1>
                    <p className="text-muted-foreground">
                        ØªØ§Ø¨Ø¹ ØªÙ‚Ø¯Ù… Ø£Ø¨Ù†Ø§Ø¦Ùƒ Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø¨Ø­Ø³Ø§Ø¨Ùƒ.
                    </p>
                </div>
            </div>

            {children.length > 0 ? (
                <div className="grid gap-6 md:grid-cols-1 lg:grid-cols-2">
                    {children.map(child => {
                        const childName = `${child.firstName} ${child.lastName}`;
                        const childInitial = child.firstName.charAt(0);
                        return (
                             <Card key={child.id}>
                                <CardHeader className="flex flex-row items-center gap-4">
                                    <Avatar className="h-16 w-16">
                                        <AvatarImage src={child.image || ''} alt={childName} />
                                        <AvatarFallback>{childInitial}</AvatarFallback>
                                    </Avatar>
                                    <div className="grid gap-1">
                                        <CardTitle>{childName}</CardTitle>
                                        <CardDescription>{child.email}</CardDescription>
                                    </div>
                                </CardHeader>
                                <CardContent className="grid grid-cols-3 gap-4 text-center">
                                    <div className="p-3 bg-muted rounded-md">
                                        <BookCheck className="h-6 w-6 mx-auto mb-2 text-primary" />
                                        <p className="text-xl font-bold">{child.stats.completedLessons}</p>
                                        <p className="text-xs text-muted-foreground">Ø¯Ø±ÙˆØ³ Ù…ÙƒØªÙ…Ù„Ø©</p>
                                    </div>
                                    <div className="p-3 bg-muted rounded-md">
                                        <Target className="h-6 w-6 mx-auto mb-2 text-primary" />
                                        <p className="text-xl font-bold">{child.stats.averageScore}/10</p>
                                        <p className="text-xs text-muted-foreground">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª</p>
                                    </div>
                                    <div className="p-3 bg-muted rounded-md">
                                        <TrendingUp className="h-6 w-6 mx-auto mb-2 text-primary" />
                                        <p className="text-xl font-bold">{child.stats.submissionCount}</p>
                                        <p className="text-xs text-muted-foreground">ØªÙ…Ø§Ø±ÙŠÙ† Ù…Ø­Ù„ÙˆÙ„Ø©</p>
                                    </div>
                                </CardContent>
                                <CardFooter>
                                     <Link href={`/dashboard/parent/children/${child.id}`} className="w-full" passHref>
                                        <Button className="w-full">
                                            <span>Ø¹Ø±Ø¶ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…ÙØµÙ„</span>
                                            <ArrowLeft className="mr-2 h-4 w-4" />
                                        </Button>
                                     </Link>
                                </CardFooter>
                            </Card>
                        )
                    })}
                </div>
            ) : (
                <Card className="flex flex-col items-center justify-center py-20">
                    <CardHeader>
                        <CardTitle>Ù„Ù… ÙŠØªÙ… Ø±Ø¨Ø· Ø£ÙŠ Ø£Ø¨Ù†Ø§Ø¡</CardTitle>
                        <CardDescription>Ø§Ø³ØªØ®Ø¯Ù… ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù„Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ø§Øª Ø£Ø¨Ù†Ø§Ø¦Ùƒ.</CardDescription>
                    </CardHeader>
                </Card>
            )}
        </div>
    );
}


// ==========================================
// FILE: src/app/(main)/dashboard/parent/reports/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Bar, BarChart, ResponsiveContainer, XAxis, YAxis, Tooltip, PieChart, Pie, Cell, Legend } from "recharts";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Loader2 } from "lucide-react";

type Child = {
  id: string;
  firstName: string;
  lastName: string;
  image: string | null;
  stats: {
    averageScore: number;
  };
};

export default function ReportsPage() {
  const [children, setChildren] = useState<Child[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchChildren();
  }, []);

  const fetchChildren = async () => {
    try {
      setIsLoading(true);
      const response = await fetch('/api/parents/children');
      const result = await response.json();
      if (result.success) {
        setChildren(result.data.children);
      }
    } catch (error) {
      console.error('Error fetching children:', error);
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  const childrenAverageScores = children.map(child => ({
    name: child.firstName,
    averageScore: child.stats.averageScore,
  }));

  const getScoreDistribution = (child: Child) => {
    const score = child.stats.averageScore;
    // Simplified distribution based on average
    if (score >= 8) {
      return [
        { name: 'Ù…Ù…ØªØ§Ø² (8-10)', value: 70, color: 'hsl(var(--chart-2))' },
        { name: 'Ø¬ÙŠØ¯ (5-7)', value: 25, color: 'hsl(var(--chart-4))' },
        { name: 'Ø¶Ø¹ÙŠÙ (0-4)', value: 5, color: 'hsl(var(--destructive))' },
      ];
    } else if (score >= 5) {
      return [
        { name: 'Ù…Ù…ØªØ§Ø² (8-10)', value: 30, color: 'hsl(var(--chart-2))' },
        { name: 'Ø¬ÙŠØ¯ (5-7)', value: 60, color: 'hsl(var(--chart-4))' },
        { name: 'Ø¶Ø¹ÙŠÙ (0-4)', value: 10, color: 'hsl(var(--destructive))' },
      ];
    } else {
      return [
        { name: 'Ù…Ù…ØªØ§Ø² (8-10)', value: 10, color: 'hsl(var(--chart-2))' },
        { name: 'Ø¬ÙŠØ¯ (5-7)', value: 30, color: 'hsl(var(--chart-4))' },
        { name: 'Ø¶Ø¹ÙŠÙ (0-4)', value: 60, color: 'hsl(var(--destructive))' },
      ];
    }
  };

  return (
    <div className="flex flex-col gap-8">
      <div className="grid gap-1">
        <h1 className="text-3xl font-bold tracking-tight">ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ø£Ø¯Ø§Ø¡</h1>
        <p className="text-muted-foreground">
          Ù†Ø¸Ø±Ø© Ù…Ù‚Ø§Ø±Ù†Ø© Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø£Ø¨Ù†Ø§Ø¦Ùƒ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ.
        </p>
      </div>

      {childrenAverageScores.length > 0 ? (
        <>
          <Card>
            <CardHeader>
              <CardTitle>Ù…Ù‚Ø§Ø±Ù†Ø© Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª</CardTitle>
              <CardDescription>
                Ù…Ù‚Ø§Ø±Ù†Ø© Ø¨ÙŠÙ† Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª Ø§Ù„ÙƒÙ„ÙŠ Ù„ÙƒÙ„ Ø§Ø¨Ù†.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={childrenAverageScores}>
                  <XAxis dataKey="name" stroke="hsl(var(--muted-foreground))" fontSize={12} tickLine={false} axisLine={false} />
                  <YAxis stroke="hsl(var(--muted-foreground))" fontSize={12} tickFormatter={(value) => `${value}/10`} domain={[0, 10]} />
                  <Tooltip
                    cursor={{ fill: 'hsl(var(--accent) / 0.2)' }}
                    content={({ active, payload, label }) => {
                      if (active && payload && payload.length) {
                        return (
                          <div className="rounded-lg border bg-background p-2 shadow-sm">
                            <p className="font-bold">{label}</p>
                            <p className="text-sm text-primary">{`Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª: ${payload[0].value}/10`}</p>
                          </div>
                        )
                      }
                      return null
                    }}
                  />
                  <Bar dataKey="averageScore" fill="hsl(var(--primary))" radius={[4, 4, 0, 0]} />
                </BarChart>
              </ResponsiveContainer>
            </CardContent>
          </Card>

          <div className="grid gap-6 md:grid-cols-1 lg:grid-cols-2">
            {children.map(child => {
              const scoreDistribution = getScoreDistribution(child);
              return (
                <Card key={child.id}>
                  <CardHeader className="flex flex-row items-center gap-4">
                    <Avatar className="h-12 w-12">
                      <AvatarImage src={child.image || ''} alt={child.firstName} />
                      <AvatarFallback>{child.firstName.charAt(0)}</AvatarFallback>
                    </Avatar>
                    <div>
                      <CardTitle>ØªÙˆØ²ÙŠØ¹ Ø¯Ø±Ø¬Ø§Øª {child.firstName}</CardTitle>
                      <CardDescription>Ù†Ø¸Ø±Ø© Ø¹Ù„Ù‰ ØªÙˆØ²ÙŠØ¹ Ø¯Ø±Ø¬Ø§ØªÙ‡.</CardDescription>
                    </div>
                  </CardHeader>
                  <CardContent>
                    {child.stats.averageScore > 0 ? (
                      <ResponsiveContainer width="100%" height={250}>
                        <PieChart>
                          <Pie data={scoreDistribution} dataKey="value" nameKey="name" cx="50%" cy="50%" outerRadius={80} label>
                            {scoreDistribution.map((entry, index) => (
                              <Cell key={`cell-${index}`} fill={entry.color} />
                            ))}
                          </Pie>
                          <Tooltip content={({ active, payload }) => {
                            if (active && payload && payload.length) {
                              return (
                                <div className="rounded-lg border bg-background p-2 shadow-sm">
                                  <p className="text-sm">{`${payload[0].name}: ${payload[0].value}%`}</p>
                                </div>
                              )
                            }
                            return null
                          }}
                          />
                          <Legend />
                        </PieChart>
                      </ResponsiveContainer>
                    ) : (
                      <p className="text-muted-foreground text-center py-10">
                        Ù„Ù… ÙŠÙ‚Ù… {child.firstName} Ø¨Ø­Ù„ Ø£ÙŠ ØªÙ…Ø§Ø±ÙŠÙ† Ø¨Ø¹Ø¯.
                      </p>
                    )}
                  </CardContent>
                </Card>
              )
            })}
          </div>
        </>
      ) : (
        <Card>
          <CardContent className="flex flex-col items-center justify-center py-12">
            <p className="text-muted-foreground">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø£Ø¨Ù†Ø§Ø¡ Ù…Ø±ØªØ¨Ø·ÙˆÙ† Ù„Ø¹Ø±Ø¶ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±</p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/lessons/[id]/page.tsx
// ==========================================

'use client';

import { useEffect, useState } from "react";
import { notFound } from "next/navigation";
import { useSession } from "next-auth/react";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { FileQuestion, Loader2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import MainExercise from "./components/MainExercise";
import SupportWithResultsExercise from "./components/SupportWithResultsExercise";
import SupportOnlyExercise from "./components/SupportOnlyExercise";

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Google Drive Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¥Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· Proxy
const getProxiedUrl = (url: string) => {
  if (!url) return "";
  
  // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù† Ø£ÙŠ Ù„Ø§Ø­Ù‚Ø§Øª ÙˆÙ‡Ù…ÙŠØ© Ù‚Ø¯ ØªÙƒÙˆÙ† Ø£Ø¶ÙŠÙØª Ø³Ø§Ø¨Ù‚Ø§Ù‹
  const cleanUrl = url.replace('&t=image.jpg', '');
  if (cleanUrl.startsWith('/api/images/proxy')) return cleanUrl;
  
  const idMatch = url.match(/id=([a-zA-Z0-9_-]+)/) || url.match(/\/d\/([a-zA-Z0-9_-]+)/);
  if ((url.includes('drive.google.com') || url.includes('googleusercontent.com')) && idMatch && idMatch[1]) {
    return `/api/images/proxy?fileId=${idMatch[1]}`;
  }
  
  return url;
};

// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· PDF Ø¥Ù„Ù‰ ØµÙŠØºØ© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© (Preview) Ù„Ø¶Ù…Ø§Ù† Ø¹Ù…Ù„Ù‡Ø§ Ø¯Ø§Ø®Ù„ iframe
const getPdfPreviewUrl = (url: string) => {
  if (!url) return "";
  if (url.includes('/preview')) return url;
  if (url.includes('/view')) return url.replace('/view', '/preview');
  
  const idMatch = url.match(/\/d\/([a-zA-Z0-9_-]+)/) || url.match(/id=([a-zA-Z0-9_-]+)/);
  if (idMatch && idMatch[1]) {
    return `https://drive.google.com/file/d/${idMatch[1]}/preview`;
  }
  return url;
};

interface Lesson {
  id: number;
  title: string;
  content: string;
  videoUrl?: string;
  pdfUrl?: string;
  imageUrl?: string;
  subject?: {
    id: number;
    name: string;
  };
  level?: {
    id: number;
    name: string;
  };
  author?: {
    id: string;
    firstName: string;
    lastName: string;
  };
}

interface Exercise {
  id: number;
  type: 'main' | 'support_with_results' | 'support_only';
  question?: string;
  questionRichContent?: string;
  questionFileUrl?: string;
  modelAnswer?: string;
  modelAnswerImage?: string;
  expectedResults?: any;
  maxScore?: number;
  allowRetry?: boolean;
  maxAttempts?: number;
  lessonId: number;
}

export default function LessonDetailPage({ params }: { params: Promise<{ id: string }> }) {
  const { data: session } = useSession();
  const [lessonId, setLessonId] = useState<string>('');
  const [lesson, setLesson] = useState<Lesson | null>(null);
  const [exercises, setExercises] = useState<Exercise[]>([]);
  const [loading, setLoading] = useState(true);
  const [notFoundError, setNotFoundError] = useState(false);
  const [imageError, setImageError] = useState(false);
  const [currentImageSrc, setCurrentImageSrc] = useState<string>("");

  useEffect(() => {
    const fetchLessonData = async () => {
      const resolvedParams = await params;
      const id = resolvedParams.id;
      setLessonId(id);
      
      try {
        setLoading(true);
        
        // Fetch lesson details
        const lessonRes = await fetch(`/api/lessons/${id}`);
        const lessonData = await lessonRes.json();
        
        if (!lessonData.success) {
          setNotFoundError(true);
          return;
        }
        
        setLesson(lessonData.data);
        if (lessonData.data.imageUrl) {
          setCurrentImageSrc(getProxiedUrl(lessonData.data.imageUrl));
        }
        
        // Fetch exercises for this lesson
        const exercisesRes = await fetch(`/api/exercises?lessonId=${id}`);
        const exercisesData = await exercisesRes.json();
        
        if (exercisesData.success) {
          const exercisesList = exercisesData.data?.exercises || exercisesData.data || [];
          setExercises(Array.isArray(exercisesList) ? exercisesList : []);
        }
      } catch (error) {
        console.error('Error fetching lesson:', error);
        setNotFoundError(true);
      } finally {
        setLoading(false);
      }
    };

    fetchLessonData();
  }, [params]);

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (notFoundError || !lesson) {
    return notFound();
  }

  const handleImageError = () => {
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù„Ù Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ø­Ø§Ù„ÙŠ
    let fileId = null;
    
    try {
      // Ø§Ø³ØªØ®Ø¯Ø§Ù… URL API Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø´ÙƒÙ„ Ø£Ø¯Ù‚ ÙˆÙ…ÙˆØ«ÙˆÙ‚
      // Ù†Ø³ØªØ®Ø¯Ù… base ÙˆÙ‡Ù…ÙŠ Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù†Ø³Ø¨ÙŠØ©
      const urlObj = new URL(currentImageSrc, 'http://localhost');
      fileId = urlObj.searchParams.get('fileId') || urlObj.searchParams.get('id');
    } catch (e) {
      // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¨Ø¯ÙŠÙ„Ø© ÙÙŠ Ø­Ø§Ù„ ÙØ´Ù„ URL parsing
      const idMatch = currentImageSrc.match(/[\?&](fileId|id)=([^&]+)/);
      if (idMatch) fileId = idMatch[2];
    }

    if (!fileId) {
      setImageError(true);
      return;
    }

    // Ø§Ù„ØªØ³Ù„Ø³Ù„: Proxy -> Direct (uc) -> Thumbnail
    if (currentImageSrc.includes('/api/images/proxy')) {
      console.warn("Proxy failed, falling back to direct Google Drive URL");
      setCurrentImageSrc(`https://drive.google.com/uc?export=view&id=${fileId}`);
    } else if (currentImageSrc.includes('uc?export=view')) {
      console.warn("Direct URL failed, falling back to Thumbnail URL");
      // Ø±Ø§Ø¨Ø· Thumbnail ÙŠØ¹Ù…Ù„ ØºØ§Ù„Ø¨Ø§Ù‹ Ø­ØªÙ‰ Ù„Ùˆ ÙØ´Ù„Øª Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø£Ø®Ø±Ù‰
      setCurrentImageSrc(`https://drive.google.com/thumbnail?id=${fileId}&sz=w1920`);
    } else {
      // Ø¥Ø°Ø§ ÙØ´Ù„ ÙƒÙ„ Ø´ÙŠØ¡ (Ø¨Ù…Ø§ ÙÙŠ Ø°Ù„Ùƒ Thumbnail)
      console.error("All image loading attempts failed");
      setImageError(true);
    }
  };

  return (
    <div className="max-w-4xl mx-auto">
      <div className="mb-8">
        {lesson.subject && (
          <Badge variant="secondary" className="mb-2">{lesson.subject.name}</Badge>
        )}
        <h1 className="text-4xl font-bold tracking-tight">{lesson.title}</h1>
        {lesson.author && (
          <p className="text-muted-foreground mt-2">
            Ø§Ù„Ø£Ø³ØªØ§Ø°: {lesson.author.firstName} {lesson.author.lastName}
          </p>
        )}
      </div>

      <Card className="mb-8 overflow-hidden">
        {lesson.videoUrl && (
          <div className="aspect-video">
            <iframe
              className="w-full h-full"
              src={lesson.videoUrl.replace('watch?v=', 'embed/')}
              title={lesson.title}
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
              allowFullScreen
            ></iframe>
          </div>
        )}
        <CardHeader>
          <CardTitle>Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø³</CardTitle>
        </CardHeader>
        <CardContent>
          <div 
            className="prose prose-lg max-w-none dark:prose-invert text-foreground" 
            dangerouslySetInnerHTML={{ __html: lesson.content }}
          />
        </CardContent>
      </Card>

      {/* Ø¹Ø±Ø¶ ØµÙˆØ±Ø© Ø§Ù„Ø¯Ø±Ø³ */}
      {lesson.imageUrl && (
        <Card className="mb-8 overflow-hidden">
          <div className="relative w-full h-[400px] bg-muted flex items-center justify-center">
            {!imageError ? (
              <img
                src={currentImageSrc}
                alt={lesson.title}
                className="w-full h-full object-cover"
                onError={handleImageError}
                referrerPolicy="no-referrer"
              />
            ) : (
              <div className="flex flex-col items-center justify-center p-4 text-muted-foreground">
                <FileQuestion className="h-10 w-10 mb-2 opacity-50" />
                <p className="text-sm">ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©</p>
                <code className="text-[10px] mt-2 bg-black/5 p-1 rounded max-w-full break-all dir-ltr">{currentImageSrc}</code>
              </div>
            )}
          </div>
        </Card>
      )}

      {lesson.pdfUrl && (
        <Card className="mb-8 overflow-hidden" id="pdf-viewer-card">
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <span>Ù…Ù„Ù PDF Ø§Ù„Ù…Ø±ÙÙ‚</span>
              <div className="flex gap-2">
                <Link href={lesson.pdfUrl} target="_blank" passHref>
                  <Button variant="outline" size="sm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="ml-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
                    <span>ØªØ­Ù…ÙŠÙ„</span>
                  </Button>
                </Link>
                <Link href={lesson.pdfUrl} target="_blank" passHref>
                  <Button variant="outline" size="sm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="ml-2"><path d="M15 3h6v6"/><path d="M10 14 21 3"/><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/></svg>
                    <span>ÙØªØ­ ÙÙŠ Ù†Ø§ÙØ°Ø© Ø¬Ø¯ÙŠØ¯Ø©</span>
                  </Button>
                </Link>
              </div>
            </CardTitle>
          </CardHeader>
          <CardContent className="p-0">
            <div className="w-full h-[800px]">
              <iframe
                src={getPdfPreviewUrl(lesson.pdfUrl)}
                className="w-full h-full border-0"
                title="PDF Viewer"
              />
            </div>
          </CardContent>
        </Card>
      )}
      
      {exercises.length > 0 && (
        <>
          <Separator className="my-8" />
          
          <div>
            <h2 className="text-3xl font-bold mb-6 flex items-center gap-2">
              <FileQuestion className="text-primary"/>
              ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ø¯Ø±Ø³
              <Badge variant="secondary" className="mr-auto">
                {exercises.length} {exercises.length === 1 ? 'ØªÙ…Ø±ÙŠÙ†' : 'ØªÙ…Ø±ÙŠÙ†'}
              </Badge>
            </h2>
            
            <Tabs defaultValue="0" className="w-full">
              <TabsList className="w-full justify-start flex-wrap h-auto">
                {exercises.map((exercise, index) => (
                  <TabsTrigger key={exercise.id} value={String(index)} className="gap-2">
                    <span>ØªÙ…Ø±ÙŠÙ† {index + 1}</span>
                    <Badge 
                      variant={
                        exercise.type === 'main' 
                          ? 'default' 
                          : exercise.type === 'support_with_results' 
                          ? 'secondary' 
                          : 'outline'
                      }
                      className="text-xs"
                    >
                      {exercise.type === 'main' 
                        ? 'Ø±Ø¦ÙŠØ³ÙŠ' 
                        : exercise.type === 'support_with_results' 
                        ? 'Ø¯Ø¹Ù…+Ù†ØªØ§Ø¦Ø¬' 
                        : 'Ø¯Ø¹Ù…'}
                    </Badge>
                  </TabsTrigger>
                ))}
              </TabsList>

              {exercises.map((exercise, index) => (
                <TabsContent key={exercise.id} value={String(index)} className="mt-6">
                  {exercise.type === 'main' && (
                    <MainExercise 
                      exercise={exercise}
                      studentId={session?.user?.id ? String(session.user.id) : ''}
                    />
                  )}
                  {exercise.type === 'support_with_results' && (
                    <SupportWithResultsExercise exercise={exercise} />
                  )}
                  {exercise.type === 'support_only' && (
                    <SupportOnlyExercise exercise={exercise} />
                  )}
                </TabsContent>
              ))}
            </Tabs>
          </div>
        </>
      )}
      
      {exercises.length === 0 && (
        <Card>
          <CardContent className="text-center py-12">
            <FileQuestion className="h-12 w-12 mx-auto mb-4 text-muted-foreground" />
            <p className="text-muted-foreground">Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ…Ø§Ø±ÙŠÙ† Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¯Ø±Ø³ Ø¨Ø¹Ø¯</p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/lessons/[id]/components/ExerciseSubmissionForm.tsx
// ==========================================

'use client';

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Loader2, Upload, Send } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { Badge } from "@/components/ui/badge";

interface ExerciseSubmissionFormProps {
  exercise: {
    id: number;
    question: string;
    questionFileUrl?: string;
    maxScore?: number;
  };
  onSubmissionComplete?: () => void;
}

export default function ExerciseSubmissionForm({ exercise, onSubmissionComplete }: ExerciseSubmissionFormProps) {
  const { toast } = useToast();
  const [answer, setAnswer] = useState('');
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [imagePreview, setImagePreview] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isEvaluating, setIsEvaluating] = useState(false);
  const [submission, setSubmission] = useState<any>(null);

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setImageFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setImagePreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleSubmit = async () => {
    if (!answer.trim() && !imageFile) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø¥Ø¬Ø§Ø¨Ø© Ø£Ùˆ Ø±ÙØ¹ ØµÙˆØ±Ø©",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);
    try {
      const formData = new FormData();
      formData.append('exerciseId', exercise.id.toString());
      formData.append('answerText', answer);
      if (imageFile) {
        formData.append('answerImage', imageFile);
      }

      const response = await fetch('/api/submissions', {
        method: 'POST',
        body: formData,
      });

      const result = await response.json();

      if (result.success) {
        setSubmission(result.data);
        toast({
          title: "ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„",
          description: "ØªÙ… Ø­ÙØ¸ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­",
        });
      } else {
        toast({
          title: "ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„",
          description: result.error || "Ø­Ø¯Ø« Ø®Ø·Ø£",
          variant: "destructive",
        });
      }
    } catch (error) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleEvaluate = async () => {
    if (!submission) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ¬Ø¨ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø£ÙˆÙ„Ø§Ù‹",
        variant: "destructive",
      });
      return;
    }

    setIsEvaluating(true);
    try {
      const response = await fetch(`/api/submissions/${submission.id}/evaluate`, {
        method: 'POST',
      });

      const result = await response.json();

      if (result.success) {
        setSubmission(result.data);
        toast({
          title: "ØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ…",
          description: `Ø¯Ø±Ø¬ØªÙƒ: ${result.data.score}/${exercise.maxScore || 10}`,
        });
        if (onSubmissionComplete) {
          onSubmissionComplete();
        }
      } else {
        toast({
          title: "ÙØ´Ù„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…",
          description: result.error || "Ø­Ø¯Ø« Ø®Ø·Ø£",
          variant: "destructive",
        });
      }
    } catch (error) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…",
        variant: "destructive",
      });
    } finally {
      setIsEvaluating(false);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          <span>Ø¥Ø¬Ø§Ø¨ØªÙƒ</span>
          {submission && (
            <Badge variant={submission.score >= (exercise.maxScore || 10) * 0.6 ? 'default' : 'destructive'}>
              {submission.score}/{exercise.maxScore || 10}
            </Badge>
          )}
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="space-y-2">
          <Label htmlFor="answer">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†ØµÙŠØ©</Label>
          <Textarea
            id="answer"
            placeholder="Ø§ÙƒØªØ¨ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ù‡Ù†Ø§..."
            value={answer}
            onChange={(e) => setAnswer(e.target.value)}
            rows={6}
            disabled={!!submission}
          />
        </div>

        <div className="space-y-2">
          <Label htmlFor="image">Ø£Ùˆ Ø§Ø±ÙØ¹ ØµÙˆØ±Ø© Ù„Ù„Ø­Ù„</Label>
          <Input
            id="image"
            type="file"
            accept="image/*"
            onChange={handleImageChange}
            disabled={!!submission}
          />
          {imagePreview && (
            <div className="mt-2">
              <img
                src={imagePreview}
                alt="Ù…Ø¹Ø§ÙŠÙ†Ø©"
                className="max-w-full h-auto max-h-64 rounded-lg border"
              />
            </div>
          )}
        </div>

        {submission?.feedback && (
          <Card className="bg-muted">
            <CardHeader>
              <CardTitle className="text-sm">Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-sm whitespace-pre-wrap">{submission.feedback}</p>
            </CardContent>
          </Card>
        )}

        <div className="flex gap-2">
          {!submission ? (
            <Button onClick={handleSubmit} disabled={isSubmitting} className="flex-1">
              {isSubmitting && <Loader2 className="ml-2 h-4 w-4 animate-spin" />}
              <Send className="ml-2 h-4 w-4" />
              Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
            </Button>
          ) : (
            <Button onClick={handleEvaluate} disabled={isEvaluating || !!submission.score} className="flex-1">
              {isEvaluating && <Loader2 className="ml-2 h-4 w-4 animate-spin" />}
              {submission.score ? 'ØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ…' : 'ØªÙ‚ÙŠÙŠÙ… Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ'}
            </Button>
          )}
        </div>
      </CardContent>
    </Card>
  );
}


// ==========================================
// FILE: src/app/(main)/lessons/[id]/components/MainExercise.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Loader2, Send, CheckCircle2, XCircle, RotateCcw } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { Badge } from "@/components/ui/badge";
import { RichTextEditor } from "@/components/editor";
import { Input } from "@/components/ui/input";
import { Alert, AlertDescription } from "@/components/ui/alert";
import MathContent from "@/components/MathContent";

interface MainExerciseProps {
  exercise: {
    id: number;
    questionRichContent?: string;
    question?: string;
    modelAnswer?: string;
    modelAnswerImage?: string;
    maxScore?: number;
    allowRetry?: boolean;
    maxAttempts?: number;
  };
  studentId: string;
  onSubmissionComplete?: () => void;
}

export default function MainExercise({ exercise, studentId, onSubmissionComplete }: MainExerciseProps) {
  const { toast } = useToast();
  const [answer, setAnswer] = useState('');
  const [answerImage, setAnswerImage] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submission, setSubmission] = useState<any>(null);
  const [attempts, setAttempts] = useState<number>(0);
  const [bestScore, setBestScore] = useState<number | null>(null);

  useEffect(() => {
    fetchSubmissionHistory();
  }, [exercise.id]);

  const fetchSubmissionHistory = async () => {
    try {
      const response = await fetch(`/api/submissions?exerciseId=${exercise.id}&studentId=${studentId}`);
      const result = await response.json();
      
      if (result.success && result.submissions?.length > 0) {
        const sorted = result.submissions.sort((a: any, b: any) => 
          (b.aiScore || 0) - (a.aiScore || 0)
        );
        setAttempts(result.submissions.length);
        setBestScore(sorted[0]?.aiScore || null);
        setSubmission(sorted[0]);
      }
    } catch (error) {
      console.error('Error fetching submission history:', error);
    }
  };

  const handleSubmit = async () => {
    if (!answer.trim() && !answerImage) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø¥Ø¬Ø§Ø¨Ø© Ø£Ùˆ Ø¥Ø¶Ø§ÙØ© ØµÙˆØ±Ø©",
        variant: "destructive",
      });
      return;
    }

    if (exercise.maxAttempts && attempts >= exercise.maxAttempts) {
      toast({
        title: "ØªØ¬Ø§ÙˆØ²Øª Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰",
        description: `Ù„Ù‚Ø¯ Ø§Ø³ØªØ®Ø¯Ù…Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø© (${exercise.maxAttempts})`,
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);
    try {
      const submissionData = {
        exerciseId: exercise.id,
        answerRichContent: answer,
        submissionFileUrl: answerImage || null,
        attemptNumber: attempts + 1,
      };

      const response = await fetch('/api/submissions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(submissionData),
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: "ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„",
          description: "Ø¬Ø§Ø±Ù ØªØµØ­ÙŠØ­ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...",
        });

        // Ø·Ù„Ø¨ Ø§Ù„ØªØµØ­ÙŠØ­ Ø¨Ø§Ù„Ù€ AI
        const aiResponse = await fetch(`/api/submissions/${result.data.id}/evaluate`, {
          method: 'POST',
        });

        const aiResult = await aiResponse.json();

        if (aiResult.success) {
          setSubmission(aiResult.data);
          setAttempts(attempts + 1);
          
          if (!bestScore || (aiResult.data.aiScore > bestScore)) {
            setBestScore(aiResult.data.aiScore);
          }

          toast({
            title: "ØªÙ… Ø§Ù„ØªØµØ­ÙŠØ­",
            description: `Ø­ØµÙ„Øª Ø¹Ù„Ù‰ ${aiResult.data.aiScore} Ù…Ù† ${exercise.maxScore}`,
          });

          if (onSubmissionComplete) {
            onSubmissionComplete();
          }
        }
      } else {
        throw new Error(result.error);
      }
    } catch (error: any) {
      toast({
        title: "Ø®Ø·Ø£",
        description: error.message || "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleRetry = () => {
    setAnswer('');
    setAnswerImage('');
    setSubmission(null);
  };

  const canRetry = exercise.allowRetry && 
                   (!exercise.maxAttempts || attempts < exercise.maxAttempts);

  return (
    <div className="space-y-6">
      {/* Ø§Ù„Ø³Ø¤Ø§Ù„ */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <CardTitle>Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ</CardTitle>
              <CardDescription>
                Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ù‚ØµÙˆÙ‰: {exercise.maxScore || 20} - Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª: {attempts}/{exercise.maxAttempts || 'âˆ'}
              </CardDescription>
            </div>
            {bestScore !== null && (
              <Badge variant="default" className="text-lg px-4 py-2">
                Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: {bestScore}
              </Badge>
            )}
          </div>
        </CardHeader>
        <CardContent>
          {exercise.questionRichContent ? (
            <MathContent content={exercise.questionRichContent} />
          ) : (
            <p className="whitespace-pre-wrap">{exercise.question}</p>
          )}
        </CardContent>
      </Card>

      {/* Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© */}
      {!submission || canRetry ? (
        <Card>
          <CardHeader>
            <CardTitle>Ø¥Ø¬Ø§Ø¨ØªÙƒ</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <RichTextEditor
              content={answer}
              onChange={setAnswer}
              placeholder="Ø§ÙƒØªØ¨ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ù‡Ù†Ø§..."
            />

            <div className="space-y-2">
              <label className="text-sm font-medium">Ø±Ø§Ø¨Ø· ØµÙˆØ±Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
              <Input
                type="url"
                placeholder="https://example.com/answer.jpg"
                value={answerImage}
                onChange={(e) => setAnswerImage(e.target.value)}
              />
            </div>

            <div className="flex gap-3">
              <Button 
                onClick={handleSubmit} 
                disabled={isSubmitting}
                className="flex-1"
              >
                {isSubmitting ? (
                  <>
                    <Loader2 className="ml-2 h-4 w-4 animate-spin" />
                    Ø¬Ø§Ø±Ù Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...
                  </>
                ) : (
                  <>
                    <Send className="ml-2 h-4 w-4" />
                    Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
                  </>
                )}
              </Button>

              {submission && canRetry && (
                <Button 
                  variant="outline" 
                  onClick={handleRetry}
                >
                  <RotateCcw className="ml-2 h-4 w-4" />
                  Ù…Ø­Ø§ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©
                </Button>
              )}
            </div>

            {!canRetry && attempts > 0 && (
              <Alert>
                <AlertDescription>
                  Ù„Ù‚Ø¯ Ø§Ø³ØªØ®Ø¯Ù…Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©. Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø© Ù„Ùƒ: {bestScore}
                </AlertDescription>
              </Alert>
            )}
          </CardContent>
        </Card>
      ) : null}

      {/* Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØµØ­ÙŠØ­ */}
      {submission && (
        <Card className="border-primary">
          <CardHeader>
            <div className="flex items-center justify-between">
              <CardTitle>Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØµØ­ÙŠØ­</CardTitle>
              <Badge 
                variant={submission.aiScore >= (exercise.maxScore || 20) * 0.7 ? "default" : "destructive"}
                className="text-lg px-4 py-2"
              >
                {submission.aiScore} / {exercise.maxScore || 20}
              </Badge>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            {/* Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ© */}
            {exercise.modelAnswer && (
              <div className="space-y-2">
                <h4 className="font-semibold text-lg">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©:</h4>
                <div className="bg-blue-50 dark:bg-blue-950 p-4 rounded-lg border border-blue-200 dark:border-blue-800">
                  <MathContent content={exercise.modelAnswer} />
                </div>
              </div>
            )}

            {submission.aiFeedback && (
              <div className="space-y-2">
                <h4 className="font-semibold">Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ:</h4>
                <div className="bg-muted p-4 rounded-lg">
                  <p className="whitespace-pre-wrap">{submission.aiFeedback}</p>
                </div>
              </div>
            )}

            {canRetry && (
              <Button 
                variant="outline" 
                onClick={handleRetry}
                className="w-full"
              >
                <RotateCcw className="ml-2 h-4 w-4" />
                Ù…Ø­Ø§ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù†ØªÙŠØ¬Ø©
              </Button>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/lessons/[id]/components/ExerciseSubmission.tsx
// ==========================================

"use client";

import { useFormState, useFormStatus } from "react-dom";
import { handleSubmission, type SubmissionState } from "@/lib/actions";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { AlertCircle, CheckCircle2, Lightbulb, Loader2, Paperclip, Send, X } from "lucide-react";
import type { Exercise } from "@/lib/types";
import { Textarea } from "@/components/ui/textarea";
import { Input } from "@/components/ui/input";
import { useState, useRef } from "react";
import { Label } from "@/components/ui/label";

const initialState: SubmissionState = {};

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <Button type="submit" disabled={pending}>
      {pending ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
          <span>Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…...</span>
        </>
      ) : (
        <>
          <Send className="mr-2 h-4 w-4" />
          <span>Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©</span>
        </>
      )}
    </Button>
  );
}

export default function ExerciseSubmission({ exercise }: { exercise: Exercise }) {
  const [state, formAction] = useFormState(handleSubmission, initialState);
  const [fileName, setFileName] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setFileName(file.name);
    } else {
      setFileName(null);
    }
  };

  const handleRemoveFile = () => {
    setFileName(null);
    if(fileInputRef.current) {
        fileInputRef.current.value = "";
    }
  }

  return (
    <div className="space-y-6">
      <form action={formAction} className="space-y-4">
        <input type="hidden" name="exerciseId" value={exercise.id} />
        
        <div>
          <Label htmlFor="answer-textarea">Ø§ÙƒØªØ¨ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ù‡Ù†Ø§ Ø£Ùˆ Ø§Ø±ÙÙ‚ Ù…Ù„ÙÙ‹Ø§</Label>
          <Textarea
            id="answer-textarea"
            name="answer"
            placeholder="Ø§ÙƒØªØ¨ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ù‡Ù†Ø§..."
            rows={5}
            className="mt-2"
          />
        </div>

        <div className="space-y-2">
            <Label htmlFor="file-upload">Ø¥Ø±ÙØ§Ù‚ Ù…Ù„Ù (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</Label>
            <div className="flex items-center gap-2">
                <Input 
                    id="file-upload" 
                    name="submissionFile" 
                    type="file" 
                    className="hidden" 
                    accept="image/*,.pdf" 
                    onChange={handleFileChange}
                    ref={fileInputRef}
                />
                <Button type="button" variant="outline" onClick={() => fileInputRef.current?.click()}>
                    <Paperclip className="h-4 w-4 ml-2"/>
                    <span>Ø§Ø®ØªØ± Ù…Ù„ÙÙ‹Ø§</span>
                </Button>
                {fileName && (
                    <div className="flex items-center gap-2 text-sm text-muted-foreground bg-muted p-2 rounded-md">
                        <span>{fileName}</span>
                        <Button type="button" variant="ghost" size="icon" className="h-6 w-6" onClick={handleRemoveFile}>
                            <X className="h-4 w-4" />
                        </Button>
                    </div>
                )}
            </div>
             <p className="text-xs text-muted-foreground">ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø£Ùˆ Ù…Ù„Ù PDF Ù„Ø­Ù„Ùƒ.</p>
        </div>


        {state?.error && (
            <p className="text-sm text-destructive flex items-center gap-1">
                <AlertCircle className="h-4 w-4" />
                {state.error}
            </p>
        )}
        <SubmitButton />
      </form>

      {state?.feedback && (
        <Card className="bg-secondary/50 border-accent">
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-accent">
                <CheckCircle2 />
                <span>ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</span>
            </CardTitle>
            <CardDescription>Ù‡Ø°Ù‡ Ù‡ÙŠ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø¹Ù„Ù‰ Ø¥Ø¬Ø§Ø¨ØªÙƒ.</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <h4 className="font-semibold mb-2">Ø§Ù„ØªÙ‚ÙŠÙŠÙ…:</h4>
              <p className="text-muted-foreground">{state.feedback}</p>
            </div>
             {state.score !== undefined && (
              <div>
                <h4 className="font-semibold mb-2">Ø§Ù„Ø¯Ø±Ø¬Ø©:</h4>
                <div className="flex items-center gap-2">
                    <div className="w-full bg-muted rounded-full h-4">
                         <div
                            className="bg-primary h-4 rounded-full"
                            style={{ width: `${state.score * 10}%` }}
                         ></div>
                    </div>
                    <span className="font-bold text-lg text-primary">{state.score}/10</span>
                </div>
              </div>
            )}
          </CardContent>
          {state.suggestedPrompts && state.suggestedPrompts.length > 0 && (
            <CardFooter className="flex flex-col items-start gap-2">
                 <h4 className="font-semibold flex items-center gap-2">
                    <Lightbulb className="h-5 w-5 text-yellow-500" />
                    <span>Ù†Ù‚Ø§Ø· Ù„Ù„ØªÙÙƒÙŠØ±</span>
                </h4>
                <div className="flex flex-wrap gap-2">
                    {state.suggestedPrompts.map((prompt, index) => (
                        <Button key={index} variant="outline" size="sm">
                            {prompt}
                        </Button>
                    ))}
                </div>
            </CardFooter>
          )}
        </Card>
      )}
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/lessons/[id]/components/SupportOnlyExercise.tsx
// ==========================================

'use client';

import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { BookOpen } from "lucide-react";
import MathContent from "@/components/MathContent";

interface SupportOnlyExerciseProps {
  exercise: {
    id: number;
    questionRichContent?: string;
    question?: string;
  };
}

export default function SupportOnlyExercise({ exercise }: SupportOnlyExerciseProps) {
  return (
    <div className="space-y-6">
      {/* Ø§Ù„Ø³Ø¤Ø§Ù„ */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <CardTitle>ØªÙ…Ø±ÙŠÙ† Ø¯Ø¹Ù… Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø©</CardTitle>
              <CardDescription>
                ØªÙ…Ø±ÙŠÙ† Ù„Ù„Ø¯Ø±Ø§Ø³Ø© Ø§Ù„Ø°Ø§ØªÙŠØ© - Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø¯Ø®Ø§Ù„ Ø¥Ø¬Ø§Ø¨Ø§Øª
              </CardDescription>
            </div>
            <Badge variant="outline">
              <BookOpen className="ml-2 h-4 w-4" />
              Ø¹Ø±Ø¶ ÙÙ‚Ø·
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          {exercise.questionRichContent ? (
            <MathContent content={exercise.questionRichContent} />
          ) : (
            <p className="whitespace-pre-wrap">{exercise.question}</p>
          )}
        </CardContent>
      </Card>

      {/* Ù…Ù„Ø§Ø­Ø¸Ø© */}
      <Card className="bg-muted/50">
        <CardContent className="p-6">
          <div className="flex items-start gap-3">
            <BookOpen className="h-5 w-5 text-muted-foreground mt-0.5" />
            <div className="space-y-1">
              <p className="font-medium">ØªÙ…Ø±ÙŠÙ† Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø°Ø§ØªÙŠØ©</p>
              <p className="text-sm text-muted-foreground">
                Ù‡Ø°Ø§ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ù…Ø®ØµØµ Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© ÙˆØ§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„Ø´Ø®ØµÙŠ. ÙŠÙ…ÙƒÙ†Ùƒ Ø­Ù„Ù‡ Ø¹Ù„Ù‰ ÙˆØ±Ù‚Ø© Ø®Ø§Ø±Ø¬ÙŠØ© ÙˆÙ…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø­Ù„ Ù…Ø¹ Ø£Ø³ØªØ§Ø°Ùƒ.
              </p>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/lessons/[id]/components/SupportWithResultsExercise.tsx
// ==========================================

'use client';

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { CheckCircle2, XCircle, RefreshCw } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";

interface SupportWithResultsExerciseProps {
  exercise: {
    id: number;
    questionRichContent?: string;
    question?: string;
    expectedResults?: any; // JSON array
  };
}

export default function SupportWithResultsExercise({ exercise }: SupportWithResultsExerciseProps) {
  const { toast } = useToast();
  const expectedResults = exercise.expectedResults || [];
  
  const [studentAnswers, setStudentAnswers] = useState<Record<string, string>>(
    expectedResults.reduce((acc: any, item: any) => {
      acc[item.question] = '';
      return acc;
    }, {})
  );
  const [comparisonResults, setComparisonResults] = useState<Record<string, boolean> | null>(null);
  const [showResults, setShowResults] = useState(false);

  const handleAnswerChange = (questionNum: string, value: string) => {
    setStudentAnswers({
      ...studentAnswers,
      [questionNum]: value,
    });
  };

  const normalizeAnswer = (answer: string): string => {
    return answer
      .trim()
      .toLowerCase()
      .replace(/\s+/g, '') // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª
      .replace(/[Ù -Ù©]/g, (d) => String.fromCharCode(d.charCodeAt(0) - 1632 + 48)) // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
      .replace(/[^\w\d.+\-*/^()]/g, ''); // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø±Ù…ÙˆØ² ØºÙŠØ± Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
  };

  const compareAnswers = () => {
    const hasEmptyAnswers = Object.values(studentAnswers).some(answer => !answer.trim());
    
    if (hasEmptyAnswers) {
      toast({
        title: "ØªÙ†Ø¨ÙŠÙ‡",
        description: "ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©",
        variant: "destructive",
      });
      return;
    }

    const results: Record<string, boolean> = {};
    let correctCount = 0;

    expectedResults.forEach((expected: any) => {
      const studentAnswer = normalizeAnswer(studentAnswers[expected.question] || '');
      const expectedAnswer = normalizeAnswer(expected.result);
      
      const isCorrect = studentAnswer === expectedAnswer;
      results[expected.question] = isCorrect;
      
      if (isCorrect) correctCount++;
    });

    setComparisonResults(results);
    setShowResults(true);

    toast({
      title: "ØªÙ…Øª Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©",
      description: `${correctCount} Ù…Ù† ${expectedResults.length} Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©`,
    });
  };

  const resetExercise = () => {
    setStudentAnswers(
      expectedResults.reduce((acc: any, item: any) => {
        acc[item.question] = '';
        return acc;
      }, {})
    );
    setComparisonResults(null);
    setShowResults(false);
  };

  const correctCount = comparisonResults 
    ? Object.values(comparisonResults).filter(Boolean).length 
    : 0;
  const totalCount = expectedResults.length;
  const percentage = totalCount > 0 ? (correctCount / totalCount) * 100 : 0;

  return (
    <div className="space-y-6">
      {/* Ø§Ù„Ø³Ø¤Ø§Ù„ */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <CardTitle>ØªÙ…Ø±ÙŠÙ† Ø¯Ø¹Ù… + Ù†ØªØ§Ø¦Ø¬</CardTitle>
              <CardDescription>
                Ø­Ù„ Ø§Ù„ØªÙ…Ø±ÙŠÙ† ÙˆÙ‚Ø§Ø±Ù† Ù†ØªØ§Ø¦Ø¬Ùƒ Ù…Ø¹ Ø§Ù„Ø­Ù„ Ø§Ù„ØµØ­ÙŠØ­
              </CardDescription>
            </div>
            <Badge variant="secondary">
              ØªØ¯Ø±ÙŠØ¨ Ø°Ø§ØªÙŠ
            </Badge>
          </div>
        </CardHeader>
        <CardContent>
          {exercise.questionRichContent ? (
            <div 
              className="tiptap prose max-w-none"
              dangerouslySetInnerHTML={{ __html: exercise.questionRichContent }}
            />
          ) : (
            <p className="whitespace-pre-wrap">{exercise.question}</p>
          )}
        </CardContent>
      </Card>

      {/* Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ */}
      <Card>
        <CardHeader>
          <CardTitle>Ø£Ø¯Ø®Ù„ Ù†ØªØ§Ø¦Ø¬Ùƒ</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {expectedResults.map((item: any, index: number) => (
            <div key={index} className="space-y-2">
              <div className="flex items-center gap-2">
                <Label htmlFor={`answer-${item.question}`} className="min-w-[100px]">
                  Ø§Ù„Ø³Ø¤Ø§Ù„ {item.question}:
                </Label>
                <div className="flex-1 flex items-center gap-2">
                  <Input
                    id={`answer-${item.question}`}
                    placeholder="Ø§Ù„Ù†ØªÙŠØ¬Ø©"
                    value={studentAnswers[item.question] || ''}
                    onChange={(e) => handleAnswerChange(item.question, e.target.value)}
                    disabled={showResults}
                    className={
                      showResults && comparisonResults
                        ? comparisonResults[item.question]
                          ? 'border-green-500 bg-green-50'
                          : 'border-red-500 bg-red-50'
                        : ''
                    }
                  />
                  {showResults && comparisonResults && (
                    <>
                      {comparisonResults[item.question] ? (
                        <CheckCircle2 className="h-5 w-5 text-green-600" />
                      ) : (
                        <XCircle className="h-5 w-5 text-red-600" />
                      )}
                    </>
                  )}
                </div>
              </div>
              {showResults && comparisonResults && !comparisonResults[item.question] && (
                <div className="mr-[100px] text-sm text-muted-foreground bg-muted p-2 rounded">
                  Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: <span className="font-semibold text-foreground">{item.result}</span>
                </div>
              )}
            </div>
          ))}

          <div className="flex gap-3 pt-4">
            {!showResults ? (
              <Button onClick={compareAnswers} className="flex-1">
                <CheckCircle2 className="ml-2 h-4 w-4" />
                Ù‚Ø§Ø±Ù† Ø§Ù„Ù†ØªØ§Ø¦Ø¬
              </Button>
            ) : (
              <Button onClick={resetExercise} variant="outline" className="flex-1">
                <RefreshCw className="ml-2 h-4 w-4" />
                Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
              </Button>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªÙŠØ¬Ø© */}
      {showResults && comparisonResults && (
        <Card className="border-primary">
          <CardHeader>
            <CardTitle>Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…Ù‚Ø§Ø±Ù†Ø©</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <div className="flex justify-between text-sm">
                <span>Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø©</span>
                <span className="font-semibold">
                  {correctCount} Ù…Ù† {totalCount}
                </span>
              </div>
              <Progress value={percentage} className="h-3" />
              <p className="text-center text-2xl font-bold text-primary">
                {percentage.toFixed(0)}%
              </p>
            </div>

            {percentage === 100 ? (
              <div className="bg-green-50 border border-green-200 rounded-lg p-4 text-center">
                <p className="text-green-800 font-semibold">
                  ğŸ‰ Ù…Ù…ØªØ§Ø²! Ø¬Ù…ÙŠØ¹ Ø¥Ø¬Ø§Ø¨Ø§ØªÙƒ ØµØ­ÙŠØ­Ø©!
                </p>
              </div>
            ) : percentage >= 70 ? (
              <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 text-center">
                <p className="text-blue-800 font-semibold">
                  ğŸ‘ Ø¬ÙŠØ¯ Ø¬Ø¯Ø§Ù‹! Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø© ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
                </p>
              </div>
            ) : (
              <div className="bg-orange-50 border border-orange-200 rounded-lg p-4 text-center">
                <p className="text-orange-800 font-semibold">
                  ğŸ’ª ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø³ÙŠÙ† Ù†ØªÙŠØ¬ØªÙƒ! Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø­Ù„ÙˆÙ„ ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
                </p>
              </div>
            )}
          </CardContent>
        </Card>
      )}
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/lessons/page.tsx
// ==========================================

'use client';

import Link from "next/link";
import Image from "next/image";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { PlaceHolderImages } from "@/lib/placeholder-images";
import { ArrowLeft, Lock, Loader2, BookOpen } from "lucide-react";
import { useLessons } from "@/hooks";
import { useSession } from "next-auth/react";
import { useSearchParams } from "next/navigation";
import { useState, useEffect } from "react";

export default function LessonsPage() {
  const { data: session } = useSession();
  const searchParams = useSearchParams();
  const subjectId = searchParams.get('subject');
  const [subjectName, setSubjectName] = useState<string>('');
  
  const { lessons, isLoading, error } = useLessons({
    subjectId: subjectId ? parseInt(subjectId) : undefined,
    status: 'approved',
  });

  // Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø©
  useEffect(() => {
    if (subjectId && lessons.length > 0) {
      setSubjectName(lessons[0]?.subject?.name || '');
    }
  }, [subjectId, lessons]);


  const getLessonImage = (id: number) => {
    const imageName = `lesson${id}`;
    return PlaceHolderImages.find((img) => img.id === imageName);
  };

  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center justify-center min-h-[400px]">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="text-center text-destructive">
          <p>{error}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <Link href="/subjects">
          <Button variant="outline" size="sm" className="mb-4">
            <ArrowLeft className="ml-2 h-4 w-4" />
            <span>Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…ÙˆØ§Ø¯</span>
          </Button>
        </Link>
        <div className="flex items-center gap-3 mb-2">
          <BookOpen className="h-8 w-8 text-primary" />
          <h1 className="text-3xl font-bold tracking-tight">
            {subjectName ? `Ø¯Ø±ÙˆØ³ ${subjectName}` : 'Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø±ÙˆØ³'}
          </h1>
        </div>
        <p className="text-muted-foreground">
          {subjectName 
            ? `ØªØµÙØ­ Ø¬Ù…ÙŠØ¹ Ø¯Ø±ÙˆØ³ Ù…Ø§Ø¯Ø© ${subjectName} Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ùƒ`
            : 'ØªØµÙØ­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ùƒ ÙˆØ§Ø¨Ø¯Ø£ Ø±Ø­Ù„ØªÙƒ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©.'}
        </p>
      </div>

      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-3">
        {lessons.map((lesson) => {
          const lessonImage = getLessonImage(lesson.id);

          return (
            <Card key={lesson.id} className="flex flex-col overflow-hidden">
              <CardHeader className="relative p-0">
                {lessonImage && (
                  <div className="relative aspect-video w-full">
                    <Image
                      src={lessonImage.imageUrl}
                      alt={lesson.title}
                      fill
                      className="object-cover"
                      data-ai-hint={lessonImage.imageHint}
                    />
                  </div>
                )}
                <div className="p-6">
                  <div className="flex justify-between items-start gap-2">
                    <div className="flex gap-2 flex-wrap">
                      <Badge variant="secondary">{lesson.subject?.name}</Badge>
                      <Badge variant={lesson.type === 'public' ? 'default' : 'outline'}>
                        {lesson.type === 'public' ? 'Ø¹Ø§Ù…' : 'Ø®Ø§Øµ'}
                      </Badge>
                    </div>
                    <p className="text-xs text-muted-foreground whitespace-nowrap">
                      Ø¨ÙˆØ§Ø³Ø·Ø©: {lesson.author?.name}
                    </p>
                  </div>
                  <CardTitle className="text-xl mt-2">{lesson.title}</CardTitle>
                </div>
              </CardHeader>
              <CardContent className="flex-grow">
                <CardDescription>
                  {lesson.description || lesson.content.substring(0, 100) + '...'}
                </CardDescription>
              </CardContent>
              <CardFooter>
                <Link href={`/lessons/${lesson.id}`} className="w-full" passHref>
                  <Button className="w-full">
                    <span>Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¯Ø±Ø³</span>
                    <ArrowLeft className="mr-2 h-4 w-4" />
                  </Button>
                </Link>
              </CardFooter>
            </Card>
          );
        })}
        {lessons.length === 0 && (
          <p className="text-muted-foreground col-span-full text-center">
            Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¯Ø±ÙˆØ³ Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠÙ‹Ø§.
          </p>
        )}
      </div>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/test-api/page.tsx
// ==========================================

'use client';

import { useEffect, useState } from 'react';
import { useSession } from 'next-auth/react';

export default function TestAPIPage() {
  const { data: session, status } = useSession();
  const [usersData, setUsersData] = useState<any>(null);
  const [dbData, setDbData] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (status === 'authenticated') {
      // Test Users API
      fetch('/api/users')
        .then(res => res.json())
        .then(data => {
          console.log('Users API Response:', data);
          setUsersData(data);
        })
        .catch(err => {
          console.error('Users API Error:', err);
          setError(err.message);
        });

      // Test Database API
      fetch('/api/database/inspect')
        .then(res => res.json())
        .then(data => {
          console.log('Database API Response:', data);
          setDbData(data);
        })
        .catch(err => {
          console.error('Database API Error:', err);
        });
    }
  }, [status]);

  if (status === 'loading') {
    return <div className="p-8">Loading session...</div>;
  }

  if (status === 'unauthenticated') {
    return <div className="p-8">Please login first</div>;
  }

  return (
    <div className="p-8 space-y-6">
      <h1 className="text-2xl font-bold">API Test Page</h1>

      <div className="space-y-4">
        <div className="p-4 bg-gray-100 rounded">
          <h2 className="font-bold mb-2">Session Data:</h2>
          <pre className="text-sm overflow-auto">{JSON.stringify(session, null, 2)}</pre>
        </div>

        <div className="p-4 bg-gray-100 rounded">
          <h2 className="font-bold mb-2">Users API Response:</h2>
          {error && <div className="text-red-500 mb-2">Error: {error}</div>}
          <pre className="text-sm overflow-auto">{JSON.stringify(usersData, null, 2)}</pre>
        </div>

        <div className="p-4 bg-gray-100 rounded">
          <h2 className="font-bold mb-2">Database API Response:</h2>
          <pre className="text-sm overflow-auto">{JSON.stringify(dbData, null, 2)}</pre>
        </div>
      </div>
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/profile/ParentProfile.tsx
// ==========================================

'use client';

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { Save, Loader2 } from "lucide-react";
import { useSession } from "next-auth/react";
import { useState, useEffect } from "react";

const ParentProfile = () => {
  const { toast } = useToast();
  const { data: session } = useSession();
  const [formData, setFormData] = useState({
    prenom: '',
    nom: '',
    email: '',
  });
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchProfile();
  }, []);

  const fetchProfile = async () => {
    try {
      const response = await fetch('/api/profile');
      const result = await response.json();
      if (result.success) {
        const user = result.data.user;
        setFormData({
          prenom: user.firstName || '',
          nom: user.lastName || '',
          email: user.email || '',
        });
      }
    } catch (error) {
      console.error('Error fetching profile:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSaveProfile = async () => {
    try {
      const response = await fetch('/api/profile', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      });

      const result = await response.json();
      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø­ÙØ¸',
          description: 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ',
        });
      } else {
        toast({
          title: 'Ø®Ø·Ø£',
          description: result.error || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª',
          variant: 'destructive',
        });
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸',
        variant: 'destructive',
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  const userName = `${formData.prenom} ${formData.nom}`;
  const userInitial = formData.prenom.charAt(0) || 'P';

  return (
    <div className="space-y-8">
      <Card>
        <CardHeader>
          <CardTitle>Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center gap-4">
            <Avatar className="h-20 w-20">
              <AvatarImage src={session?.user?.image || ''} alt={userName} />
              <AvatarFallback>{userInitial}</AvatarFallback>
            </Avatar>
            <Button variant="outline">ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø©</Button>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="parent-prenom">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„</Label>
              <Input 
                id="parent-prenom" 
                value={formData.prenom}
                onChange={(e) => setFormData({...formData, prenom: e.target.value})}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="parent-nom">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£Ø®ÙŠØ±</Label>
              <Input 
                id="parent-nom" 
                value={formData.nom}
                onChange={(e) => setFormData({...formData, nom: e.target.value})}
              />
            </div>
          </div>
          <div className="space-y-2">
            <Label htmlFor="parent-email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</Label>
            <Input 
              id="parent-email" 
              type="email" 
              value={formData.email}
              onChange={(e) => setFormData({...formData, email: e.target.value})}
            />
          </div>
          <div className="flex justify-end">
            <Button onClick={handleSaveProfile}>
              <Save className="ml-2 h-4 w-4" />
              <span>Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª</span>
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default ParentProfile;


// ==========================================
// FILE: src/app/(main)/profile/page.tsx
// ==========================================

'use client';

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { Save, Link as LinkIcon, UserMinus, Users, Loader2, UserCheck } from "lucide-react";
import { useSession } from "next-auth/react";
import { useState, useEffect } from "react";


const StudentProfile = () => {
  const { toast } = useToast();
  const { data: session } = useSession();
  const [teacherCode, setTeacherCode] = useState('');
  const [teachers, setTeachers] = useState<any[]>([]);
  const [parentCode, setParentCode] = useState('');
  const [parents, setParents] = useState<any[]>([]);
  const [formData, setFormData] = useState({
    prenom: '',
    nom: '',
    email: '',
  });
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    fetchProfile();
    fetchTeachers();
    fetchParents();
  }, []);

  const fetchProfile = async () => {
    try {
      const response = await fetch('/api/profile');
      const result = await response.json();
      if (result.success) {
        const user = result.data.user;
        setFormData({
          prenom: user.firstName || '',
          nom: user.lastName || '',
          email: user.email || '',
        });
      }
    } catch (error) {
      console.error('Error fetching profile:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const fetchTeachers = async () => {
    try {
      const response = await fetch('/api/students/teachers');
      const result = await response.json();
      if (result.success) {
        setTeachers(result.data.teachers);
      }
    } catch (error) {
      console.error('Error fetching teachers:', error);
    }
  };

  const fetchParents = async () => {
    try {
      const response = await fetch('/api/students/parents');
      const result = await response.json();
      if (result.success) {
        setParents(result.data.parents);
      }
    } catch (error) {
      console.error('Error fetching parents:', error);
    }
  };

  const handleConnectTeacher = async () => {
    if (!teacherCode.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¹Ù„Ù…',
        variant: 'destructive',
      });
      return;
    }

    try {
      const response = await fetch('/api/students/connect-teacher', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ teacherCode: teacherCode.trim() }),
      });

      const result = await response.json();
      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­',
          description: 'ØªÙ… Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ Ø¨Ø§Ù„Ù…Ø¹Ù„Ù…',
        });
        setTeacherCode('');
        fetchTeachers();
      } else {
        toast({
          title: 'Ø®Ø·Ø£',
          description: result.error || 'ÙØ´Ù„ Ø§Ù„Ø±Ø¨Ø· Ø¨Ø§Ù„Ù…Ø¹Ù„Ù…',
          variant: 'destructive',
        });
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø¨Ø·',
        variant: 'destructive',
      });
    }
  };

  const handleDisconnectTeacher = async (teacherId: number) => {
    try {
      const response = await fetch('/api/students/connect-teacher', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ teacherId }),
      });

      const result = await response.json();
      if (result.success) {
        toast({
          title: 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø¨Ø·',
          description: 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø¨Ø· Ø¨Ø§Ù„Ù…Ø¹Ù„Ù… Ø¨Ù†Ø¬Ø§Ø­',
        });
        fetchTeachers();
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø¨Ø·',
        variant: 'destructive',
      });
    }
  };

  const handleConnectParent = async () => {
    if (!parentCode.trim()) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙˆØ¯ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±',
        variant: 'destructive',
      });
      return;
    }

    try {
      const response = await fetch('/api/students/connect-parent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ parentCode: parentCode.trim() }),
      });

      const result = await response.json();
      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­',
          description: 'ØªÙ… Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ Ø¨ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±',
        });
        setParentCode('');
        fetchParents();
      } else {
        toast({
          title: 'Ø®Ø·Ø£',
          description: result.error || 'ÙØ´Ù„ Ø§Ù„Ø±Ø¨Ø· Ø¨ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±',
          variant: 'destructive',
        });
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø¨Ø·',
        variant: 'destructive',
      });
    }
  };

  const handleDisconnectParent = async (parentId: number) => {
    try {
      const response = await fetch('/api/students/connect-parent', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ parentId }),
      });

      const result = await response.json();
      if (result.success) {
        toast({
          title: 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø¨Ø·',
          description: 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø¨Ø· Ø¨ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ø¨Ù†Ø¬Ø§Ø­',
        });
        fetchParents();
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø¨Ø·',
        variant: 'destructive',
      });
    }
  };

  const handleSaveProfile = async () => {
    try {
      const response = await fetch('/api/profile', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      });

      const result = await response.json();
      if (result.success) {
        toast({
          title: 'ØªÙ… Ø§Ù„Ø­ÙØ¸',
          description: 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ',
        });
      } else {
        toast({
          title: 'Ø®Ø·Ø£',
          description: result.error || 'ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª',
          variant: 'destructive',
        });
      }
    } catch (error) {
      toast({
        title: 'Ø®Ø·Ø£',
        description: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­ÙØ¸',
        variant: 'destructive',
      });
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  const userName = `${formData.prenom} ${formData.nom}`;
  const userInitial = formData.prenom.charAt(0) || 'S';

  return (
    <div className="space-y-8">
      <Card>
        <CardHeader>
          <CardTitle>Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center gap-4">
            <Avatar className="h-20 w-20">
              <AvatarImage src={session?.user?.image || ''} alt={userName} />
              <AvatarFallback>{userInitial}</AvatarFallback>
            </Avatar>
            <Button variant="outline">ØªØºÙŠÙŠØ± Ø§Ù„ØµÙˆØ±Ø©</Button>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="student-prenom">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„</Label>
              <Input 
                id="student-prenom" 
                value={formData.prenom}
                onChange={(e) => setFormData({...formData, prenom: e.target.value})}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="student-nom">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£Ø®ÙŠØ±</Label>
              <Input 
                id="student-nom" 
                value={formData.nom}
                onChange={(e) => setFormData({...formData, nom: e.target.value})}
              />
            </div>
          </div>
          <div className="space-y-2">
            <Label htmlFor="student-email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</Label>
            <Input 
              id="student-email" 
              type="email" 
              value={formData.email}
              onChange={(e) => setFormData({...formData, email: e.target.value})}
            />
          </div>
          <div className="flex justify-end">
            <Button onClick={handleSaveProfile}>
              <Save className="ml-2 h-4 w-4" />
              <span>Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª</span>
            </Button>
          </div>
        </CardContent>
      </Card>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        <Card>
            <CardHeader>
            <CardTitle className="flex items-center gap-2">
                <LinkIcon className="text-primary" />
                <span>Ø§Ù„Ø±Ø¨Ø· Ø¨Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¹Ù„Ù…</span>
            </CardTitle>
            <CardDescription>
                Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¹Ù„Ù… Ù„Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ ÙˆÙ…Ø´Ø§Ø±ÙƒØ© ØªÙ‚Ø¯Ù…Ùƒ Ù…Ø¹Ù‡.
            </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
                <div className="flex items-center gap-2">
                  <Input 
                    id="teacher-code" 
                    placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¹Ù„Ù… Ù‡Ù†Ø§..."
                    value={teacherCode}
                    onChange={(e) => setTeacherCode(e.target.value)}
                  />
                  <Button onClick={handleConnectTeacher}>Ø±Ø¨Ø· Ø§Ù„Ø­Ø³Ø§Ø¨</Button>
                </div>
                
                <div className="space-y-4">
                    <Label className="flex items-center gap-2 text-muted-foreground">
                        <Users className="h-5 w-5" />
                        <span>Ø§Ù„Ù…Ø¹Ù„Ù…ÙˆÙ† Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙˆÙ†</span>
                    </Label>
                    {teachers.length > 0 ? (
                      teachers.map((teacher) => (
                        <div key={teacher.id} className="flex items-center justify-between rounded-lg border p-3 bg-muted/50">
                            <div>
                                <span className="font-semibold">{teacher.prenom} {teacher.nom}</span>
                                {teacher.subject && <span className="text-sm text-muted-foreground mx-2">({teacher.subject.name})</span>}
                            </div>
                            <Button 
                              variant="destructive" 
                              size="sm"
                              onClick={() => handleDisconnectTeacher(teacher.id)}
                            >
                                <UserMinus className="ml-2 h-4 w-4" />
                                <span>Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø¨Ø·</span>
                            </Button>
                        </div>
                      ))
                    ) : (
                        <p className="text-sm text-muted-foreground text-center py-4">
                            Ø£Ù†Øª ØºÙŠØ± Ù…Ø±ØªØ¨Ø· Ø¨Ø£ÙŠ Ù…Ø¹Ù„Ù… Ø­Ø§Ù„ÙŠÙ‹Ø§.
                        </p>
                    )}
                </div>
            </CardContent>
        </Card>

        <Card>
            <CardHeader>
            <CardTitle className="flex items-center gap-2">
                <UserCheck className="text-primary" />
                <span>Ø§Ù„Ø±Ø¨Ø· Ø¨Ø­Ø³Ø§Ø¨ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±</span>
            </CardTitle>
            <CardDescription>
                Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ù„Ø±Ø¨Ø· Ø­Ø³Ø§Ø¨Ùƒ ÙˆÙ…Ø´Ø§Ø±ÙƒØ© ØªÙ‚Ø¯Ù…Ùƒ Ù…Ø¹Ù‡.
            </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
                <div className="flex items-center gap-2">
                  <Input 
                    id="parent-code" 
                    placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ù‡Ù†Ø§..."
                    value={parentCode}
                    onChange={(e) => setParentCode(e.target.value)}
                  />
                  <Button onClick={handleConnectParent}>Ø±Ø¨Ø· Ø§Ù„Ø­Ø³Ø§Ø¨</Button>
                </div>
                
                <div className="space-y-4">
                    <Label className="flex items-center gap-2 text-muted-foreground">
                        <Users className="h-5 w-5" />
                        <span>Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ± Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙˆÙ†</span>
                    </Label>
                    {parents.length > 0 ? (
                      parents.map((parent) => (
                        <div key={parent.id} className="flex items-center justify-between rounded-lg border p-3 bg-muted/50">
                            <div>
                                <span className="font-semibold">{parent.firstName} {parent.lastName}</span>
                                <span className="text-sm text-muted-foreground mx-2">({parent.email})</span>
                            </div>
                            <Button 
                              variant="destructive" 
                              size="sm"
                              onClick={() => handleDisconnectParent(parent.id)}
                            >
                                <UserMinus className="ml-2 h-4 w-4" />
                                <span>Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø±Ø¨Ø·</span>
                            </Button>
                        </div>
                      ))
                    ) : (
                        <p className="text-sm text-muted-foreground text-center py-4">
                            Ø£Ù†Øª ØºÙŠØ± Ù…Ø±ØªØ¨Ø· Ø¨Ø£ÙŠ ÙˆÙ„ÙŠ Ø£Ù…Ø± Ø­Ø§Ù„ÙŠÙ‹Ø§.
                        </p>
                    )}
                </div>
            </CardContent>
        </Card>
      </div>
    </div>
  );
};

import ParentProfile from "./ParentProfile";

export default function ProfilePage() {
  const { data: session } = useSession();
  const userRole = session?.user?.role;

  return (
    <div className="max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold tracking-tight mb-8">
        Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
      </h1>
      {userRole === 'parent' ? <ParentProfile /> : <StudentProfile />}
    </div>
  );
}

    

// ==========================================
// FILE: src/app/(main)/subjects/[id]/page.tsx
// ==========================================

'use client';

import { useState, useEffect } from "react";
import { useParams } from "next/navigation";
import { useSession } from "next-auth/react";
import Link from "next/link";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Book, Loader2, Lock, Unlock } from "lucide-react";

export default function SubjectLessonsPage() {
  const params = useParams();
  const { data: session } = useSession();
  const [lessons, setLessons] = useState<any[]>([]);
  const [subject, setSubject] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchLessons = async () => {
      if (!session?.user || !params.id) return;

      try {
        setIsLoading(true);

        // Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø§Ø¯Ø©
        const subjectRes = await fetch(`/api/subjects/${params.id}`);
        const subjectData = await subjectRes.json();
        if (subjectData.success) {
          setSubject(subjectData.data);
        }

        // Ø¬Ù„Ø¨ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ†
        const teachersRes = await fetch('/api/students/teachers');
        const teachersData = await teachersRes.json();
        const teacherIds = teachersData.success 
          ? teachersData.data.teachers.map((t: any) => t.id) 
          : [];

        // Ø¬Ù„Ø¨ Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…Ø§Ø¯Ø© (Ø¹Ø§Ù…Ø© + Ø¯Ø±ÙˆØ³ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ†)
        const lessonsRes = await fetch(`/api/lessons?subjectId=${params.id}`);
        const lessonsResult = await lessonsRes.json();
        
        if (lessonsResult.success) {
          const lessonsList = lessonsResult.data?.lessons || lessonsResult.data || [];
          // ØªØµÙÙŠØ©: Ø¯Ø±ÙˆØ³ Ø¹Ø§Ù…Ø© Ø£Ùˆ Ø¯Ø±ÙˆØ³ Ù…Ù† Ø£Ø³Ø§ØªØ°Ø© Ù…Ø±ØªØ¨Ø·ÙŠÙ†
          const filteredLessons = lessonsList.filter((lesson: any) => 
            lesson.type === 'public' || teacherIds.includes(lesson.authorId)
          );
          setLessons(Array.isArray(filteredLessons) ? filteredLessons : []);
        }
      } catch (error) {
        console.error('Error fetching lessons:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchLessons();
  }, [session, params.id]);

  // ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
  const groupedLessons: { levelName: string; lessons: any[] }[] = [];
  lessons.forEach((lesson) => {
    const levelName = lesson.level?.name || 'Ù…Ø³ØªÙˆÙ‰ ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
    let group = groupedLessons.find(g => g.levelName === levelName);
    if (!group) {
      group = { levelName, lessons: [] };
      groupedLessons.push(group);
    }
    group.lessons.push(lesson);
  });

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold tracking-tight mb-2">
          {subject?.name || 'Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…Ø§Ø¯Ø©'}
        </h1>
        <p className="text-muted-foreground">
          {subject?.description || 'Ø§Ø®ØªØ± Ø¯Ø±Ø³Ø§Ù‹ Ù„ØªØ¨Ø¯Ø£ Ø§Ù„ØªØ¹Ù„Ù…'}
        </p>
      </div>

      {lessons.length > 0 ? (
        <div className="space-y-12">
          {groupedLessons.map((group) => (
            <div key={group.levelName} className="space-y-6">
              <div className="flex items-center gap-3 border-b pb-2">
                <div className="h-8 w-1.5 bg-primary rounded-full" />
                <h2 className="text-2xl font-bold text-foreground">{group.levelName}</h2>
                <Badge variant="secondary" className="mr-auto">
                  {group.lessons.length} {group.lessons.length === 1 ? 'Ø¯Ø±Ø³' : 'Ø¯Ø±ÙˆØ³'}
                </Badge>
              </div>

              <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
                {group.lessons.map((lesson) => (
                  <Card key={lesson.id} className="hover:shadow-lg transition-shadow flex flex-col">
                    <CardHeader>
                      <div className="flex items-start justify-between mb-2">
                        <Book className="h-5 w-5 text-primary" />
                        <Badge variant={lesson.type === 'public' ? 'default' : 'secondary'}>
                          {lesson.type === 'public' ? 'Ø¹Ø§Ù…' : 'Ø®Ø§Øµ'}
                        </Badge>
                      </div>
                      <CardTitle className="line-clamp-2">{lesson.title}</CardTitle>
                      <CardDescription className="line-clamp-3">
                        {lesson.content ? lesson.content.replace(/<[^>]*>?/gm, '').substring(0, 100) + '...' : 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙˆØµÙ'}
                      </CardDescription>
                    </CardHeader>
                    <CardContent className="mt-auto">
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2 text-sm text-muted-foreground">
                          {lesson.isLocked ? (
                            <Lock className="h-4 w-4" />
                          ) : (
                            <Unlock className="h-4 w-4" />
                          )}
                          <span>{lesson.isLocked ? 'Ù…ØºÙ„Ù‚' : 'Ù…ØªØ§Ø­'}</span>
                        </div>
                        <Link href={`/lessons/${lesson.id}`}>
                          <Button size="sm">
                            Ø¨Ø¯Ø¡ Ø§Ù„Ø¯Ø±Ø³
                          </Button>
                        </Link>
                      </div>
                    </CardContent>
                  </Card>
                ))}
              </div>
            </div>
          ))}
        </div>
      ) : (
        <Card>
          <CardContent className="text-center py-12">
            <Book className="h-12 w-12 mx-auto mb-4 text-muted-foreground" />
            <p className="text-muted-foreground">
              Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¯Ø±ÙˆØ³ Ù…ØªØ§Ø­Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø§Ø¯Ø© Ø­Ø§Ù„ÙŠØ§Ù‹
            </p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}


// ==========================================
// FILE: src/app/(main)/subjects/page.tsx
// ==========================================

'use client';

import Link from "next/link";
import Image from "next/image";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { PlaceHolderImages } from "@/lib/placeholder-images";
import { ArrowLeft, BookOpen, Loader2 } from "lucide-react";
import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";

export default function SubjectsPage() {
  const { data: session } = useSession();
  const [subjects, setSubjects] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchSubjects = async () => {
      if (!session) return; // Wait for session to be available

      try {
        setIsLoading(true);
        setError(null); // Reset error state on new fetch
        const subjectsRes = await fetch(`/api/subjects`);
        
        if (!subjectsRes.ok) {
          let errorMsg = `ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯. Ø±Ù…Ø² Ø§Ù„Ø­Ø§Ù„Ø©: ${subjectsRes.status}`;
          try {
            const errorData = await subjectsRes.json();
            errorMsg = errorData.error || errorMsg;
          } catch (jsonError) {
            console.error('Could not parse error JSON:', jsonError);
          }
          throw new Error(errorMsg);
        }

        const subjectsData = await subjectsRes.json();
        
        if (subjectsData.success) {
          const subjectsList = subjectsData.data || [];
          setSubjects(Array.isArray(subjectsList) ? subjectsList : []);
        } else {
          setError(subjectsData.error || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…ÙˆØ§Ø¯');
        }
      } catch (err: any) {
        console.error('Error fetching subjects:', err);
        setError(err.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯');
      } finally {
        setIsLoading(false);
      }
    };

    fetchSubjects();
  }, [session]);

  const getSubjectImage = (subjectName: string) => {
    const imageName = `subject-${subjectName.toLowerCase()}`;
    if (subjectName === 'Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª') return PlaceHolderImages.find((img) => img.id === 'subject-math');
    if (subjectName === 'Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©') return PlaceHolderImages.find((img) => img.id === 'subject-arabic');
    if (subjectName === 'Ø§Ù„Ø¹Ù„ÙˆÙ…') return PlaceHolderImages.find((img) => img.id === 'subject-science');
    return null;
  };

  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="flex items-center justify-center min-h-[400px]">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className="text-center text-destructive">
          <p>{error}</p>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold tracking-tight">Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©</h1>
        <p className="text-muted-foreground">
          ØªØµÙØ­ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ùƒ ÙˆØ§Ø¨Ø¯Ø£ ÙÙŠ Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ø¯Ø±ÙˆØ³.
        </p>
      </div>

      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-3">
        {subjects.map((subject) => {
          const subjectImage = getSubjectImage(subject.name);
          return (
            <Card key={subject.id} className="flex flex-col overflow-hidden">
              {subjectImage && (
                <div className="relative aspect-video w-full">
                  <Image
                    src={subjectImage.imageUrl}
                    alt={subject.name}
                    fill
                    className="object-cover"
                    data-ai-hint={subjectImage.imageHint}
                  />
                </div>
              )}
              <CardHeader>
                <CardTitle className="text-xl">{subject.name}</CardTitle>
                <CardDescription>{subject.description}</CardDescription>
              </CardHeader>
              <CardContent className="flex-grow">
                <div className="flex items-center text-sm text-muted-foreground">
                  <BookOpen className="ml-2 h-4 w-4" />
                  <span>Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…ØªØ§Ø­Ø©</span>
                </div>
              </CardContent>
              <CardFooter>
                <Link href={`/lessons?subject=${subject.id}`} className="w-full" passHref>
                  <Button className="w-full">
                    <span>Ø¹Ø±Ø¶ Ø§Ù„Ø¯Ø±ÙˆØ³</span>
                    <ArrowLeft className="mr-2 h-4 w-4" />
                  </Button>
                </Link>
              </CardFooter>
            </Card>
          );
        })}
        {subjects.length === 0 && (
          <p className="text-muted-foreground col-span-full text-center">
            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ÙˆØ§Ø¯ Ù…ØªØ§Ø­Ø© Ø­Ø§Ù„ÙŠÙ‹Ø§.
          </p>
        )}
      </div>
    </div>
  );
}


// ==========================================
// FILE: src/app/(auth)/signup/page.tsx
// ==========================================


'use client';

import { useState, useEffect } from "react";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { School, Loader2 } from "lucide-react";
import Link from "next/link";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useToast } from "@/hooks/use-toast";

interface Stage {
  id: number;
  name: string;
  description: string;
}

interface Level {
  id: number;
  name: string;
  stage_id: number;
}

interface Subject {
  id: number;
  name: string;
  stageId?: number;
  stage_id?: number;
}

export default function SignupPage() {
  const router = useRouter();
  const { toast } = useToast();
  const [role, setRole] = useState<string>('');
  const [stage, setStage] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);
  
  const [stages, setStages] = useState<Stage[]>([]);
  const [levels, setLevels] = useState<Level[]>([]);
  const [subjects, setSubjects] = useState<Subject[]>([]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        console.log('Fetching stages, levels, subjects...');
        
        const [stagesRes, levelsRes, subjectsRes] = await Promise.all([
          fetch('/api/stages'),
          fetch('/api/levels'),
          fetch('/api/subjects')
        ]);
        
        const stagesData = await stagesRes.json();
        const levelsData = await levelsRes.json();
        const subjectsData = await subjectsRes.json();
        
        console.log('Stages response:', stagesData);
        console.log('Levels response:', levelsData);
        console.log('Subjects response:', subjectsData);
        
        // Handle API response format: { success: true, data: [...] }
        setStages(stagesData.success ? stagesData.data : []);
        setLevels(levelsData.success ? levelsData.data : []);
        setSubjects(subjectsData.success ? subjectsData.data : []);
        
        console.log('Stages set:', stagesData.success ? stagesData.data.length : 0);
        console.log('Levels set:', levelsData.success ? levelsData.data.length : 0);
        console.log('Subjects set:', subjectsData.success ? subjectsData.data.length : 0);
      } catch (error) {
        console.error('Failed to fetch data:', error);
      }
    };
    
    fetchData();
  }, []);

  const handleRoleChange = (value: string) => {
    setRole(value);
    setStage(''); // Reset stage when role changes
  };

  const levelsForStage = levels.filter(level => {
    const levelStageId = (level as any).stageId || level.stage_id;
    return String(levelStageId) === stage;
  });
  
  console.log('Selected stage:', stage);
  console.log('All levels:', levels);
  console.log('Filtered levels for stage:', levelsForStage);

  // Filter subjects by stage and deduplicate by name
  const uniqueSubjectsForStage = (() => {
    const stageSubjects = subjects.filter(
      subject => String(subject.stageId) === stage || String(subject.stage_id) === stage
    );
    const uniqueMap = new Map();
    stageSubjects.forEach(s => {
      if (!uniqueMap.has(s.name)) uniqueMap.set(s.name, s);
    });
    return Array.from(uniqueMap.values());
  })();

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);

    const formData = new FormData(e.currentTarget);
    const data = {
      email: formData.get('email') as string,
      password: formData.get('password') as string,
      firstName: formData.get('firstName') as string,
      lastName: formData.get('lastName') as string,
      roleName: role,
      stageId: (role === 'teacher' || role === 'student') && stage ? parseInt(stage) : undefined,
      subjectId: role === 'teacher' ? parseInt(formData.get('subjectId') as string) : undefined,
      levelId: role === 'student' ? parseInt(formData.get('levelId') as string) : undefined,
    };

    try {
      const response = await fetch('/api/auth/signup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        toast({
          title: "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­",
          description: "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
        });
        router.push('/login');
      } else {
        toast({
          title: "Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨",
          description: result.error || "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨",
          variant: "destructive",
        });
      }
    } catch (error) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleSignIn = async () => {
    setIsGoogleLoading(true);
    try {
      await signIn('google', { callbackUrl: '/complete-profile' });
    } catch (error) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ø¨Ø± Google",
        variant: "destructive",
      });
      setIsGoogleLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-background p-4">
      <Card className="w-full max-w-lg shadow-2xl">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-primary">
            <School className="h-10 w-10 text-primary-foreground" />
          </div>
          <CardTitle className="text-3xl">Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙŠØ¯</CardTitle>
          <CardDescription>
            Ø§Ù†Ø¶Ù… Ø¥Ù„Ù‰ SmartEdu ÙˆØ§Ø¨Ø¯Ø£ Ø±Ø­Ù„ØªÙƒ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="firstName">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„</Label>
                <Input 
                  id="firstName" 
                  name="firstName" 
                  placeholder="Ù…Ø«Ø§Ù„: Ø£Ø­Ù…Ø¯" 
                  required 
                  disabled={isLoading}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="lastName">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£Ø®ÙŠØ±</Label>
                <Input 
                  id="lastName" 
                  name="lastName" 
                  placeholder="Ù…Ø«Ø§Ù„: Ø§Ù„Ù…Ø­Ù…ÙˆØ¯" 
                  required 
                  disabled={isLoading}
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="email@example.com"
                required
                disabled={isLoading}
              />
            </div>
            
            <div className="space-y-2">
              <Label htmlFor="role">Ø§Ù„Ø¯ÙˆØ±</Label>
              <Select onValueChange={handleRoleChange} value={role} disabled={isLoading}>
                <SelectTrigger id="role">
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø¯ÙˆØ±Ùƒ" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="teacher">Ø£Ø³ØªØ§Ø°</SelectItem>
                  <SelectItem value="student">Ø·Ø§Ù„Ø¨</SelectItem>
                  <SelectItem value="parent">ÙˆÙ„ÙŠ Ø£Ù…Ø±</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {role === 'teacher' && (
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="teacher-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                  <Select onValueChange={setStage} value={stage} disabled={isLoading}>
                    <SelectTrigger id="teacher-stage">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                      {stages.map(s => (
                        <SelectItem key={s.id} value={String(s.id)}>
                          {s.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label htmlFor="subjectId">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                  <Select name="subjectId" disabled={!stage || isLoading}>
                    <SelectTrigger id="subjectId">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                      {uniqueSubjectsForStage.map(subject => (
                        <SelectItem key={subject.id} value={String(subject.id)}>
                          {subject.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}

            {role === 'student' && (
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="student-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© *</Label>
                  <Select onValueChange={setStage} value={stage} disabled={isLoading} required>
                    <SelectTrigger id="student-stage">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                      {stages.map(s => (
                        <SelectItem key={s.id} value={String(s.id)}>
                          {s.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label htmlFor="levelId">Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© *</Label>
                  <Select name="levelId" disabled={!stage || isLoading} required>
                    <SelectTrigger id="levelId">
                      <SelectValue placeholder={!stage ? "Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø£ÙˆÙ„Ø§Ù‹" : "Ø§Ø®ØªØ± Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©"} />
                    </SelectTrigger>
                    <SelectContent>
                      {levelsForStage.length > 0 ? (
                        levelsForStage.map(level => (
                          <SelectItem key={level.id} value={String(level.id)}>
                            {level.name}
                          </SelectItem>
                        ))
                      ) : (
                        <SelectItem value="none" disabled>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³ØªÙˆÙŠØ§Øª Ù…ØªØ§Ø­Ø©</SelectItem>
                      )}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}

            <div className="space-y-2">
              <Label htmlFor="password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</Label>
              <Input 
                id="password" 
                name="password" 
                type="password" 
                required 
                disabled={isLoading}
              />
            </div>

            <Button type="submit" className="w-full !mt-6" disabled={isLoading}>
              {isLoading && <Loader2 className="ml-2 h-4 w-4 animate-spin" />}
              Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨
            </Button>
          </form>
        </CardContent>
        <CardFooter className="flex flex-col gap-4">
          <div className="relative w-full">
            <div className="absolute inset-0 flex items-center">
              <span className="w-full border-t" />
            </div>
            <div className="relative flex justify-center text-xs uppercase">
              <span className="bg-card px-2 text-muted-foreground">
                Ø£Ùˆ Ø§Ø³ØªÙ…Ø± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…
              </span>
            </div>
          </div>
          <Button 
            variant="outline" 
            className="w-full"
            onClick={handleGoogleSignIn}
            disabled={isGoogleLoading}
            type="button"
          >
            {isGoogleLoading && <Loader2 className="ml-2 h-4 w-4 animate-spin" />}
            Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Google
          </Button>
          <div className="mt-4 text-center text-sm">
            Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ Ø¨Ø§Ù„ÙØ¹Ù„ØŸ{" "}
            <Link href="/login" className="underline">
              ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(auth)/layout.tsx
// ==========================================


export default function AuthLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <>{children}</>;
}


// ==========================================
// FILE: src/app/(auth)/login/page.tsx
// ==========================================


'use client';

import { useState } from "react";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { School, Loader2 } from "lucide-react";
import Link from "next/link";
import { useToast } from "@/hooks/use-toast";

export default function LoginPage() {
  const router = useRouter();
  const { toast } = useToast();
  const [isLoading, setIsLoading] = useState(false);
  const [isGoogleLoading, setIsGoogleLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);

    const formData = new FormData(e.currentTarget);
    const email = formData.get('email') as string;
    const password = formData.get('password') as string;

    try {
      const result = await signIn('credentials', {
        email,
        password,
        redirect: false,
      });

      if (result?.error) {
        toast({
          title: "Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
          description: result.error === 'CredentialsSignin' 
            ? "Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©"
            : result.error || "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„",
          variant: "destructive",
        });
      } else if (result?.ok) {
        toast({
          title: "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­",
          description: "Ø¬Ø§Ø±ÙŠ ØªØ­ÙˆÙŠÙ„Ùƒ...",
        });
        // Force a session update before redirecting
        await fetch('/api/auth/session', { 
          method: 'GET',
          cache: 'no-store'
        });
        router.push('/dashboard');
        router.refresh();
      }
    } catch (error) {
      console.error('Login error:', error);
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleGoogleSignIn = async () => {
    setIsGoogleLoading(true);
    try {
      await signIn('google', { callbackUrl: '/dashboard' });
    } catch (error) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ø¨Ø± Google",
        variant: "destructive",
      });
      setIsGoogleLoading(false);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-background p-4">
      <Card className="w-full max-w-md shadow-2xl">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-primary">
            <School className="h-10 w-10 text-primary-foreground" />
          </div>
          <CardTitle className="text-3xl">Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ SmartEdu</CardTitle>
          <CardDescription>
            Ù…Ù†ØµØªÙƒ Ø§Ù„Ø°ÙƒÙŠØ© Ù„Ù„ØªØ¹Ù„Ù…. Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</Label>
              <Input
                id="email"
                name="email"
                type="email"
                placeholder="email@example.com"
                required
                disabled={isLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</Label>
              <Input 
                id="password" 
                name="password" 
                type="password" 
                required 
                disabled={isLoading}
              />
            </div>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading && <Loader2 className="ml-2 h-4 w-4 animate-spin" />}
              ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
            </Button>
          </form>
        </CardContent>
        <CardFooter className="flex flex-col gap-4">
          <div className="relative w-full">
            <div className="absolute inset-0 flex items-center">
              <span className="w-full border-t" />
            </div>
            <div className="relative flex justify-center text-xs uppercase">
              <span className="bg-card px-2 text-muted-foreground">
                Ø£Ùˆ Ø§Ø³ØªÙ…Ø± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…
              </span>
            </div>
          </div>
          <Button 
            variant="outline" 
            className="w-full" 
            onClick={handleGoogleSignIn}
            disabled={isGoogleLoading}
            type="button"
          >
            {isGoogleLoading && <Loader2 className="ml-2 h-4 w-4 animate-spin" />}
            ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Google
          </Button>
          <div className="mt-4 text-center text-sm">
            Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ Ø­Ø³Ø§Ø¨ØŸ{" "}
            <Link href="/signup" className="underline">
              Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}


// ==========================================
// FILE: src/app/(auth)/complete-profile/page.tsx
// ==========================================


'use client';

import { useState, useEffect } from "react";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { School, Loader2 } from "lucide-react";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";

interface Stage {
  id: number;
  name: string;
  description: string;
}

interface Level {
  id: number;
  name: string;
  stage_id: number;
}

interface Subject {
  id: number;
  name: string;
}

export default function CompleteProfilePage() {
  const router = useRouter();
  const { toast } = useToast();
  const { data: session, update } = useSession();
  
  const [role, setRole] = useState<string>('');
  const [stage, setStage] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  
  const [stages, setStages] = useState<Stage[]>([]);
  const [levels, setLevels] = useState<Level[]>([]);
  const [subjects, setSubjects] = useState<Subject[]>([]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [stagesRes, levelsRes, subjectsRes] = await Promise.all([
          fetch('/api/stages'),
          fetch('/api/levels'),
          fetch('/api/subjects')
        ]);
        
        const stagesData = await stagesRes.json();
        const levelsData = await levelsRes.json();
        const subjectsData = await subjectsRes.json();
        
        if (stagesData.success) setStages(stagesData.data);
        if (levelsData.success) setLevels(levelsData.data);
        if (subjectsData.success) setSubjects(subjectsData.data);
      } catch (error) {
        console.error('Failed to fetch data:', error);
      }
    };
    
    fetchData();
  }, []);

  const handleRoleChange = (value: string) => {
    setRole(value);
    setStage('');
  };

  const levelsForStage = levels.filter(level => String(level.stage_id) === stage);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);

    if (!session?.user?.id) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø¬Ù„Ø³Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©",
        variant: "destructive",
      });
      setIsLoading(false);
      return;
    }

    const formData = new FormData(e.currentTarget);
    const data = {
      role: role,
      subjectId: role === 'teacher' ? parseInt(formData.get('subjectId') as string) : undefined,
      levelId: role === 'student' ? parseInt(formData.get('levelId') as string) : undefined,
    };

    try {
      const response = await fetch(`/api/users/${session.user.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      const result = await response.json();

      if (result.success) {
        await update();
        toast({
          title: "ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ Ø¨Ù†Ø¬Ø§Ø­",
          description: "Ø¬Ø§Ø±ÙŠ ØªØ­ÙˆÙŠÙ„Ùƒ Ø¥Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…...",
        });
        router.push('/dashboard');
        router.refresh();
      } else {
        toast({
          title: "Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ",
          description: result.error || "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ø¯ÙŠØ«",
          variant: "destructive",
        });
      }
    } catch (error) {
      toast({
        title: "Ø®Ø·Ø£",
        description: "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  if (!session) {
    router.push('/login');
    return null;
  }

  const firstName = session.user.name?.split(' ')[0] || '';
  const lastName = session.user.name?.split(' ').slice(1).join(' ') || '';

  return (
    <div className="flex min-h-screen items-center justify-center bg-background p-4">
      <Card className="w-full max-w-lg shadow-2xl">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-primary">
            <School className="h-10 w-10 text-primary-foreground" />
          </div>
          <CardTitle className="text-3xl">Ø£ÙƒÙ…Ù„ Ù…Ù„ÙÙƒ Ø§Ù„Ø´Ø®ØµÙŠ</CardTitle>
          <CardDescription>
            Ø®Ø·ÙˆØ© Ø£Ø®ÙŠØ±Ø©! Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ø¯ÙˆØ±Ùƒ ÙˆØ§Ø³ØªÙƒÙ…Ø§Ù„ Ø¨ÙŠØ§Ù†Ø§ØªÙƒ.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="firstName">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„</Label>
                <Input id="firstName" defaultValue={firstName} disabled />
              </div>
              <div className="space-y-2">
                <Label htmlFor="lastName">Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£Ø®ÙŠØ±</Label>
                <Input id="lastName" defaultValue={lastName} disabled />
              </div>
            </div>
            <div className="space-y-2">
              <Label htmlFor="email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</Label>
              <Input
                id="email"
                type="email"
                defaultValue={session.user.email || ''}
                disabled
              />
            </div>
            
            <div className="space-y-4">
              <Label htmlFor="role">Ø§Ù„Ø¯ÙˆØ±</Label>
              <Select onValueChange={handleRoleChange} value={role} disabled={isLoading}>
                <SelectTrigger id="role">
                  <SelectValue placeholder="Ø§Ø®ØªØ± Ø¯ÙˆØ±Ùƒ" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="teacher">Ø£Ø³ØªØ§Ø°</SelectItem>
                  <SelectItem value="student">Ø·Ø§Ù„Ø¨</SelectItem>
                  <SelectItem value="parent">ÙˆÙ„ÙŠ Ø£Ù…Ø±</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {role === 'teacher' && (
              <div className="space-y-2">
                <Label htmlFor="subjectId">Ø§Ù„Ù…Ø§Ø¯Ø©</Label>
                <Select name="subjectId" disabled={isLoading}>
                  <SelectTrigger id="subjectId">
                    <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø§Ø¯Ø©" />
                  </SelectTrigger>
                  <SelectContent>
                    {subjects.map(subject => (
                      <SelectItem key={subject.id} value={String(subject.id)}>
                        {subject.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            )}

            {role === 'student' && (
              <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label htmlFor="student-stage">Ø§Ù„Ù…Ø±Ø­Ù„Ø©</Label>
                  <Select onValueChange={setStage} value={stage} disabled={isLoading}>
                    <SelectTrigger id="student-stage">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø±Ø­Ù„Ø©" />
                    </SelectTrigger>
                    <SelectContent>
                      {stages.map(s => (
                        <SelectItem key={s.id} value={String(s.id)}>
                          {s.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="space-y-2">
                  <Label htmlFor="levelId">Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ</Label>
                  <Select name="levelId" disabled={!stage || isLoading}>
                    <SelectTrigger id="levelId">
                      <SelectValue placeholder="Ø§Ø®ØªØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰" />
                    </SelectTrigger>
                    <SelectContent>
                      {levelsForStage.map(level => (
                        <SelectItem key={level.id} value={String(level.id)}>
                          {level.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            )}

            <Button type="submit" className="w-full !mt-8" disabled={isLoading}>
              {isLoading && <Loader2 className="ml-2 h-4 w-4 animate-spin" />}
              Ø­ÙØ¸ ÙˆØ§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}



// ==========================================
// FILE: src/app/layout.tsx
// ==========================================

import type {Metadata} from 'next';
import './globals.css';
import { Toaster } from "@/components/ui/toaster"
import { AuthProvider } from '@/components/providers/SessionProvider';

export const metadata: Metadata = {
  title: 'SmartEdu Platform',
  description: 'An intelligent learning platform.',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" dir="rtl">
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
        <link href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Cairo:wght@400;500;600;700&family=Inter:wght@400;500;600;700&family=Tajawal:wght@400;500;700&display=swap" rel="stylesheet" />
      </head>
      <body className="antialiased">
        <AuthProvider>
          {children}
        </AuthProvider>
        <Toaster />
      </body>
    </html>
  );
}


// ==========================================
// FILE: src/app/page.tsx
// ==========================================


'use client';

import { Button } from "@/components/ui/button";
import { School, ArrowLeft, Bot, BarChart, Users, Star, BookCopy, FileQuestion } from "lucide-react";
import Link from "next/link";
import Image from "next/image";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { USERS, LESSONS, EXERCISES, LEVELS, getUserById } from "@/lib/mock-data";
import { Badge } from "@/components/ui/badge";
import { useEffect, useState } from "react";

export default function LandingPage() {
  // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙˆÙ‡Ù…ÙŠØ© ÙƒÙ‚ÙŠÙ… Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ© Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… Ø¸Ù‡ÙˆØ± Ø§Ù„Ø£ØµÙØ§Ø± Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© ÙØ§Ø±ØºØ©
  const [stats, setStats] = useState({
    studentCount: USERS.filter(u => u.role === 'student').length,
    teacherCount: USERS.filter(u => ['teacher', 'supervisor'].includes(u.role)).length,
    lessonCount: LESSONS.length,
    exerciseCount: EXERCISES.length,
  });

  const [topStudents, setTopStudents] = useState<Array<{
    id: string;
    firstName: string;
    lastName: string;
    levelName: string;
    averageScore: number;
  }>>([]);

  useEffect(() => {
    const fetchStats = async () => {
      try {
        // Ø¥Ø¶Ø§ÙØ© { cache: 'no-store' } Ù„Ù…Ù†Ø¹ Ø§Ù„Ù…ØªØµÙØ­ Ù…Ù† ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© (0)
        const response = await fetch('/api/statistics/public', { cache: 'no-store' });
        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data) {
            setStats({
              studentCount: result.data.students || 0,
              teacherCount: result.data.teachers || 0,
              lessonCount: result.data.lessons || 0,
              exerciseCount: result.data.exercises || 0,
            });
            // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ø¬Ù„Ø¨ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…ØªÙÙˆÙ‚ÙŠÙ† Ù‡Ù†Ø§ Ù„Ø§Ø­Ù‚Ø§Ù‹ Ø¥Ø°Ø§ ØªÙˆÙØ± ÙÙŠ Ø§Ù„Ù€ API
          }
        } else {
          console.error('Failed to fetch stats:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('Error fetching stats:', error);
      }
    };
    fetchStats();
  }, []);

  const studentCount = stats.studentCount;
  const teacherCount = stats.teacherCount;
  const lessonCount = stats.lessonCount;
  const exerciseCount = stats.exerciseCount;

  return (
    <div className="flex flex-col min-h-screen bg-background">
      <header className="container mx-auto px-4 sm:px-6 lg:px-8 h-20 flex items-center justify-between sticky top-0 bg-background/80 backdrop-blur-sm z-50">
        <Link href="/" className="flex items-center gap-2">
          <School className="h-8 w-8 text-primary" />
          <h1 className="text-2xl font-bold text-foreground">Smartedu</h1>
        </Link>
        <nav className="flex items-center gap-2">
          <Link href="/login" passHref>
            <Button variant="ghost">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</Button>
          </Link>
          <Link href="/signup" passHref>
            <Button>
              <span>Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨</span>
              <ArrowLeft className="mr-2 h-4 w-4" />
            </Button>
          </Link>
        </nav>
      </header>

      <main className="flex-1">
        <section className="container mx-auto px-4 sm:px-6 lg:px-8 py-16 md:py-24 flex flex-col items-center">
          <div className="flex flex-col lg:flex-row items-center gap-12">
            <div className="lg:w-1/2 text-center lg:text-right">
              <h2 className="text-4xl md:text-5xl font-extrabold tracking-tight text-foreground leading-tight">
                Ø£Ø·Ù„Ù‚ Ø§Ù„Ø¹Ù†Ø§Ù† Ù„Ø¥Ù…ÙƒØ§Ù†ÙŠØ§ØªÙƒ Ù…Ø¹ <span className="text-primary">SmartEdu</span>ØŒ Ù…Ù†ØµØ© Ø§Ù„ØªØ¹Ù„ÙŠÙ… Ø§Ù„Ø°ÙƒÙŠØ©
              </h2>
              <p className="mt-6 text-lg text-muted-foreground max-w-xl mx-auto lg:mx-0">
                Ù†Ø­Ù† Ù†Ù‚Ø¯Ù… ØªØ¬Ø±Ø¨Ø© ØªØ¹Ù„ÙŠÙ…ÙŠØ© ÙØ±ÙŠØ¯Ø© ÙˆØ´Ø®ØµÙŠØ©ØŒ Ù…Ø¯Ø¹ÙˆÙ…Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¹Ù„Ù‰ Ø§Ù„ØªÙÙˆÙ‚ØŒ ÙˆØªÙ…ÙƒÙŠÙ† Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ† Ù…Ù† Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ØŒ ÙˆØ·Ù…Ø£Ù†Ø© Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±.
              </p>
              <div className="mt-8 flex justify-center lg:justify-start gap-4">
                  <Link href="/signup" passHref>
                      <Button size="lg">Ø§Ø¨Ø¯Ø£ Ø±Ø­Ù„ØªÙƒ Ø§Ù„Ø¢Ù†</Button>
                  </Link>
                  <Link href="#features" passHref>
                      <Button size="lg" variant="outline">
                      Ø§ÙƒØªØ´Ù Ø§Ù„Ù…ÙŠØ²Ø§Øª
                      </Button>
                  </Link>
              </div>
            </div>
            <div className="lg:w-1/2">
              <Image
                //src="https://images.unsplash.com/photo-1522202176988-66273c2fd55f?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3NDE5ODJ8MHwxfHNlYXJjaHwxfHxlZHVjYXRpb24lMjB0ZWNobm9sb2d5fGVufDB8fHx8MTc2NTA2MTI4MHww&ixlib.rb-4.1.0&q=80&w=1080"
                //src="/images/landing/kenny-eliason.jpg"
                src="/images/landing/kenny-eliason.jpg"
                alt="Ø·Ù„Ø§Ø¨ Ø³Ø¹Ø¯Ø§Ø¡ ÙŠØ³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„ØªÙƒÙ†ÙˆÙ„ÙˆØ¬ÙŠØ§ ÙÙŠ Ø§Ù„ØªØ¹Ù„ÙŠÙ… Ø£Ùˆ Ù…ØªØ¹Ù„Ù… ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ Ø£Ùˆ Ø·Ù„Ø§Ø¨ Ø¯Ø§Ø®Ù„ Ø§Ù„ÙØµÙ„"
                width={600}
                height={400}
                className="rounded-xl shadow-2xl"
                data-ai-hint="education technology"
              />
            </div>
          </div>
          
          <div className="w-full mt-20 text-center">
            <div className="grid grid-cols-2 md:grid-cols-4 gap-8">
                <div className="flex flex-col items-center p-4 rounded-lg">
                    <Users className="h-10 w-10 text-primary mb-3" />
                    <p className="text-3xl font-bold">{studentCount}</p>
                    <p className="text-muted-foreground mt-1">Ø·Ø§Ù„Ø¨ Ù…Ø³Ø¬Ù„</p>
                </div>
                 <div className="flex flex-col items-center p-4 rounded-lg">
                    <Users className="h-10 w-10 text-primary mb-3" />
                    <p className="text-3xl font-bold">{teacherCount}</p>
                    <p className="text-muted-foreground mt-1">Ù…Ø¹Ù„Ù… ÙˆÙ…Ø´Ø±Ù</p>
                </div>
                 <div className="flex flex-col items-center p-4 rounded-lg">
                    <BookCopy className="h-10 w-10 text-primary mb-3" />
                    <p className="text-3xl font-bold">{lessonCount}</p>
                    <p className="text-muted-foreground mt-1">Ø¯Ø±Ø³ Ù…ØªØ§Ø­</p>
                </div>
                 <div className="flex flex-col items-center p-4 rounded-lg">
                    <FileQuestion className="h-10 w-10 text-primary mb-3" />
                    <p className="text-3xl font-bold">{exerciseCount}</p>
                    <p className="text-muted-foreground mt-1">ØªÙ…Ø±ÙŠÙ† Ù…ØªØ§Ø­</p>
                </div>
            </div>
          </div>

        </section>

        <section id="features" className="py-20 bg-muted/50">
            <div className="container mx-auto px-4 sm:px-6 lg:px-8">
                <div className="text-center mb-12">
                    <h3 className="text-3xl font-bold">Ù„Ù…Ø§Ø°Ø§ ØªØ®ØªØ§Ø± SmartEduØŸ</h3>
                    <p className="text-muted-foreground mt-2">Ù…Ù†ØµØ© Ù…ØªÙƒØ§Ù…Ù„Ø© ØªÙ„Ø¨ÙŠ Ø§Ø­ØªÙŠØ§Ø¬Ø§Øª Ø§Ù„Ø¬Ù…ÙŠØ¹ ÙÙŠ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©.</p>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                    <Card className="text-center">
                        <CardHeader>
                            <div className="mx-auto bg-primary/10 text-primary w-16 h-16 rounded-full flex items-center justify-center mb-4">
                                <Bot className="w-8 h-8" />
                            </div>
                            <CardTitle>ØªÙ‚ÙŠÙŠÙ… Ø°ÙƒÙŠ ÙÙˆØ±ÙŠ</CardTitle>
                        </CardHeader>
                        <CardContent>
                            <p className="text-muted-foreground">ÙŠØ­ØµÙ„ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¹Ù„Ù‰ ØªÙ‚ÙŠÙŠÙ… ÙÙˆØ±ÙŠ Ù„Ø¥Ø¬Ø§Ø¨Ø§ØªÙ‡Ù… Ù…Ø¯Ø¹ÙˆÙ… Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠØŒ Ù…Ù…Ø§ ÙŠØ³Ø§Ø¹Ø¯Ù‡Ù… Ø¹Ù„Ù‰ Ø§Ù„ØªØ¹Ù„Ù… Ø¨Ø´ÙƒÙ„ Ø£Ø³Ø±Ø¹ ÙˆØ£ÙƒØ«Ø± ÙØ¹Ø§Ù„ÙŠØ©.</p>
                        </CardContent>
                    </Card>
                     <Card className="text-center">
                        <CardHeader>
                            <div className="mx-auto bg-primary/10 text-primary w-16 h-16 rounded-full flex items-center justify-center mb-4">
                                <BarChart className="w-8 h-8" />
                            </div>
                            <CardTitle>Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªÙ‚Ø¯Ù…</CardTitle>
                        </CardHeader>
                        <CardContent>
                            <p className="text-muted-foreground">Ù„ÙˆØ­Ø§Øª ØªØ­ÙƒÙ… Ù…Ø®ØµØµØ© Ù„Ù„Ù…Ø¹Ù„Ù…ÙŠÙ† ÙˆØ£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ± Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø·Ù„Ø§Ø¨ ÙˆØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„Ù„Ø§Ø²Ù… ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨.</p>
                        </CardContent>
                    </Card>
                     <Card className="text-center">
                        <CardHeader>
                            <div className="mx-auto bg-primary/10 text-primary w-16 h-16 rounded-full flex items-center justify-center mb-4">
                                <Users className="w-8 h-8" />
                            </div>
                            <CardTitle>Ø£Ø¯ÙˆØ§Ø± Ù…ØªØ¹Ø¯Ø¯Ø©</CardTitle>
                        </CardHeader>
                        <CardContent>
                            <p className="text-muted-foreground">ØªØ¬Ø±Ø¨Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø®ØµØµØ© Ù„ÙƒÙ„ Ø¯ÙˆØ± (Ø·Ø§Ù„Ø¨ØŒ Ù…Ø¹Ù„Ù…ØŒ ÙˆÙ„ÙŠ Ø£Ù…Ø±ØŒ Ù…Ø¯ÙŠØ±) Ù„ØªÙ„Ø¨ÙŠØ© Ø§Ø­ØªÙŠØ§Ø¬Ø§ØªÙ‡Ù… Ø§Ù„ÙØ±ÙŠØ¯Ø©.</p>
                        </CardContent>
                    </Card>
                </div>
            </div>
        </section>
        
        <section className="py-20">
            <div className="container mx-auto px-4 sm:px-6 lg:px-8">
                <div className="text-center mb-12">
                    <h3 className="text-3xl font-bold">Ø£Ø¨Ø·Ø§Ù„ SmartEdu</h3>
                    <p className="text-muted-foreground mt-2">Ù†Ø­ØªÙÙŠ Ø¨Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…ØªÙÙˆÙ‚ÙŠÙ† ÙÙŠ ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰ Ø¯Ø±Ø§Ø³ÙŠ.</p>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-4xl mx-auto">
                    {topStudents.length > 0 ? (
                        topStudents.map((student) => (
                            <Card key={student.id} className="overflow-hidden">
                                <CardHeader className="bg-primary/5 p-4">
                                    <CardTitle className="text-center text-primary">{student.levelName}</CardTitle>
                                </CardHeader>
                                <CardContent className="p-6 flex flex-col items-center text-center">
                                    <div className="relative mb-4">
                                        <Avatar className="h-24 w-24 border-4 border-primary">
                                            <AvatarFallback>{student.firstName.charAt(0)}</AvatarFallback>
                                        </Avatar>
                                        <Badge className="absolute -bottom-2 -right-2 text-lg p-2" variant="destructive">
                                            <Star className="ml-1 h-5 w-5 fill-current" />
                                            <span>#1</span>
                                        </Badge>
                                    </div>
                                    <h4 className="text-xl font-semibold">{student.firstName} {student.lastName}</h4>
                                    <p className="text-muted-foreground">Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª: <span className="font-bold text-primary">{student.averageScore.toFixed(1)}%</span></p>
                                </CardContent>
                            </Card>
                        ))
                    ) : (
                        <div className="col-span-full text-center text-muted-foreground">
                            <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ù…ØªÙÙˆÙ‚ÙŠÙ† Ø­Ø§Ù„ÙŠÙ‹Ø§</p>
                        </div>
                    )}
                </div>
            </div>
        </section>

        <section className="py-20 bg-muted/50">
            <div className="container mx-auto px-4 sm:px-6 lg:px-8">
                <div className="text-center mb-12">
                    <h3 className="text-3xl font-bold">Ø¢Ø±Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†Ø§</h3>
                    <p className="text-muted-foreground mt-2">Ù…Ø§Ø°Ø§ ÙŠÙ‚ÙˆÙ„ÙˆÙ† Ø¹Ù† ØªØ¬Ø±Ø¨ØªÙ‡Ù… Ù…Ø¹ SmartEdu.</p>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                    <Card>
                        <CardContent className="pt-6">
                            <div className="flex items-center mb-4">
                                <Avatar className="h-12 w-12 ml-4">
                                    <AvatarImage src="https://images.unsplash.com/photo-1708426238272-994fcddabca4?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3NDE5ODJ8MHwxfHNlYXJjaHwxfHxwb3J0cmFpdCUyMHBlcnNvbnxlbnwwfHx8fDE3NjQ4ODQ5ODV8MA&ixlib=rb-4.1.0&q=80&w=1080" />
                                    <AvatarFallback>Ù</AvatarFallback>
                                </Avatar>
                                <div>
                                    <p className="font-semibold">ÙØ§Ø·Ù…Ø© Ø§Ù„ØºØ§Ù…Ø¯ÙŠ</p>
                                    <p className="text-sm text-muted-foreground">Ø·Ø§Ù„Ø¨Ø©</p>
                                </div>
                            </div>
                            <p className="text-muted-foreground">"Ø£Ø­Ø¨ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ feedback ÙÙˆØ±ÙŠØŒ Ù‡Ø°Ø§ ÙŠØ³Ø§Ø¹Ø¯Ù†ÙŠ Ø¹Ù„Ù‰ ÙÙ‡Ù… Ø£Ø®Ø·Ø§Ø¦ÙŠ Ø¨Ø³Ø±Ø¹Ø© ÙˆØ§Ù„ØªØ­Ø³Ù† ÙÙŠ Ø¯Ø±Ø§Ø³ØªÙŠ."</p>
                        </CardContent>
                    </Card>
                    <Card>
                        <CardContent className="pt-6">
                             <div className="flex items-center mb-4">
                                <Avatar className="h-12 w-12 ml-4">
                                    <AvatarImage src="https://images.unsplash.com/photo-1580893472468-01373fe4c97e?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3NDE5ODJ8MHwxfHNlYXJjaHw0fHxwb3J0cmFpdCUyMHBlcnNvbnxlbnwwfHx8fDE3NjQ4ODQ5ODV8MA&ixlib.rb-4.1.0&q=80&w=1080" />
                                    <AvatarFallback>Ø£</AvatarFallback>
                                </Avatar>
                                <div>
                                    <p className="font-semibold">Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…ÙˆØ¯</p>
                                    <p className="text-sm text-muted-foreground">Ù…Ø¹Ù„Ù…</p>
                                </div>
                            </div>
                            <p className="text-muted-foreground">"Ø§Ù„Ù…Ù†ØµØ© ÙˆÙØ±Øª Ø¹Ù„ÙŠÙ‘ Ø§Ù„ÙƒØ«ÙŠØ± Ù…Ù† Ø§Ù„ÙˆÙ‚Øª ÙÙŠ ØªØµØ­ÙŠØ­ Ø§Ù„ÙˆØ§Ø¬Ø¨Ø§ØªØŒ ÙˆØ£Ø¹Ø·ØªÙ†ÙŠ Ø±Ø¤Ù‰ Ø¯Ù‚ÙŠÙ‚Ø© Ø¹Ù† Ù…Ø³ØªÙˆÙ‰ ÙƒÙ„ Ø·Ø§Ù„Ø¨."</p>
                        </CardContent>
                    </Card>
                     <Card>
                        <CardContent className="pt-6">
                            <div className="flex items-center mb-4">
                                <Avatar className="h-12 w-12 ml-4">
                                    <AvatarImage src="https://images.unsplash.com/photo-1576765974026-6a4a1f6a1a3e?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3w3NDE5ODJ8MHwxfHNlYXJjaHwxfHxwb3J0cmFpdCUyMG1hbnxlbnwwfHx8fDE3NjUxNzU4MjZ8MA&ixlib.rb-4.1.0&q=80&w=1080" />
                                    <AvatarFallback>Ø®</AvatarFallback>
                                </Avatar>
                                <div>
                                    <p className="font-semibold">Ø®Ø§Ù„Ø¯ Ø§Ù„ØºØ§Ù…Ø¯ÙŠ</p>
                                    <p className="text-sm text-muted-foreground">ÙˆÙ„ÙŠ Ø£Ù…Ø±</p>
                                </div>
                            </div>
                            <p className="text-muted-foreground">"Ø£Ø´Ø¹Ø± Ø¨Ø±Ø§Ø­Ø© Ø£ÙƒØ¨Ø± ÙˆØ£Ù†Ø§ Ø£ØªØ§Ø¨Ø¹ ØªÙ‚Ø¯Ù… Ø§Ø¨Ù†ØªÙŠ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ Ø¨Ø³Ù‡ÙˆÙ„Ø© Ø¹Ø¨Ø± Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…ÙØµÙ„Ø© Ø§Ù„ØªÙŠ ØªÙ‚Ø¯Ù…Ù‡Ø§ Ø§Ù„Ù…Ù†ØµØ©."</p>
                        </CardContent>
                    </Card>
                </div>
            </div>
        </section>

        <section className="bg-primary text-primary-foreground py-20">
             <div className="container mx-auto px-4 sm:px-6 lg:px-8 text-center">
                <h3 className="text-3xl font-bold">Ù‡Ù„ Ø£Ù†Øª Ù…Ø³ØªØ¹Ø¯ Ù„ØªØºÙŠÙŠØ± Ù…Ø³ØªÙ‚Ø¨Ù„ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ØŸ</h3>
                <p className="text-lg mt-4 max-w-2xl mx-auto">
                    Ø§Ù†Ø¶Ù… Ø¥Ù„Ù‰ Ø¢Ù„Ø§Ù Ø§Ù„Ø·Ù„Ø§Ø¨ ÙˆØ§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ† ÙˆØ£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ± Ø§Ù„Ø°ÙŠÙ† ÙŠØ«Ù‚ÙˆÙ† ÙÙŠ SmartEdu.
                </p>
                <div className="mt-8">
                     <Link href="/signup" passHref>
                        <Button size="lg" variant="secondary">
                            Ø£Ù†Ø´Ø¦ Ø­Ø³Ø§Ø¨Ùƒ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠ Ø§Ù„Ø¢Ù†
                        </Button>
                    </Link>
                </div>
            </div>
        </section>
      </main>

       <footer className="py-6 border-t bg-muted/30">
          <div className="container mx-auto px-4 sm:px-6 lg:px-8 text-center text-muted-foreground">
              <p>&copy; {new Date().getFullYear()} SmartEdu. Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ‚ Ù…Ø­ÙÙˆØ¸Ø©.</p>
          </div>
      </footer>
    </div>
  );
}


// ==========================================
// FILE: src/app/api/students/results/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const studentId = session.user.id; // Already a string

    // Get all submissions for this student
    const submissions = await prisma.submission.findMany({
      where: { studentId },
      orderBy: { submittedAt: 'desc' },
    });

    // Get related exercises and lessons
    const exerciseIds = submissions.map((s) => s.exerciseId);
    const exercises = await prisma.exercise.findMany({
      where: { id: { in: exerciseIds } },
      select: {
        id: true,
        question: true,
        lessonId: true,
      },
    });

    const lessonIds = [...new Set(exercises.map((e) => e.lessonId))];
    const lessons = await prisma.lesson.findMany({
      where: { id: { in: lessonIds } },
      select: {
        id: true,
        title: true,
      },
    });

    const exerciseMap = new Map(exercises.map((e) => [e.id, e]));
    const lessonMap = new Map(lessons.map((l) => [l.id, l]));

    // Transform to match frontend expectations
    const formattedSubmissions = submissions.map((sub) => {
      const exercise = exerciseMap.get(sub.exerciseId);
      const lesson = exercise ? lessonMap.get(exercise.lessonId) : null;

      return {
        id: sub.id,
        score: Number(sub.finalScore || 0),
        aiFeedback: sub.aiFeedback,
        submittedAt: sub.submittedAt.toISOString(),
        exercise: {
          id: exercise?.id || 0,
          question: exercise?.question || '',
          lesson: {
            id: lesson?.id || 0,
            title: lesson?.title || '',
          },
        },
      };
    });

    return NextResponse.json({
      success: true,
      data: {
        submissions: formattedSubmissions,
      },
    });
  } catch (error) {
    console.error("Error fetching results:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch results" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/students/stats/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/students/stats - Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø·Ø§Ù„Ø¨
export async function GET(request: NextRequest) {
  try {
    const session = await requireAuth();

    if (session.user.role !== 'student') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠÙ…ÙƒÙ†Ù‡Ù… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©', 403);
    }

    // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨
    const submissions = await prisma.submission.findMany({
      where: { studentId: session.user.id },
      include: {
        exercise: {
          include: {
            lesson: {
              select: {
                id: true,
                title: true,
              },
            },
          },
        },
      },
    });

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
    const totalSubmissions = submissions.length;
    
    // Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø© (Ø¯Ø±ÙˆØ³ ÙÙŠÙ‡Ø§ ØªÙ…Ø§Ø±ÙŠÙ† Ù…Ø­Ù„ÙˆÙ„Ø©)
    const completedLessons = new Set(
      submissions.map(s => s.exercise.lessonId)
    ).size;

    // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„Ø¯Ø±Ø¬Ø§Øª
    const totalScore = submissions.reduce((acc, s) => acc + (s.score || 0), 0);
    const maxPossibleScore = submissions.reduce((acc, s) => acc + (s.exercise.maxScore || 10), 0);
    const averageScore = maxPossibleScore > 0 
      ? Math.round((totalScore / maxPossibleScore) * 100) 
      : 0;

    // Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© (ØªÙ…Ø§Ø±ÙŠÙ† Ø¨Ø¯ÙˆÙ† Ø¥Ø¬Ø§Ø¨Ø©)
    // Ø£ÙˆÙ„Ø§Ù‹: Ø¬Ù„Ø¨ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ†
    const teacherLinks = await prisma.teacherStudentLink.findMany({
      where: { studentId: session.user.id },
      select: { teacherId: true },
    });
    const teacherIds = teacherLinks.map(link => link.teacherId);

    // Ø¬Ù„Ø¨ ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø·Ø§Ù„Ø¨
    const studentDetails = await prisma.userDetails.findUnique({
      where: { userId: session.user.id },
    });

    // Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ù…ØªØ§Ø­Ø© Ù„Ù„Ø·Ø§Ù„Ø¨
    const availableExercises = await prisma.exercise.findMany({
      where: {
        lesson: {
          OR: [
            { type: 'public' }, // Ø¯Ø±ÙˆØ³ Ø¹Ø§Ù…Ø©
            { authorId: { in: teacherIds } }, // Ø¯Ø±ÙˆØ³ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ†
          ],
          levelId: studentDetails?.levelId || undefined,
        },
      },
      select: { id: true },
    });

    const solvedExerciseIds = submissions.map(s => s.exerciseId);
    const pendingExercises = availableExercises.filter(
      ex => !solvedExerciseIds.includes(ex.id)
    ).length;

    return successResponse({
      stats: {
        completedLessons,
        totalSubmissions,
        averageScore,
        pendingExercises,
      },
    });
  } catch (error: any) {
    console.error('Error fetching student stats:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª', 500);
  }
}


// ==========================================
// FILE: src/app/api/students/connect-parent/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

// POST: Connect student to parent via parent code
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const studentId = session.user.id;
    const body = await request.json();
    const { parentCode } = body;

    if (!parentCode) {
      return NextResponse.json(
        { success: false, error: "Parent code is required" },
        { status: 400 }
      );
    }

    // Find parent by code
    const parentDetails = await prisma.userDetails.findUnique({
      where: { parentCode: parentCode.trim() },
      include: {
        user: {
          include: {
            role: true,
          },
        },
      },
    });

    if (!parentDetails) {
      return NextResponse.json(
        { success: false, error: "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ø¨Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯" },
        { status: 404 }
      );
    }

    if (parentDetails.user.role.name !== "parent") {
      return NextResponse.json(
        { success: false, error: "Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¯Ø®Ù„ Ù„Ø§ ÙŠÙ†ØªÙ…ÙŠ Ù„Ø­Ø³Ø§Ø¨ ÙˆÙ„ÙŠ Ø£Ù…Ø±" },
        { status: 400 }
      );
    }

    const parentId = parentDetails.userId;

    // Check if already linked
    const existingLink = await prisma.parentChildLink.findUnique({
      where: {
        parentId_childId: {
          parentId,
          childId: studentId,
        },
      },
    });

    if (existingLink) {
      return NextResponse.json(
        { success: false, error: "Ø£Ù†Øª Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ù‡Ø°Ø§" },
        { status: 400 }
      );
    }

    // Create link
    await prisma.parentChildLink.create({
      data: {
        parentId,
        childId: studentId,
      },
    });

    return NextResponse.json({
      success: true,
      data: {
        message: "ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ø¨Ù†Ø¬Ø§Ø­",
        parent: {
          id: parentDetails.user.id,
          firstName: parentDetails.user.firstName,
          lastName: parentDetails.user.lastName,
        },
      },
    });
  } catch (error) {
    console.error("Error connecting to parent:", error);
    return NextResponse.json(
      { success: false, error: "Failed to connect to parent" },
      { status: 500 }
    );
  }
}

// DELETE: Disconnect student from parent
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const studentId = session.user.id;
    const body = await request.json();
    const { parentId } = body;

    if (!parentId) {
      return NextResponse.json(
        { success: false, error: "Parent ID is required" },
        { status: 400 }
      );
    }

    // Delete link
    await prisma.parentChildLink.delete({
      where: {
        parentId_childId: {
          parentId,
          childId: studentId,
        },
      },
    });

    return NextResponse.json({
      success: true,
      data: {
        message: "ØªÙ… ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ø¨Ù†Ø¬Ø§Ø­",
      },
    });
  } catch (error) {
    console.error("Error disconnecting from parent:", error);
    return NextResponse.json(
      { success: false, error: "Failed to disconnect from parent" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/students/teachers/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/students/teachers - Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø¨Ø§Ù„Ø·Ø§Ù„Ø¨
export async function GET(request: NextRequest) {
  try {
    const session = await requireAuth();

    if (session.user.role !== 'student') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠÙ…ÙƒÙ†Ù‡Ù… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©', 403);
    }

    const teacherLinks = await prisma.teacherStudentLink.findMany({
      where: { studentId: session.user.id },
      include: {
        teacher: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            image: true,
            userDetails: {
              select: {
                teacherCode: true,
                subject: {
                  select: {
                    id: true,
                    name: true,
                  },
                },
              },
            },
          },
        },
      },
    });

    const teachers = teacherLinks.map(link => ({
      id: link.teacher.id,
      name: `${link.teacher.firstName} ${link.teacher.lastName}`,
      email: link.teacher.email,
      image: link.teacher.image,
      teacherCode: link.teacher.userDetails?.teacherCode,
      subject: link.teacher.userDetails?.subject,
    }));

    return successResponse({ teachers });
  } catch (error: any) {
    console.error('Error fetching teachers:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø£Ø³Ø§ØªØ°Ø©', 500);
  }
}


// ==========================================
// FILE: src/app/api/students/connect-teacher/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// POST /api/students/connect-teacher
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth();

    if (session.user.role !== 'student') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠÙ…ÙƒÙ†Ù‡Ù… Ø§Ù„Ø±Ø¨Ø· Ø¨Ø§Ù„Ø£Ø³ØªØ§Ø°', 403);
    }

    const body = await request.json();
    const { teacherCode } = body;

    if (!teacherCode) {
      return errorResponse('ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³ØªØ§Ø° Ù…Ø·Ù„ÙˆØ¨', 400);
    }

    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ø³ØªØ§Ø° Ø¨Ø§Ù„ÙƒÙˆØ¯
    const teacherDetails = await prisma.userDetails.findUnique({
      where: { teacherCode },
      include: {
        user: {
          include: {
            role: true,
          },
        },
      },
    });

    if (!teacherDetails || teacherDetails.user.role.name !== 'teacher') {
      return errorResponse('ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³ØªØ§Ø° ØºÙŠØ± ØµØ­ÙŠØ­', 404);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ Ø±Ø¨Ø· Ù…Ø³Ø¨Ù‚
    const existingLink = await prisma.teacherStudentLink.findUnique({
      where: {
        teacherId_studentId: {
          teacherId: teacherDetails.userId,
          studentId: session.user.id,
        },
      },
    });

    if (existingLink) {
      return errorResponse('Ø£Ù†Øª Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø£Ø³ØªØ§Ø°', 400);
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±Ø¨Ø·
    await prisma.teacherStudentLink.create({
      data: {
        teacherId: teacherDetails.userId,
        studentId: session.user.id,
      },
    });

    return successResponse(
      {
        teacher: {
          id: teacherDetails.user.id,
          name: `${teacherDetails.user.firstName} ${teacherDetails.user.lastName}`,
          email: teacherDetails.user.email,
        },
      },
      'ØªÙ… Ø§Ù„Ø±Ø¨Ø· Ø¨Ø§Ù„Ø£Ø³ØªØ§Ø° Ø¨Ù†Ø¬Ø§Ø­'
    );
  } catch (error: any) {
    console.error('Error connecting to teacher:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø±Ø¨Ø· Ø¨Ø§Ù„Ø£Ø³ØªØ§Ø°', 500);
  }
}

// DELETE /api/students/connect-teacher - ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·
export async function DELETE(request: NextRequest) {
  try {
    const session = await requireAuth();

    if (session.user.role !== 'student') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠÙ…ÙƒÙ†Ù‡Ù… ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·', 403);
    }

    const { searchParams } = new URL(request.url);
    const teacherId = searchParams.get('teacherId');

    if (!teacherId) {
      return errorResponse('Ù…Ø¹Ø±Ù Ø§Ù„Ø£Ø³ØªØ§Ø° Ù…Ø·Ù„ÙˆØ¨', 400);
    }

    // Ø­Ø°Ù Ø§Ù„Ø±Ø¨Ø·
    await prisma.teacherStudentLink.delete({
      where: {
        teacherId_studentId: {
          teacherId: teacherId,
          studentId: session.user.id,
        },
      },
    });

    return successResponse(null, 'ØªÙ… ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Error disconnecting from teacher:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ ÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø·', 500);
  }
}


// ==========================================
// FILE: src/app/api/students/progress/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const studentId = session.user.id; // Already a string

    // Get student details
    const student = await prisma.userDetails.findUnique({
      where: { userId: studentId },
      include: {
        level: {
          include: {
            subjects: true,
          },
        },
      },
    });

    if (!student) {
      return NextResponse.json(
        { success: false, error: "Student not found" },
        { status: 404 }
      );
    }

    // Get connected teachers
    const teacherLinks = await prisma.teacherStudentLink.findMany({
      where: { studentId },
      select: { teacherId: true },
    });
    const connectedTeacherIds = teacherLinks.map((link) => link.teacherId);

    // Get subjects for student's level
    const subjects = student.levelId 
      ? await prisma.subject.findMany({
          where: { levelId: student.levelId },
        })
      : [];

    // Get all submissions for this student
    const submissions = await prisma.submission.findMany({
      where: { studentId },
      orderBy: { submittedAt: 'desc' },
    });

    // Calculate progress per subject
    const subjectsProgress = await Promise.all(
      subjects.map(async (subject, index) => {
        // Get lessons for this subject
        const lessons = await prisma.lesson.findMany({
          where: { subjectId: subject.id },
          select: { id: true },
        });
        const lessonIds = lessons.map((l) => l.id);

        // Get exercises for these lessons
        const exercises = await prisma.exercise.findMany({
          where: { lessonId: { in: lessonIds } },
          select: { id: true, maxScore: true },
        });
        const exerciseIds = exercises.map((e) => e.id);

        // Filter submissions for this subject
        const subjectSubmissions = submissions.filter((sub) =>
          exerciseIds.includes(sub.exerciseId)
        );

        if (subjectSubmissions.length === 0) {
          return {
            subject: subject.name,
            score: 0,
            color: `hsl(var(--chart-${(index % 5) + 1}))`,
          };
        }

        // Calculate average score
        const totalScore = subjectSubmissions.reduce(
          (acc, sub) => acc + Number(sub.finalScore || 0),
          0
        );
        const totalPossible = subjectSubmissions.reduce((acc, sub) => {
          const exercise = exercises.find((e) => e.id === sub.exerciseId);
          return acc + Number(exercise?.maxScore || 10);
        }, 0);
        const average =
          totalPossible > 0
            ? Math.round((totalScore / totalPossible) * 100)
            : 0;

        return {
          subject: subject.name,
          score: average,
          color: `hsl(var(--chart-${(index % 5) + 1}))`,
        };
      })
    );

    // Get recent lessons
    // First, get exercises with their lessons
    const exercisesWithLessons = await prisma.exercise.findMany({
      where: {
        id: { in: submissions.map((s) => s.exerciseId) },
      },
      select: { id: true, lessonId: true },
    });

    const exerciseLessonMap = new Map<number, number>();
    exercisesWithLessons.forEach((ex) => {
      exerciseLessonMap.set(ex.id, ex.lessonId);
    });

    const lessonSubmissions = new Map<number, any[]>();
    submissions.forEach((sub) => {
      const lessonId = exerciseLessonMap.get(sub.exerciseId);
      if (lessonId) {
        if (!lessonSubmissions.has(lessonId)) {
          lessonSubmissions.set(lessonId, []);
        }
        lessonSubmissions.get(lessonId)?.push(sub);
      }
    });

    const recentLessonIds = Array.from(lessonSubmissions.keys()).slice(0, 3);
    const recentLessons = await Promise.all(
      recentLessonIds.map(async (lessonId) => {
        const lesson = await prisma.lesson.findUnique({
          where: { id: lessonId },
          select: {
            id: true,
            title: true,
          },
        });

        if (!lesson) return null;

        // Get all exercises for this lesson
        const lessonExercises = await prisma.exercise.findMany({
          where: { lessonId },
          select: { id: true },
        });

        const totalExercises = lessonExercises.length;
        const solvedExercises = lessonExercises.filter((ex) =>
          submissions.some((sub) => sub.exerciseId === ex.id)
        ).length;

        const progress =
          totalExercises > 0
            ? Math.round((solvedExercises / totalExercises) * 100)
            : 0;

        return {
          id: lesson.id,
          title: lesson.title,
          progress,
        };
      })
    );

    return NextResponse.json({
      success: true,
      data: {
        subjectsProgress,
        recentLessons: recentLessons.filter((lesson) => lesson !== null),
      },
    });
  } catch (error) {
    console.error("Error fetching progress:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch progress" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/students/parents/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const studentId = session.user.id;

    // Get linked parents
    const parentLinks = await prisma.parentChildLink.findMany({
      where: { childId: studentId },
      include: {
        parent: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
      },
    });

    const parents = parentLinks.map((link) => ({
      id: link.parent.id,
      firstName: link.parent.firstName,
      lastName: link.parent.lastName,
      email: link.parent.email,
    }));

    return NextResponse.json({
      success: true,
      data: {
        parents,
      },
    });
  } catch (error) {
    console.error("Error fetching parents:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch parents" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/notifications/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©
    await requireAuth();

    // Ø¥Ø±Ø¬Ø§Ø¹ Ù‚Ø§Ø¦Ù…Ø© ÙØ§Ø±ØºØ© Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
    // TODO: Ø±Ø¨Ø· Ù‡Ø°Ø§ Ø¨Ø¬Ø¯ÙˆÙ„ Notifications ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø§Ø­Ù‚Ø§Ù‹
    return successResponse({
      notifications: [],
      unreadCount: 0
    });
  } catch (error: any) {
    return errorResponse(error.message || 'Failed to fetch notifications', 500);
  }
}

export async function PATCH(request: NextRequest) {
  try {
    await requireAuth();
    return successResponse(null, 'Notifications updated');
  } catch (error: any) {
    return errorResponse(error.message || 'Failed to update notifications', 500);
  }
}

// ==========================================
// FILE: src/app/api/upload/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { requireAuth } from '@/lib/api-auth';
import { errorResponse, successResponse } from '@/lib/api-response';
import { uploadFileToHierarchy } from '@/lib/google-drive';

export async function POST(request: NextRequest) {
  try {
    await requireAuth();

    const formData = await request.formData();
    const file = formData.get('file') as File | null;
    
    // Ø¯Ø¹Ù… Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© ÙˆØ§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø­Ù‚ÙˆÙ„ Ù„Ø¶Ù…Ø§Ù† Ø§Ù„ØªÙˆØ§ÙÙ‚
    const stage = ((formData.get('stage') || formData.get('stageName')) as string)?.trim();
    const subject = ((formData.get('subject') || formData.get('subjectName')) as string)?.trim();
    const teacher = ((formData.get('teacher') || formData.get('teacherName')) as string)?.trim();
    const lesson = ((formData.get('lesson') || formData.get('lessonName')) as string)?.trim();

    console.log(`[API] ğŸ“¥ Received Upload Request: Stage=${stage}, Subject=${subject}, Teacher=${teacher}, Lesson=${lesson}`);

    if (!file) {
      return errorResponse('Ø§Ù„Ù…Ù„Ù Ù…Ø·Ù„ÙˆØ¨', 400);
    }

    if (!stage || !subject || !teacher || !lesson) {
      return errorResponse('Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨Ø© (Ø§Ù„Ù…Ø±Ø­Ù„Ø©ØŒ Ø§Ù„Ù…Ø§Ø¯Ø©ØŒ Ø§Ù„Ø£Ø³ØªØ§Ø°ØŒ Ø§Ù„Ø¯Ø±Ø³)', 400);
    }
    
    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø¥Ù„Ù‰ Buffer
    const fileBuffer = Buffer.from(await file.arrayBuffer());

    // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù‡Ø±Ù…ÙŠØ©
    const hierarchy = [stage, subject, teacher, lesson];
    console.log(`[API] ğŸ—ºï¸ Hierarchy to resolve: ${JSON.stringify(hierarchy)}`);

    // Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    const driveResult = await uploadFileToHierarchy(
      fileBuffer,
      file.name,
      file.type,
      hierarchy
    );

    // ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ø¯Ø±Ø³ Ù‡Ù†Ø§ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
    // Ø³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¯Ø±Ø³ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ Ø¹Ù†Ø¯ Ø¶ØºØ· Ø²Ø± "Ø­ÙØ¸" ÙÙŠ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø¹Ù„Ù…

    return successResponse(
      { 
        fileId: driveResult.fileId, 
        fileName: file.name, 
        fileUrl: driveResult.webViewLink
      },
      'ØªÙ… Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­',
      201
    );
  } catch (error: any) {
    console.error('Upload API Error:', error);
    if (error.message.includes('Authentication required')) {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø¨Ø§Ù„Ù‚ÙŠØ§Ù… Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡', 401);
    }
    return errorResponse(error.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹', 500);
  }
}


// ==========================================
// FILE: src/app/api/logs/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { getLogs, LogLevel, LogCategory } from '@/lib/logger';

/**
 * Get system logs with filters
 * GET /api/logs?level=INFO&category=AUTH&startDate=...&endDate=...&limit=50&offset=0
 * Only accessible by Director role
 */
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    // Check if user is Director
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { role: true }
    });

    if (user?.role.name !== 'directeur') {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - Ù…Ø®ØµØµ Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·' }, { status: 403 });
    }

    // Parse query parameters
    const searchParams = req.nextUrl.searchParams;
    const level = searchParams.get('level') as LogLevel | undefined;
    const category = searchParams.get('category') as LogCategory | undefined;
    const userId = searchParams.get('userId') || undefined;
    const startDate = searchParams.get('startDate') ? new Date(searchParams.get('startDate')!) : undefined;
    const endDate = searchParams.get('endDate') ? new Date(searchParams.get('endDate')!) : undefined;
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');

    const { logs, total } = await getLogs({
      level,
      category,
      userId,
      startDate,
      endDate,
      limit,
      offset
    });

    return NextResponse.json({
      logs,
      total,
      page: Math.floor(offset / limit) + 1,
      totalPages: Math.ceil(total / limit)
    });

  } catch (error: any) {
    console.error('Logs fetch error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¬Ù„Ø§Øª' },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/levels/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/levels?stageId=1
export async function GET(request: NextRequest) {
  try {
    // No auth required for signup page
    const { searchParams } = new URL(request.url);
    const stageId = searchParams.get('stageId');

    const where: any = {};
    if (stageId) {
      where.stageId = parseInt(stageId);
    }

    const levels = await prisma.level.findMany({
      where,
      orderBy: { displayOrder: 'asc' },
      include: {
        stage: true,
        _count: {
          select: {
            subjects: true,
          },
        },
      },
    });

    return successResponse(levels, `ØªÙ… Ø¬Ù„Ø¨ ${levels.length} Ù…Ø³ØªÙˆÙ‰`);
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª', 500);
  }
}

// POST /api/levels
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth();

    if (session.user.role !== 'directeur') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª', 403);
    }

    const body = await request.json();
    const { name, stageId, displayOrder } = body;

    if (!name || !stageId) {
      return errorResponse('Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙˆØ§Ù„Ù…Ø±Ø­Ù„Ø© Ù…Ø·Ù„ÙˆØ¨Ø©', 400);
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¢Ø®Ø± displayOrder Ø¥Ø°Ø§ Ù„Ù… ÙŠÙØ­Ø¯Ø¯
    let order = displayOrder;
    if (!order) {
      const lastLevel = await prisma.level.findFirst({
        where: { stageId: parseInt(stageId) },
        orderBy: { displayOrder: 'desc' },
      });
      order = lastLevel ? lastLevel.displayOrder + 1 : 1;
    }

    const level = await prisma.level.create({
      data: {
        name,
        stageId: parseInt(stageId),
        displayOrder: order,
      },
      include: {
        stage: true,
      },
    });

    return successResponse(level, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¨Ù†Ø¬Ø§Ø­', 201);
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙ‰', 500);
  }
}

/**
 * Delete a level
 * DELETE /api/levels?id=<levelId>
 * Only accessible by Director
 */
export async function DELETE(request: NextRequest) {
    try {
        const session = await requireAuth();
        if (session.user.role !== 'directeur') {
            return errorResponse('ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª', 403);
        }

        const { searchParams } = new URL(request.url);
        const levelId = searchParams.get('id');

        if (!levelId) {
            return errorResponse('Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ù…Ø·Ù„ÙˆØ¨', 400);
        }

        const levelToDelete = await prisma.level.findUnique({
            where: { id: parseInt(levelId) },
        });

        if (!levelToDelete) {
            return errorResponse('Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 404);
        }

        // 1. Delete associated Google Drive folder if exists
        if (levelToDelete.driveFolderId) {
            try {
                await GoogleDriveService.deleteFolder(levelToDelete.driveFolderId);
            } catch (gdError: any) {
                console.error(`Failed to delete Google Drive folder for level ${levelId}:`, gdError);
                // Log and proceed with DB deletion to maintain app data integrity
            }
        }

        // 2. Delete the level from the database
        await prisma.level.delete({
            where: { id: parseInt(levelId) },
        });

        return successResponse(null, 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ÙˆØ§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø±ØªØ¨Ø· Ø¨Ù‡ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error: any) {
        console.error('Level deletion error:', error);
        return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆÙ‰', 500);
    }
}



// ==========================================
// FILE: src/app/api/submissions/[id]/evaluate/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

// Helper function to notify parent
async function notifyParent(prisma: PrismaClient, studentId: string, submissionId: number) {
  try {
    // Get parent link
    const parentLink = await prisma.parentChildLink.findFirst({
      where: { childId: studentId },
      select: { parentId: true },
    });

    if (parentLink) {
      // Get submission details
      const submission = await prisma.submission.findUnique({
        where: { id: submissionId },
        include: {
          exercise: {
            include: {
              lesson: {
                include: { subject: true },
              },
            },
          },
          student: {
            select: {
              firstName: true,
              lastName: true,
            },
          },
        },
      });

      if (submission) {
        const score = Number(submission.finalScore || submission.aiScore || 0);
        const maxScore = Number(submission.exercise.maxScore || 20);
        const percentage = Math.round((score / maxScore) * 100);
        const studentName = `${submission.student.firstName} ${submission.student.lastName}`;
        const subjectName = submission.exercise.lesson.subject.name;
        const lessonTitle = submission.exercise.lesson.title;

        let message = '';
        if (percentage >= 80) {
          message = `ğŸ‰ Ø£Ø­Ø³Ù†Øª! Ø­ØµÙ„ ${studentName} Ø¹Ù„Ù‰ ${score}/${maxScore} (${percentage}%) ÙÙŠ ${subjectName} - ${lessonTitle}`;
        } else if (percentage >= 60) {
          message = `âœ… Ø­ØµÙ„ ${studentName} Ø¹Ù„Ù‰ ${score}/${maxScore} (${percentage}%) ÙÙŠ ${subjectName} - ${lessonTitle}`;
        } else {
          message = `âš ï¸ ÙŠØ­ØªØ§Ø¬ ${studentName} Ø¥Ù„Ù‰ Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªØ¯Ø±ÙŠØ¨. Ø­ØµÙ„ Ø¹Ù„Ù‰ ${score}/${maxScore} (${percentage}%) ÙÙŠ ${subjectName} - ${lessonTitle}`;
        }

        // Create notification (you can extend this to send email/SMS later)
        await prisma.notification.create({
          data: {
            userId: parentLink.parentId,
            title: 'Ù†ØªÙŠØ¬Ø© Ø¬Ø¯ÙŠØ¯Ø©',
            message,
            type: 'submission_graded',
            relatedId: submissionId,
            isRead: false,
          },
        });
      }
    }
  } catch (error) {
    console.error('Error notifying parent:', error);
    // Don't throw - notification failure shouldn't break the main flow
  }
}
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// POST /api/submissions/[id]/evaluate - ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await requireAuth();
    const { id } = await params;
    const submissionId = parseInt(id);

    console.log('ğŸ” Evaluating submission ID:', submissionId);

    const submission = await prisma.submission.findUnique({
      where: { id: submissionId },
      include: {
        exercise: {
          select: {
            id: true,
            question: true,
            modelAnswer: true,
            maxScore: true,
          },
        },
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
      },
    });

    console.log('ğŸ“„ Submission found:', submission ? 'Yes' : 'No');
    
    if (!submission) {
      return errorResponse('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©', 404);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª
    if (session.user.role === 'student' && submission.studentId !== session.user.id) {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„', 403);
    }

    // Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
    // TODO: Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ AI Ù„Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ÙØ¹Ù„ÙŠ
    const feedback = `ØªÙ‚ÙŠÙŠÙ… ØªÙ„Ù‚Ø§Ø¦ÙŠ:\n\n` +
      `Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø­Ù„ Ø§Ù„ØªÙ…Ø±ÙŠÙ†. ` +
      `\n\nÙ…Ù„Ø§Ø­Ø¸Ø§Øª:\n` +
      `- Ø­Ø§ÙˆÙ„ Ø´Ø±Ø­ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ø¨Ø´ÙƒÙ„ Ø£ÙˆØ¶Ø­.\n` +
      `- Ø±Ø§Ø¬Ø¹ Ø§Ù„Ø¯Ø±Ø³ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙÙ‡Ù…Ùƒ Ø§Ù„ÙƒØ§Ù…Ù„ Ù„Ù„Ù…ÙˆØ¶ÙˆØ¹.\n` +
      `- Ù‚Ø§Ø±Ù† Ø¥Ø¬Ø§Ø¨ØªÙƒ Ù…Ø¹ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ© Ø£Ø¹Ù„Ø§Ù‡.`;

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¯Ø±Ø¬Ø© (Ø¨Ø´ÙƒÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù„Ø¢Ù† - Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù€ AI)
    const maxScoreValue = submission.exercise.maxScore ? parseFloat(submission.exercise.maxScore.toString()) : 20;
    const calculatedScore = Math.floor(Math.random() * (maxScoreValue + 1));

    console.log('ğŸ“Š Max score:', maxScoreValue, 'Generated score:', calculatedScore);

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
    const updatedSubmission = await prisma.submission.update({
      where: { id: submissionId },
      data: {
        aiScore: calculatedScore,
        finalScore: calculatedScore,
        aiFeedback: feedback,
        gradedAt: new Date(),
        status: 'graded',
      },
      include: {
        exercise: {
          select: {
            id: true,
            question: true,
            maxScore: true,
          },
        },
      },
    });

    console.log('âœ… Submission updated successfully');

    // Send notification to parent
    await notifyParent(prisma, submission.studentId, submissionId);

    return successResponse(updatedSubmission, 'ØªÙ… ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Error evaluating submission:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©', 500);
  }
}


// ==========================================
// FILE: src/app/api/submissions/[id]/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse, notFoundResponse } from '@/lib/api-response';

// PATCH /api/submissions/[id] - ØªØµØ­ÙŠØ­ Ø§Ù„Ù…Ø¹Ù„Ù…
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await requireAuth();

    // ÙÙ‚Ø· Ø§Ù„Ù…Ø¹Ù„Ù…ÙˆÙ† ÙˆØ§Ù„Ù…Ø´Ø±ÙÙˆÙ† ÙŠÙ…ÙƒÙ†Ù‡Ù… Ø§Ù„ØªØµØ­ÙŠØ­
    if (!['teacher', 'supervisor_specific', 'supervisor_general', 'directeur'].includes(session.user.role)) {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ØªØµØ­ÙŠØ­', 403);
    }

    const submissionId = parseInt(params.id);
    const body = await request.json();
    const { finalScore, teacherNotes, status } = body;

    const submission = await prisma.submission.findUnique({
      where: { id: submissionId },
      include: {
        exercise: {
          include: {
            lesson: true,
          },
        },
      },
    });

    if (!submission) {
      return notFoundResponse('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø¹Ù„Ù… Ù‡Ùˆ Ù…Ø¹Ù„Ù… Ø§Ù„Ø¯Ø±Ø³
    if (session.user.role === 'teacher' && submission.exercise.lesson.authorId !== session.user.id) {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨ØªØµØ­ÙŠØ­ Ù‡Ø°Ù‡ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©', 403);
    }

    const updateData: any = {};
    if (finalScore !== undefined) updateData.finalScore = parseFloat(finalScore);
    if (teacherNotes !== undefined) updateData.teacherNotes = teacherNotes;
    if (status !== undefined) updateData.status = status;

    const updatedSubmission = await prisma.submission.update({
      where: { id: submissionId },
      data: updateData,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            image: true,
          },
        },
        exercise: {
          include: {
            lesson: true,
          },
        },
      },
    });

    return successResponse(updatedSubmission, 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØµØ­ÙŠØ­ Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Error updating submission:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØµØ­ÙŠØ­', 500);
  }
}


// ==========================================
// FILE: src/app/api/submissions/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/submissions?studentId=xxx&exerciseId=xxx
export async function GET(request: NextRequest) {
  try {
    const session = await requireAuth();
    const { searchParams } = new URL(request.url);

    const studentId = searchParams.get('studentId');
    const exerciseId = searchParams.get('exerciseId');
    const lessonId = searchParams.get('lessonId');
    const status = searchParams.get('status');

    const where: any = {};

    // Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠØ±ÙˆÙ† Ø¥Ø¬Ø§Ø¨Ø§ØªÙ‡Ù… ÙÙ‚Ø·
    if (session.user.role === 'student') {
      where.studentId = session.user.id;
    } else if (studentId) {
      where.studentId = studentId;
    }

    if (exerciseId) where.exerciseId = parseInt(exerciseId);
    if (status) where.status = status;

    // Ø¥Ø°Ø§ ÙƒØ§Ù† lessonId Ù…ÙˆØ¬ÙˆØ¯ØŒ Ù†Ø­ØªØ§Ø¬ Ù„Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ù…Ø¹ exercises
    if (lessonId) {
      const exercisesInLesson = await prisma.exercise.findMany({
        where: { lessonId: parseInt(lessonId) },
        select: { id: true },
      });
      where.exerciseId = {
        in: exercisesInLesson.map(e => e.id),
      };
    }

    const submissions = await prisma.submission.findMany({
      where,
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            image: true,
          },
        },
        exercise: {
          include: {
            lesson: {
              select: {
                id: true,
                title: true,
              },
            },
          },
        },
      },
      orderBy: { submittedAt: 'desc' },
    });

    return successResponse({ submissions });
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª', 500);
  }
}

// POST /api/submissions - Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø¬Ø§Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth();

    // ÙÙ‚Ø· Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠÙ…ÙƒÙ†Ù‡Ù… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª
    if (session.user.role !== 'student') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠÙ…ÙƒÙ†Ù‡Ù… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª', 403);
    }

    const body = await request.json();
    const { exerciseId, answerText, answerRichContent, submissionFileUrl } = body;

    // Ù‚Ø¨ÙˆÙ„ answerText Ø£Ùˆ answerRichContent
    const answer = answerRichContent || answerText;

    if (!exerciseId || !answer) {
      return errorResponse('Ù…Ø¹Ø±Ù Ø§Ù„ØªÙ…Ø±ÙŠÙ† ÙˆØ§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ù…Ø·Ù„ÙˆØ¨Ø©', 400);
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ù…Ø¹ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©
    const exercise = await prisma.exercise.findUnique({
      where: { id: parseInt(exerciseId) },
    });

    if (!exercise) {
      return errorResponse('Ø§Ù„ØªÙ…Ø±ÙŠÙ† ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 404);
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
    const previousAttempts = await prisma.submission.count({
      where: {
        studentId: session.user.id,
        exerciseId: parseInt(exerciseId),
      },
    });

    // ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡
    // Ø³ÙŠØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± "ØªÙ‚ÙŠÙŠÙ…" ÙŠØ¯ÙˆÙŠØ§Ù‹
    let aiFeedback = null;
    let aiScore = null;

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©
    const submission = await prisma.submission.create({
      data: {
        studentId: session.user.id,
        exerciseId: parseInt(exerciseId),
        answerText: answerText || null,
        answerRichContent: answerRichContent || null,
        submissionFileUrl: submissionFileUrl || null,
        attemptNumber: previousAttempts + 1,
        aiFeedback,
        aiScore: aiScore ? parseFloat(aiScore.toFixed(2)) : null,
        status: 'pending',
      },
      include: {
        exercise: {
          include: {
            lesson: true,
          },
        },
      },
    });

    return successResponse(
      submission,
      aiFeedback ? 'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙˆØªÙ‚ÙŠÙŠÙ…Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­' : 'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­',
      201
    );
  } catch (error: any) {
    console.error('Error creating submission:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©', 500);
  }
}


// ==========================================
// FILE: src/app/api/auth/signup/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { successResponse, errorResponse } from '@/lib/api-response';
import bcrypt from 'bcryptjs';

// POST /api/auth/signup - ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const {
      firstName,
      lastName,
      email,
      password,
      roleName, // student, teacher, parent
      stageId,
      levelId,
      subjectId,
    } = body;

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    if (!firstName || !lastName || !email || !password || !roleName) {
      return errorResponse('Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨Ø©', 400);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø·ÙˆÙ„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    if (password.length < 6) {
      return errorResponse('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„', 400);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return errorResponse('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ­ÙŠØ­', 400);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return errorResponse('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„', 400);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡ (Ø§Ù„Ù…Ø¯ÙŠØ± Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ³Ø¬ÙŠÙ„Ù‡ Ø¹Ø¨Ø± Ø§Ù„ØµÙØ­Ø©)
    if (!['student', 'teacher', 'parent'].includes(roleName)) {
      return errorResponse('Ø§Ù„Ø¯ÙˆØ± ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡', 400);
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¯ÙˆØ±
    const role = await prisma.role.findFirst({
      where: { name: roleName },
    });

    if (!role) {
      return errorResponse('Ø§Ù„Ø¯ÙˆØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 400);
    }

    // ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    const hashedPassword = await bcrypt.hash(password, 10);

    // Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ ÙØ±ÙŠØ¯ Ù„Ù„Ù…Ø¹Ù„Ù… Ø£Ùˆ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±
    let teacherCode: string | undefined;
    let parentCode: string | undefined;

    if (roleName === 'teacher') {
      teacherCode = `T${Date.now().toString().slice(-6)}`;
    } else if (roleName === 'parent') {
      parentCode = `P${Date.now().toString().slice(-6)}`;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ Ø§Ù„ØªÙØ§ØµÙŠÙ„
    const user = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: hashedPassword,
        roleId: role.id,
        userDetails: {
          create: {
            stageId: stageId ? parseInt(stageId) : null,
            levelId: levelId ? parseInt(levelId) : null,
            subjectId: subjectId ? parseInt(subjectId) : null,
            teacherCode,
            parentCode,
            aiEvalMode: roleName === 'student' ? 'auto' : 'manual',
          },
        },
      },
      include: {
        role: true,
        userDetails: true,
      },
    });

    // Ø¥Ø²Ø§Ù„Ø© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
    const { password: _, ...userWithoutPassword } = user;

    return successResponse(
      {
        user: userWithoutPassword,
        message: 'ØªÙ… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­! ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„.',
      },
      'ØªÙ… Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­',
      201
    );
  } catch (error: any) {
    console.error('Error in signup:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø§Ù„ØªØ³Ø¬ÙŠÙ„', 500);
  }
}


// ==========================================
// FILE: src/app/api/auth/[...nextauth]/route.ts
// ==========================================

import NextAuth from 'next-auth';
import { authOptions } from '@/lib/auth';

const handler = NextAuth(authOptions as any);

export { handler as GET, handler as POST };


// ==========================================
// FILE: src/app/api/ai/generate-answer/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { successResponse, errorResponse } from '@/lib/api-response';
import { getSession } from '@/lib/api-auth';

export async function POST(request: NextRequest) {
  // 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ø¯Ø®ÙˆÙ„Ù‡ (Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„)
  const session = await getSession();
  if (!session?.user?.id) {
    return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ù‡. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„.', 401);
  }

  try {
    // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ÙØªØ§Ø­ API
    if (!process.env.DEEPSEEK_API_KEY) {
      console.error('DEEPSEEK_API_KEY is not configured');
      return errorResponse('Ù…ÙØªØ§Ø­ DeepSeek API ØºÙŠØ± Ù…ÙØ¹ÙŠÙ‘Ù† ÙÙŠ Ù…Ù„Ù Ø§Ù„Ø¨ÙŠØ¦Ø©.', 500);
    }

    // 3. Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø³ØªÙˆÙ‰ Ù…Ù† Ø¬Ø³Ù… Ø§Ù„Ø·Ù„Ø¨
    const { question, subject, level } = await request.json();

    if (!question || typeof question !== 'string' || !question.trim()) {
      return errorResponse('Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø·Ù„ÙˆØ¨.', 400);
    }

    // 4. Ø¨Ù†Ø§Ø¡ prompt ÙˆØ§Ø¶Ø­ Ù„Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù…Ø¹ Ø§Ù„Ø³ÙŠØ§Ù‚
    // Ø§ÙƒØªØ´Ø§Ù Ù„ØºØ© Ø§Ù„Ø³Ø¤Ø§Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
    const detectLanguage = (text: string): string => {
      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø­Ø±ÙˆÙ Ø¹Ø±Ø¨ÙŠØ©
      if (/[\u0600-\u06FF]/.test(text)) return 'Arabic';
      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø­Ø±ÙˆÙ ÙØ±Ù†Ø³ÙŠØ© Ø®Ø§ØµØ©
      if (/[Ã Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã¯Ã®Ã´Ã¹Ã»Ã¼Ã¿Ã§Ã€Ã‚Ã„Ã‰ÃˆÃŠÃ‹ÃÃÃ”Ã™Ã›ÃœÅ¸Ã‡]/.test(text)) return 'French';
      // Ø§ÙØªØ±Ø§Ø¶ Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© ÙƒÙ„ØºØ© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
      return 'English';
    };
    
    const questionLanguage = detectLanguage(question);
    
    const prompt = `You are an expert teacher in '${subject || 'General'}' for '${level || 'General'}' level.
Your task is to provide a clear and well-structured model answer to the following question.

âš ï¸ CRITICAL INSTRUCTION - LANGUAGE:
- The question is written in ${questionLanguage}
- You MUST write your ENTIRE answer in ${questionLanguage}
- DO NOT translate or use any other language
- If the question is in Arabic, your answer must be 100% in Arabic
- If the question is in French, your answer must be 100% in French  
- If the question is in English, your answer must be 100% in English

FORMATTING INSTRUCTIONS:
1. Keep the answer CONCISE but COMPLETE - neither too long nor too short
2. Focus on the essential concepts and key steps
3. For mathematical expressions, use INLINE LaTeX format: wrap them with \\( and \\) like this: \\(x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}\\)
4. For displayed equations (centered), use BLOCK LaTeX format: wrap them with $$ and $$ like this: $$x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$$
5. Format the answer in simple HTML (use <p>, <strong>, <ul>, <ol>, <li>)
6. For math questions: show the main steps without excessive details
7. Aim for a balance: thorough enough to be useful, brief enough to be practical

Question:
${question}

Model Answer (MUST BE IN ${questionLanguage}, concise, complete, in HTML format with LaTeX for math):`;

    console.log('Calling DeepSeek API with detected language:', questionLanguage);

    // 5. Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ DeepSeek API Ù…Ø¨Ø§Ø´Ø±Ø©
    const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
      },
      body: JSON.stringify({
        model: 'deepseek-chat',
        messages: [
          {
            role: 'system',
            content: `You are an expert educational assistant. You MUST respond in the SAME language as the student's question. If the question is in Arabic, respond entirely in Arabic. If in French, respond entirely in French. If in English, respond entirely in English. Never mix languages.`,
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.7,
        max_tokens: 2000,
      }),
    });

    if (!response.ok) {
      const errorData = await response.text();
      console.error('DeepSeek API error:', response.status, errorData);
      
      if (response.status === 402) {
        return errorResponse('Ø§Ù„Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ ÙÙŠ Ø­Ø³Ø§Ø¨ DeepSeek. ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ø±ØµÙŠØ¯ Ù…Ù†: https://platform.deepseek.com/', 402);
      }
      
      throw new Error(`DeepSeek API error: ${response.status} - ${errorData}`);
    }

    const data = await response.json();
    const generatedAnswer = data.choices?.[0]?.message?.content;

    if (!generatedAnswer) {
      throw new Error('No response from DeepSeek API');
    }

    console.log('DeepSeek API response received');
    
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ·Ø§Ø¨Ù‚ Ø§Ù„Ù„ØºØ©
    const answerLanguage = detectLanguage(generatedAnswer);
    if (answerLanguage !== questionLanguage) {
      console.warn(`âš ï¸ Language mismatch detected! Question: ${questionLanguage}, Answer: ${answerLanguage}`);
      // Ø³Ù†ØªØ±Ùƒ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙƒÙ…Ø§ Ù‡ÙŠ Ù„ÙƒÙ† Ù†Ø³Ø¬Ù„ Ø§Ù„ØªØ­Ø°ÙŠØ±
    }

    // 6. ØªÙ†Ø¸ÙŠÙ ÙˆØªØ­Ù‚Ù‚ Ù…Ù† HTML Ø§Ù„Ù…ÙˆÙ„Ø¯
    let cleanedAnswer = generatedAnswer.trim();
    
    // Ø¥Ø²Ø§Ù„Ø© markdown code blocks Ø¥Ø°Ø§ ÙˆØ¬Ø¯Øª
    cleanedAnswer = cleanedAnswer.replace(/```html\n?/g, '').replace(/```\n?/g, '');
    
    // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ HTML ØµØ§Ù„Ø­
    if (!cleanedAnswer.includes('<') || !cleanedAnswer.includes('>')) {
      // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† HTMLØŒ Ù„ÙÙ‡Ø§ ÙÙŠ paragraphs
      cleanedAnswer = cleanedAnswer.split('\n\n').map((para: string) => 
        para.trim() ? `<p>${para.trim()}</p>` : ''
      ).join('');
    }

    // 7. Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù…ÙˆÙ„Ø¯Ø©
    return successResponse({ 
      answer: cleanedAnswer,
    });

  } catch (error: any) {
    console.error('Error in AI answer generation:', error);
    console.error('Error details:', {
      message: error.message,
      cause: error.cause,
      stack: error.stack,
      responseBody: error.responseBody,
    });
    
    // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·Ø£
    if (error.message?.includes('API key')) {
      return errorResponse('Ø®Ø·Ø£ ÙÙŠ Ù…ÙØªØ§Ø­ API. ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ù…ÙØªØ§Ø­ DeepSeek.', 500);
    } else if (error.message?.includes('Insufficient Balance') || error.responseBody?.includes('Insufficient Balance')) {
      return errorResponse('Ø§Ù„Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ ÙÙŠ Ø­Ø³Ø§Ø¨ DeepSeek. ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ø±ØµÙŠØ¯ Ù…Ù†: https://platform.deepseek.com/', 402);
    } else if (error.message?.includes('network') || error.message?.includes('fetch')) {
      return errorResponse('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø®Ø¯Ù…Ø© DeepSeek. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.', 500);
    } else if (error.statusCode === 402 || error.message?.includes('402')) {
      return errorResponse('Ø§Ù„Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ ÙÙŠ Ø­Ø³Ø§Ø¨ DeepSeek. ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ø±ØµÙŠØ¯ Ø£Ùˆ ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙØ§ØªÙˆØ±Ø©.', 402);
    }
    
    return errorResponse('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ: ' + (error.message || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'), 500);
  }
}


// ==========================================
// FILE: src/app/api/ai/evaluate-answer/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { successResponse, errorResponse } from '@/lib/api-response';
import { getSession } from '@/lib/api-auth';

export async function POST(request: NextRequest) {
  // 1. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø³Ø¬Ù„ Ø¯Ø®ÙˆÙ„Ù‡
  const session = await getSession();
  if (!session?.user?.id) {
    return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ù‡. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„.', 401);
  }

  try {
    // 2. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…ÙØªØ§Ø­ API
    if (!process.env.DEEPSEEK_API_KEY) {
      console.error('DEEPSEEK_API_KEY is not configured');
      return errorResponse('Ù…ÙØªØ§Ø­ DeepSeek API ØºÙŠØ± Ù…ÙØ¹ÙŠÙ‘Ù† ÙÙŠ Ù…Ù„Ù Ø§Ù„Ø¨ÙŠØ¦Ø©.', 500);
    }

    // 3. Ø§Ø³ØªØ®Ù„Ø§Øµ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø¬Ø³Ù… Ø§Ù„Ø·Ù„Ø¨
    const { 
      studentAnswer, 
      modelAnswer, 
      question, 
      maxScore = 10,
      subject,
      level 
    } = await request.json();

    // 4. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    if (!studentAnswer || !studentAnswer.trim()) {
      return errorResponse('Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·Ø§Ù„Ø¨ Ù…Ø·Ù„ÙˆØ¨Ø©.', 400);
    }

    if (!modelAnswer || !modelAnswer.trim()) {
      return errorResponse('Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ© Ù…Ø·Ù„ÙˆØ¨Ø©.', 400);
    }

    if (!question || !question.trim()) {
      return errorResponse('Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø·Ù„ÙˆØ¨.', 400);
    }

    // 5. Ø¨Ù†Ø§Ø¡ prompt Ù…ÙØµÙ„ Ù„Ù„ØªØµØ­ÙŠØ­
    const prompt = `You are a fair and objective evaluator for '${subject || 'General'}' at '${level || 'General'}' level.

âš ï¸ CRITICAL EVALUATION RULES - READ CAREFULLY:

1. PRIMARY CRITERION: Is the answer CORRECT?
   - If the final answer/result is CORRECT â†’ Award 90-100% of marks
   - Correctness is MORE IMPORTANT than explanation length

2. EXPLANATION REQUIREMENT:
   - Check if the question EXPLICITLY asks for explanation/steps/justification
   - If question asks ONLY for the answer â†’ Do NOT penalize for missing explanation
   - If question says "Ø§Ø­Ø³Ø¨" (calculate), "Ø£ÙˆØ¬Ø¯" (find), "Ù…Ø§ Ù‡Ùˆ" (what is) â†’ Answer alone is sufficient
   - If question says "Ø§Ø´Ø±Ø­" (explain), "Ø¨Ø±Ø±" (justify), "Ø¨ÙŠÙ† Ø§Ù„Ø®Ø·ÙˆØ§Øª" (show steps) â†’ Then require explanation

3. SCORING GUIDELINES:
   - Correct answer WITHOUT explanation (when not required): 90-100%
   - Correct answer WITH good explanation: 100%
   - Correct answer with minor errors in explanation: 85-95%
   - Partially correct answer: 50-75%
   - Wrong answer with correct method: 30-50%
   - Wrong answer and method: 0-20%

4. AVOID OVER-PENALIZATION:
   - Do NOT deduct more than 10% for brevity if answer is correct
   - Do NOT deduct for "lack of detail" if the core answer is right
   - Focus on ERRORS, not on "what's missing" unless explicitly required

5. LANGUAGE: Provide feedback in the SAME LANGUAGE as the question.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Question:
${question}

Model Answer (reference - student doesn't need to match exactly):
${modelAnswer}

Student's Answer:
${studentAnswer}

Maximum Score: ${maxScore}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Evaluate NOW and return ONLY valid JSON (no markdown):
{
  "score": number_between_0_and_${maxScore},
  "rating": "Ù…Ù…ØªØ§Ø²/Ø¬ÙŠØ¯ Ø¬Ø¯Ø§Ù‹/Ø¬ÙŠØ¯/Ù…Ù‚Ø¨ÙˆÙ„/Ø¶Ø¹ÙŠÙ",
  "strengths": ["Ù†Ù‚Ø·Ø© Ù‚ÙˆØ© 1", "Ù†Ù‚Ø·Ø© Ù‚ÙˆØ© 2"],
  "weaknesses": ["Ù†Ù‚Ø·Ø© Ø¶Ø¹Ù Ø¥Ù† ÙˆØ¬Ø¯Øª"],
  "feedback": "Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø¨Ù†Ø§Ø¡Ø© Ù…ÙˆØ¬Ø²Ø©"
}

REMEMBER: Correct answer = High score, regardless of explanation length!`;

    console.log('Calling DeepSeek API for evaluation...');

    // 6. Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ DeepSeek API Ù…Ø¨Ø§Ø´Ø±Ø©
    const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
      },
      body: JSON.stringify({
        model: 'deepseek-chat',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.3, // Ø¯Ø±Ø¬Ø© Ø­Ø±Ø§Ø±Ø© Ù…Ù†Ø®ÙØ¶Ø© Ù„Ù„Ø¯Ù‚Ø© ÙÙŠ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
      }),
    });

    if (!response.ok) {
      const errorData = await response.text();
      console.error('DeepSeek API error:', response.status, errorData);
      
      if (response.status === 402) {
        return errorResponse('Ø§Ù„Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ ÙÙŠ Ø­Ø³Ø§Ø¨ DeepSeek. ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØ© Ø±ØµÙŠØ¯ Ù…Ù†: https://platform.deepseek.com/', 402);
      }
      
      throw new Error(`DeepSeek API error: ${response.status} - ${errorData}`);
    }

    const data = await response.json();
    const evaluationResult = data.choices?.[0]?.message?.content;

    if (!evaluationResult) {
      throw new Error('No response from DeepSeek API');
    }

    console.log('DeepSeek evaluation received:', evaluationResult);

    // 7. Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù†ØªÙŠØ¬Ø© ÙƒÙ€ JSON
    let evaluation;
    try {
      // Ø¥Ø²Ø§Ù„Ø© markdown code blocks Ø¥Ø°Ø§ ÙˆØ¬Ø¯Øª
      let cleanedResult = evaluationResult.trim();
      cleanedResult = cleanedResult.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      
      evaluation = JSON.parse(cleanedResult);
    } catch (parseError) {
      console.error('Failed to parse JSON response:', parseError);
      console.log('Raw response:', evaluationResult);
      
      // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙŠØ¯ÙˆÙŠØ§Ù‹
      try {
        const scoreMatch = evaluationResult.match(/"score"\s*:\s*(\d+\.?\d*)/);
        const ratingMatch = evaluationResult.match(/"rating"\s*:\s*"([^"]+)"/);
        
        evaluation = {
          score: scoreMatch ? parseFloat(scoreMatch[1]) : 0,
          rating: ratingMatch ? ratingMatch[1] : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
          strengths: ['ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ù„ØªÙ‚ÙŠÙŠÙ…'],
          weaknesses: [],
          feedback: evaluationResult,
        };
      } catch (extractError) {
        return errorResponse('ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ….', 500);
      }
    }

    // 8. Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø±Ø¬Ø©
    if (typeof evaluation.score !== 'number') {
      evaluation.score = 0;
    }

    // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¯Ø±Ø¬Ø© ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„ØµØ­ÙŠØ­
    evaluation.score = Math.max(0, Math.min(maxScore, evaluation.score));

    // 9. Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø©
    return successResponse({
      score: evaluation.score,
      maxScore: maxScore,
      percentage: Math.round((evaluation.score / maxScore) * 100),
      rating: evaluation.rating || 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯',
      strengths: Array.isArray(evaluation.strengths) ? evaluation.strengths : [],
      weaknesses: Array.isArray(evaluation.weaknesses) ? evaluation.weaknesses : [],
      feedback: evaluation.feedback || 'ØªÙ… Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø¨Ù†Ø¬Ø§Ø­',
      evaluatedAt: new Date().toISOString(),
    });

  } catch (error: any) {
    console.error('Error in AI evaluation:', error);
    console.error('Error details:', {
      message: error.message,
      cause: error.cause,
      stack: error.stack,
    });
    
    // ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·Ø£
    if (error.message?.includes('API key')) {
      return errorResponse('Ø®Ø·Ø£ ÙÙŠ Ù…ÙØªØ§Ø­ API. ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ù…ÙØªØ§Ø­ DeepSeek.', 500);
    } else if (error.message?.includes('network') || error.message?.includes('fetch')) {
      return errorResponse('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø®Ø¯Ù…Ø© DeepSeek. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.', 500);
    }
    
    return errorResponse('ÙØ´Ù„ ÙÙŠ ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©: ' + (error.message || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'), 500);
  }
}


// ==========================================
// FILE: src/app/api/directeur/stats/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireRole } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/directeur/stats - Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø¯ÙŠØ±
export async function GET(request: NextRequest) {
  try {
    await requireRole(['directeur']);

    // Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙÙŠ Ø§Ø³ØªØ¹Ù„Ø§Ù… ÙˆØ§Ø­Ø¯
    const [
      totalUsers,
      students,
      teachers,
      parents,
      lessons,
      exercises,
      submissions,
      subjects,
      stages,
      levels,
      messages,
    ] = await Promise.all([
      prisma.user.count(),
      prisma.user.count({
        where: {
          role: {
            name: 'student'
          }
        }
      }),
      prisma.user.count({
        where: {
          role: {
            name: {
              in: ['teacher', 'supervisor_specific']
            }
          }
        }
      }),
      prisma.user.count({
        where: {
          role: {
            name: 'parent'
          }
        }
      }),
      prisma.lesson.count(),
      prisma.exercise.count(),
      prisma.submission.count(),
      prisma.subject.count(),
      prisma.stage.count(),
      prisma.level.count(),
      prisma.message.count(),
    ]);

    return successResponse({
      totalUsers,
      students,
      teachers,
      parents,
      lessons,
      exercises,
      submissions,
      subjects,
      stages,
      levels,
      messages,
    });
  } catch (error: any) {
    console.error('Error fetching directeur stats:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª', 500);
  }
}


// ==========================================
// FILE: src/app/api/messages/[id]/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse, notFoundResponse } from '@/lib/api-response';

// PATCH /api/messages/[id] - ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© (Ù‚Ø±Ø§Ø¡Ø©/Ø¹Ø¯Ù… Ù‚Ø±Ø§Ø¡Ø©)
export async function PATCH(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await requireAuth();
    const messageId = parseInt(params.id);

    const message = await prisma.message.findUnique({
      where: { id: messageId },
    });

    if (!message) {
      return notFoundResponse('Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    // ÙÙ‚Ø· Ø§Ù„Ù…Ø³ØªÙ„Ù… ÙŠÙ…ÙƒÙ†Ù‡ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©
    if (message.recipientId !== session.user.id) {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨ØªØ­Ø¯ÙŠØ« Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©', 403);
    }

    const body = await request.json();
    const { isRead } = body;

    const updatedMessage = await prisma.message.update({
      where: { id: messageId },
      data: { isRead: isRead !== undefined ? isRead : true },
    });

    return successResponse(updatedMessage, 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø©');
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø³Ø§Ù„Ø©', 500);
  }
}

// DELETE /api/messages/[id]
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await requireAuth();
    const messageId = parseInt(params.id);

    const message = await prisma.message.findUnique({
      where: { id: messageId },
    });

    if (!message) {
      return notFoundResponse('Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    // Ø§Ù„Ù…Ø±Ø³Ù„ Ø£Ùˆ Ø§Ù„Ù…Ø³ØªÙ„Ù… ÙŠÙ…ÙƒÙ†Ù‡ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©
    if (message.senderId !== session.user.id && message.recipientId !== session.user.id) {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©', 403);
    }

    await prisma.message.delete({
      where: { id: messageId },
    });

    return successResponse(null, 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ù„Ø©', 500);
  }
}


// ==========================================
// FILE: src/app/api/messages/[id]/read/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// Mark message as read
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const messageId = parseInt(params.id);
    const userId = session.user.id;

    // Update message as read only if current user is the recipient
    const message = await prisma.message.update({
      where: {
        id: messageId,
        recipientId: userId,
      },
      data: {
        isRead: true,
      },
    });

    return NextResponse.json({
      success: true,
      data: { message },
    });
  } catch (error) {
    console.error("Error marking message as read:", error);
    return NextResponse.json(
      { success: false, error: "Failed to mark message as read" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/messages/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/messages - Ø¬Ù„Ø¨ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
export async function GET(request: NextRequest) {
  try {
    const session = await requireAuth();
    const { searchParams } = new URL(request.url);

    const type = searchParams.get('type'); // sent | received | all
    const isRead = searchParams.get('isRead'); // true | false

    let where: any = {};

    if (type === 'sent') {
      where.senderId = session.user.id;
    } else if (type === 'received') {
      where.recipientId = session.user.id;
      if (isRead !== null) {
        where.isRead = isRead === 'true';
      }
    } else {
      // all - Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„Ø© ÙˆØ§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„Ø©
      where = {
        OR: [
          { senderId: session.user.id },
          { recipientId: session.user.id },
        ],
      };
    }

    const messages = await prisma.message.findMany({
      where,
      include: {
        sender: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            image: true,
            role: {
              select: {
                name: true,
              },
            },
          },
        },
        recipient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            image: true,
            role: {
              select: {
                name: true,
              },
            },
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });

    return successResponse({ messages });
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„', 500);
  }
}

// POST /api/messages - Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth();
    const body = await request.json();
    const { recipientId, subject, content } = body;

    if (!recipientId || !subject || !content) {
      return errorResponse('Ø§Ù„Ù…Ø³ØªÙ„Ù… ÙˆØ§Ù„Ù…ÙˆØ¶ÙˆØ¹ ÙˆØ§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ø·Ù„ÙˆØ¨Ø©', 400);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù…Ø³ØªÙ„Ù…
    const recipient = await prisma.user.findUnique({
      where: { id: recipientId },
    });

    if (!recipient) {
      return errorResponse('Ø§Ù„Ù…Ø³ØªÙ„Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 404);
    }

    const message = await prisma.message.create({
      data: {
        senderId: session.user.id,
        recipientId,
        subject,
        content,
      },
      include: {
        sender: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            image: true,
          },
        },
        recipient: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            image: true,
          },
        },
      },
    });

    return successResponse(message, 'ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­', 201);
  } catch (error: any) {
    console.error('Error sending message:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©', 500);
  }
}


// ==========================================
// FILE: src/app/api/messages/broadcast/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireRole } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// POST /api/messages/broadcast - Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¬Ù…Ø§Ø¹ÙŠØ© (Ø§Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·)
export async function POST(request: NextRequest) {
  try {
    const session = await requireRole(['directeur']);

    const body = await request.json();
    const { recipientIds, recipientRole, content, subject } = body;

    if (!content || !subject) {
      return errorResponse('Ø§Ù„Ù…ÙˆØ¶ÙˆØ¹ ÙˆØ§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ø·Ù„ÙˆØ¨Ø§Ù†', 400);
    }

    let targetUserIds: string[] = [];

    // Ø¥Ø°Ø§ ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø¯ÙˆØ± Ù…Ø¹ÙŠÙ†
    if (recipientRole && recipientRole !== 'all') {
      const roleRecord = await prisma.role.findFirst({
        where: { name: recipientRole }
      });

      if (roleRecord) {
        const usersInRole = await prisma.user.findMany({
          where: { roleId: roleRecord.id },
          select: { id: true }
        });
        targetUserIds = usersInRole.map(u => u.id);
      }
    }
    // Ø¥Ø°Ø§ ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù…Ø­Ø¯Ø¯ÙŠÙ†
    else if (recipientIds && Array.isArray(recipientIds) && recipientIds.length > 0) {
      targetUserIds = recipientIds;
    }
    // Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ø¬Ù…ÙŠØ¹
    else if (recipientRole === 'all') {
      const allUsers = await prisma.user.findMany({
        where: {
          id: { not: session.user.id } // Ø¹Ø¯Ø§ Ø§Ù„Ù…Ø¯ÙŠØ± Ù†ÙØ³Ù‡
        },
        select: { id: true }
      });
      targetUserIds = allUsers.map(u => u.id);
    } else {
      return errorResponse('ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø³ØªÙ„Ù…ÙŠÙ†', 400);
    }

    if (targetUserIds.length === 0) {
      return errorResponse('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', 400);
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø³Ø§Ø¦Ù„ Ù…ØªØ¹Ø¯Ø¯Ø©
    const messages = await prisma.message.createMany({
      data: targetUserIds.map(recipientId => ({
        senderId: session.user.id,
        recipientId,
        subject,
        content,
        isRead: false,
      })),
    });

    return successResponse(
      { count: messages.count },
      `ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ${messages.count} Ø±Ø³Ø§Ù„Ø© Ø¨Ù†Ø¬Ø§Ø­`,
      201
    );
  } catch (error: any) {
    console.error('Error broadcasting message:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„', 500);
  }
}


// ==========================================
// FILE: src/app/api/messages/unread-count/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    await requireAuth();

    // Ø¥Ø±Ø¬Ø§Ø¹ 0 Ø­Ø§Ù„ÙŠØ§Ù‹ Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
    // TODO: Ø±Ø¨Ø· Ù‡Ø°Ø§ Ø¨Ø¬Ø¯ÙˆÙ„ Messages ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø§Ø­Ù‚Ø§Ù‹
    return successResponse({
      unreadCount: 0
    });
  } catch (error: any) {
    return errorResponse(error.message || 'Failed to fetch unread count', 500);
  }
}

// ==========================================
// FILE: src/app/api/academic-years/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/logger';

/**
 * Get all academic years
 * GET /api/academic-years
 */
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    const years = await prisma.academicYear.findMany({
      orderBy: { startDate: 'desc' },
      include: {
        _count: {
          select: { promotions: true }
        }
      }
    });

    return NextResponse.json({ years });

  } catch (error: any) {
    console.error('Academic years fetch error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ù†ÙˆØ§Øª Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©' },
      { status: 500 }
    );
  }
}

/**
 * Create new academic year
 * POST /api/academic-years
 * Only accessible by Director
 */
export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    // Check if user is Director
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { role: true }
    });

    if (user?.role.name !== 'directeur') {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - Ù…Ø®ØµØµ Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·' }, { status: 403 });
    }

    const { name, startDate, endDate, isCurrent } = await req.json();

    if (!name || !startDate || !endDate) {
      return NextResponse.json({ error: 'Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù†Ø§Ù‚ØµØ©' }, { status: 400 });
    }

    // If setting as current, unset other current years
    if (isCurrent) {
      await prisma.academicYear.updateMany({
        where: { isCurrent: true },
        data: { isCurrent: false }
      });
    }

    const year = await prisma.academicYear.create({
      data: {
        name,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        isCurrent: isCurrent || false,
        status: 'active'
      }
    });

    await logger.system.warning(`Academic year created: ${name}`, { 
      yearId: year.id, 
      userId: session.user.id 
    });

    return NextResponse.json({
      success: true,
      message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
      year
    });

  } catch (error: any) {
    console.error('Academic year creation error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©' },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/academic-years/promotions/initiate/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/logger';

/**
 * Initiate student promotion process
 * POST /api/academic-years/promotions/initiate
 * Sends messages to all parents asking about their children's results
 * Only accessible by Director
 */
export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    // Check if user is Director
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { role: true }
    });

    if (user?.role.name !== 'directeur') {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - Ù…Ø®ØµØµ Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·' }, { status: 403 });
    }

    const { academicYearId } = await req.json();

    if (!academicYearId) {
      return NextResponse.json({ error: 'Ù…Ø¹Ø±Ù Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© Ù…Ø·Ù„ÙˆØ¨' }, { status: 400 });
    }

    // Get current academic year
    const academicYear = await prisma.academicYear.findUnique({
      where: { id: academicYearId }
    });

    if (!academicYear) {
      return NextResponse.json({ error: 'Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©' }, { status: 404 });
    }

    // Get all students with their parents and current level
    const parentChildLinks = await prisma.parentChildLink.findMany({
      include: {
        parent: {
          include: { role: true }
        },
        child: {
          include: {
            role: true,
            userDetails: {
              include: {
                level: {
                  include: {
                    stage: true
                  }
                }
              }
            }
          }
        }
      },
      where: {
        child: {
          role: {
            name: 'student'
          },
          userDetails: {
            levelId: {
              not: null
            }
          }
        }
      }
    });

    let messagesCreated = 0;
    let promotionsCreated = 0;

    for (const link of parentChildLinks) {
      const student = link.child;
      const parent = link.parent;
      const currentLevel = student.userDetails?.level;

      if (!currentLevel) continue;

      // Check if promotion already exists
      const existingPromotion = await prisma.studentPromotion.findUnique({
        where: {
          academicYearId_studentId: {
            academicYearId,
            studentId: student.id
          }
        }
      });

      if (existingPromotion) continue;

      // Find next level
      const nextLevel = await prisma.level.findFirst({
        where: {
          stageId: currentLevel.stageId,
          displayOrder: currentLevel.displayOrder + 1
        }
      });

      // Create promotion record
      const promotion = await prisma.studentPromotion.create({
        data: {
          academicYearId,
          studentId: student.id,
          parentId: parent.id,
          fromLevelId: currentLevel.id,
          toLevelId: nextLevel?.id || null,
          status: 'pending'
        }
      });

      promotionsCreated++;

      // Send message to parent
      const studentName = `${student.firstName} ${student.lastName}`;
      const levelName = currentLevel.name;
      const nextLevelName = nextLevel?.name || 'Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø±Ø­Ù„Ø©';

      const message = await prisma.message.create({
        data: {
          senderId: session.user.id,
          recipientId: parent.id,
          subject: `ğŸ“š Ø§Ø³ØªÙØ³Ø§Ø± Ø¹Ù† Ù†ØªØ§Ø¦Ø¬ ${studentName} - Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© ${academicYear.name}`,
          content: `
<div style="direction: rtl; text-align: right; padding: 20px; font-family: Arial, sans-serif;">
  <h2 style="color: #3F51B5;">Ø§Ù„Ø³Ù„Ø§Ù… Ø¹Ù„ÙŠÙƒÙ… ÙˆØ±Ø­Ù…Ø© Ø§Ù„Ù„Ù‡ ÙˆØ¨Ø±ÙƒØ§ØªÙ‡ ğŸŒŸ</h2>
  
  <p>Ø¹Ø²ÙŠØ²ÙŠ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±ØŒ</p>
  
  <p>Ù†Ø£Ù…Ù„ Ø£Ù† ØªÙƒÙˆÙ†ÙˆØ§ Ø¨Ø®ÙŠØ±. Ù†Ø­Ù† ÙÙŠ Ù…Ù†ØµØ© SmartEdu Ù†Ù‡ØªÙ… Ø¨Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø³ÙŠØ±Ø© Ø£Ø¨Ù†Ø§Ø¦Ù†Ø§ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠØ©.</p>
  
  <div style="background-color: #f5f5f5; padding: 15px; border-radius: 8px; margin: 20px 0;">
    <p><strong>Ø§Ù„Ø·Ø§Ù„Ø¨/Ø©:</strong> ${studentName}</p>
    <p><strong>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ:</strong> ${levelName}</p>
    <p><strong>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ:</strong> ${nextLevelName}</p>
  </div>
  
  <p style="font-size: 18px; font-weight: bold; color: #2196F3;">
    ğŸ“ Ù‡Ù„ Ù†Ø¬Ø­/Øª ${studentName} ÙÙŠ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ ${nextLevelName}ØŸ
  </p>
  
  <p>ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ù€:</p>
  <ul>
    <li><strong>"Ù†Ø¹Ù…"</strong> - Ø¥Ø°Ø§ Ù†Ø¬Ø­ Ø§Ù„Ø·Ø§Ù„Ø¨ ÙˆØ§Ù†ØªÙ‚Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø£Ø¹Ù„Ù‰</li>
    <li><strong>"Ù„Ø§"</strong> - Ø¥Ø°Ø§ Ø³ÙŠØ¹ÙŠØ¯ Ø§Ù„Ø·Ø§Ù„Ø¨ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰</li>
  </ul>
  
  <p style="color: #666; font-size: 14px; margin-top: 20px;">
    Ù…Ù„Ø§Ø­Ø¸Ø©: Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø¥Ø¬Ø§Ø¨ØªÙƒ.
  </p>
  
  <p>Ø´ÙƒØ±Ø§Ù‹ Ù„ØªØ¹Ø§ÙˆÙ†ÙƒÙ… ğŸ’™</p>
  
  <hr style="border: none; border-top: 1px solid #ddd; margin: 20px 0;">
  
  <p style="color: #999; font-size: 12px;">
    Ù…Ù†ØµØ© SmartEdu - ${new Date().toLocaleDateString('ar')}
  </p>
</div>
          `.trim()
        }
      });

      messagesCreated++;

      // Update promotion with message ID
      await prisma.studentPromotion.update({
        where: { id: promotion.id },
        data: {
          messageId: message.id,
          notifiedAt: new Date()
        }
      });

      // Create notification for parent
      await prisma.notification.create({
        data: {
          userId: parent.id,
          title: 'ğŸ“š Ø§Ø³ØªÙØ³Ø§Ø± Ø¹Ù† Ù†ØªØ§Ø¦Ø¬ Ø§Ø¨Ù†Ùƒ/Ø§Ø¨Ù†ØªÙƒ',
          message: `ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø®Ø§ØµØ© Ø¨Ù†ØªØ§Ø¦Ø¬ ${studentName}`,
          type: 'message_received',
          relatedId: message.id
        }
      });
    }

    await logger.system.warning(`Promotion process initiated for ${promotionsCreated} students`, {
      academicYearId,
      userId: session.user.id,
      messagesCreated,
      promotionsCreated
    });

    return NextResponse.json({
      success: true,
      message: `ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ${messagesCreated} Ø±Ø³Ø§Ù„Ø© Ù„Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±`,
      stats: {
        messagesCreated,
        promotionsCreated
      }
    });

  } catch (error: any) {
    console.error('Promotion initiation error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ±Ù‚ÙŠØ©' },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/academic-years/promotions/stats/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

/**
 * Get promotion statistics and details
 * GET /api/academic-years/promotions/stats
 */
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    const searchParams = req.nextUrl.searchParams;
    const academicYearId = searchParams.get('academicYearId');

    if (!academicYearId) {
      return NextResponse.json({ error: 'Ù…Ø¹Ø±Ù Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© Ù…Ø·Ù„ÙˆØ¨' }, { status: 400 });
    }

    const [
      total,
      pending,
      approved,
      rejected,
      completed
    ] = await Promise.all([
      prisma.studentPromotion.count({
        where: { academicYearId }
      }),
      prisma.studentPromotion.count({
        where: { academicYearId, status: 'pending' }
      }),
      prisma.studentPromotion.count({
        where: { academicYearId, status: 'approved' }
      }),
      prisma.studentPromotion.count({
        where: { academicYearId, status: 'rejected' }
      }),
      prisma.studentPromotion.count({
        where: { academicYearId, status: 'completed' }
      })
    ]);

    // Get detailed promotions list
    const promotions = await prisma.studentPromotion.findMany({
      where: { academicYearId },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        parent: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        fromLevel: {
          select: {
            id: true,
            name: true
          }
        },
        toLevel: {
          select: {
            id: true,
            name: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    return NextResponse.json({
      stats: {
        total,
        pending,
        approved,
        rejected,
        completed,
        responseRate: total > 0 ? Math.round(((approved + rejected) / total) * 100) : 0
      },
      promotions
    });

  } catch (error: any) {
    console.error('Promotion stats error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª' },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/academic-years/promotions/pending/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/academic-years/promotions/pending - Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© Ù„ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±
export async function GET(request: NextRequest) {
  try {
    const session = await requireAuth();

    // ÙÙ‚Ø· Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±
    if (session.user.role !== 'parent') {
      return successResponse([], 'Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ±Ù‚ÙŠØ§Øª Ù…Ø¹Ù„Ù‚Ø©');
    }

    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø© (pending) Ù„Ù‡Ø°Ø§ Ø§Ù„ÙˆÙ„ÙŠ
    const pendingPromotions = await prisma.studentPromotion.findMany({
      where: {
        parentId: session.user.id,
        status: 'pending',
        parentResponse: null, // Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¨Ø¹Ø¯
      },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        fromLevel: {
          select: {
            id: true,
            name: true,
          },
        },
        toLevel: {
          select: {
            id: true,
            name: true,
          },
        },
      },
      orderBy: {
        createdAt: 'asc', // Ø§Ù„Ø£Ù‚Ø¯Ù… Ø£ÙˆÙ„Ø§Ù‹
      },
    });

    return successResponse(
      pendingPromotions,
      pendingPromotions.length > 0
        ? `Ù„Ø¯ÙŠÙƒ ${pendingPromotions.length} ØªØ±Ù‚ÙŠØ© Ù…Ø¹Ù„Ù‚Ø©`
        : 'Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ±Ù‚ÙŠØ§Øª Ù…Ø¹Ù„Ù‚Ø©'
    );
  } catch (error: any) {
    console.error('Error fetching pending promotions:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©', 500);
  }
}


// ==========================================
// FILE: src/app/api/academic-years/promotions/respond/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/logger';

/**
 * Process parent response for student promotion
 * POST /api/academic-years/promotions/respond
 * Parents respond with yes/no to promotion question
 */
export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    const { promotionId, response } = await req.json();

    if (!promotionId || !response) {
      return NextResponse.json({ error: 'Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù†Ø§Ù‚ØµØ©' }, { status: 400 });
    }

    if (!['yes', 'no'].includes(response.toLowerCase())) {
      return NextResponse.json({ error: 'Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† Ù†Ø¹Ù… Ø£Ùˆ Ù„Ø§' }, { status: 400 });
    }

    // Get promotion
    const promotion = await prisma.studentPromotion.findUnique({
      where: { id: promotionId },
      include: {
        student: true,
        parent: true,
        fromLevel: true,
        toLevel: true
      }
    });

    if (!promotion) {
      return NextResponse.json({ error: 'Ø·Ù„Ø¨ Ø§Ù„ØªØ±Ù‚ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯' }, { status: 404 });
    }

    // Check if user is the parent
    if (promotion.parentId !== session.user.id) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† ÙˆÙ„ÙŠ Ø£Ù…Ø± Ø§Ù„Ø·Ø§Ù„Ø¨' }, { status: 403 });
    }

    const isApproved = response.toLowerCase() === 'yes';
    const studentName = `${promotion.student.firstName} ${promotion.student.lastName}`;

    // Update promotion
    await prisma.studentPromotion.update({
      where: { id: promotionId },
      data: {
        parentResponse: response.toLowerCase(),
        respondedAt: new Date(),
        status: isApproved ? 'approved' : 'rejected'
      }
    });

    // If approved and there's a next level, promote the student
    if (isApproved && promotion.toLevelId) {
      await prisma.userDetails.update({
        where: { userId: promotion.studentId },
        data: { levelId: promotion.toLevelId }
      });

      await prisma.studentPromotion.update({
        where: { id: promotionId },
        data: {
          promotedAt: new Date(),
          status: 'completed'
        }
      });

      await logger.user.updated(
        promotion.studentId,
        session.user.id,
        { action: 'promoted', fromLevel: promotion.fromLevelId, toLevel: promotion.toLevelId }
      );

      // Send notification to student
      await prisma.notification.create({
        data: {
          userId: promotion.studentId,
          title: 'ğŸ‰ Ù…Ø¨Ø±ÙˆÙƒ! ØªÙ… ØªØ±Ù‚ÙŠØªÙƒ',
          message: `ØªÙ‡Ø§Ù†ÙŠÙ†Ø§! ØªÙ… ØªØ±Ù‚ÙŠØªÙƒ Ø¥Ù„Ù‰ ${promotion.toLevel?.name}`,
          type: 'system'
        }
      });
    } else if (!isApproved) {
      // Send encouragement notification to student
      await prisma.notification.create({
        data: {
          userId: promotion.studentId,
          title: 'ğŸ’ª Ù„Ø§ ØªÙŠØ£Ø³!',
          message: 'Ù„Ø§ ØªÙ‚Ù„Ù‚ØŒ Ø³ØªÙƒÙˆÙ† Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© Ø£ÙØ¶Ù„ Ø¨Ø¥Ø°Ù† Ø§Ù„Ù„Ù‡. Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„ØªØ¹Ù„Ù… ÙˆØ§Ù„ØªØ­Ø³Ù†!',
          type: 'system'
        }
      });
    }

    return NextResponse.json({
      success: true,
      isApproved,
      promoted: isApproved && promotion.toLevelId ? true : false,
      message: isApproved 
        ? `ğŸ‰ Ø±Ø§Ø¦Ø¹! ØªÙ… ØªØ±Ù‚ÙŠØ© ${studentName} Ø¨Ù†Ø¬Ø§Ø­`
        : `ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©. ${studentName} Ø³ÙŠØ¹ÙŠØ¯ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰`
    });

  } catch (error: any) {
    console.error('Promotion response error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©' },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/database/inspect/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireRole } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

export async function GET(request: NextRequest) {
  try {
    await requireRole(['directeur']);

    const [
      usersCount,
      lessonsCount,
      exercisesCount,
      submissionsCount,
      stagesCount,
      levelsCount,
      subjectsCount,
      messagesCount,
      notificationsCount,
      logsCount,
      backupsCount,
      academicYearsCount,
      promotionsCount,
    ] = await Promise.all([
      prisma.user.count(),
      prisma.lesson.count(),
      prisma.exercise.count(),
      prisma.submission.count(),
      prisma.stage.count(),
      prisma.level.count(),
      prisma.subject.count(),
      prisma.message.count(),
      prisma.notification.count(),
      prisma.log.count(),
      prisma.backup.count(),
      prisma.academicYear.count(),
      prisma.studentPromotion.count(),
    ]);

    const stats = {
      users: usersCount,
      lessons: lessonsCount,
      exercises: exercisesCount,
      submissions: submissionsCount,
      stages: stagesCount,
      levels: levelsCount,
      subjects: subjectsCount,
      messages: messagesCount,
      notifications: notificationsCount,
      logs: logsCount,
      backups: backupsCount,
      academicYears: academicYearsCount,
      promotions: promotionsCount,
      total: usersCount + lessonsCount + exercisesCount + submissionsCount + stagesCount + levelsCount + subjectsCount + messagesCount,
    };

    return successResponse(stats, 'ØªÙ… Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Database inspect error:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 500);
  }
}


// ==========================================
// FILE: src/app/api/statistics/public/route.ts
// ==========================================

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { successResponse, errorResponse } from '@/lib/api-response';

export const dynamic = 'force-dynamic';

export async function GET() {
  try {
    // Ù†Ø³ØªØ®Ø¯Ù… try-catch Ù„ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ© Ø¹Ø¯ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… ØªÙˆÙ‚Ù Ø§Ù„Ù€ API Ø¨Ø§Ù„ÙƒØ§Ù…Ù„ ÙÙŠ Ø­Ø§Ù„ ÙˆØ¬ÙˆØ¯ Ø®Ø·Ø£ ÙÙŠ Ø¬Ø¯ÙˆÙ„ Ù…Ø¹ÙŠÙ†
    
    // 1. Count Lessons
    const lessonsPromise = prisma.lesson.count().catch(err => {
      console.error('Failed to count lessons:', err);
      return 0;
    });

    // 2. Count Students
    // ØªØµØ­ÙŠØ­: role Ù‡Ùˆ Ø¹Ù„Ø§Ù‚Ø© (Relation) ÙˆÙ„ÙŠØ³ Ù†ØµØ§Ù‹ØŒ Ù„Ø°Ø§ ÙŠØ¬Ø¨ Ø§Ù„Ø¨Ø­Ø« Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù…Ø±ØªØ¨Ø·
    const studentsPromise = prisma.user.count({ 
      where: { 
        role: { name: 'student' } 
      } 
    }).catch(err => {
      console.error('Failed to count students:', err);
      return 0;
    });

    // 3. Count Teachers/Supervisors
    const teachersPromise = prisma.user.count({ 
      where: { 
        role: { 
          name: { in: ['teacher', 'supervisor_specific', 'supervisor_general'] } 
        }
      } 
    }).catch(err => {
      console.error('Failed to count teachers:', err);
      return 0;
    });

    // 4. Count Exercises (Check if model exists)
    // We check for 'exercise' or 'Exercise' to be safe
    let exercisesPromise;
    const p = prisma as any;
    
    if (p.exercise) {
      exercisesPromise = p.exercise.count();
    } else if (p.Exercise) {
      exercisesPromise = p.Exercise.count();
    } else {
      exercisesPromise = Promise.resolve(0);
    }
    
    // Wrap exercise promise in catch
    exercisesPromise = exercisesPromise.catch((err: any) => {
      console.error('Failed to count exercises:', err);
      return 0;
    });

    const [students, teachers, lessons, exercises] = await Promise.all([
      studentsPromise,
      teachersPromise,
      lessonsPromise,
      exercisesPromise,
    ]);

    return successResponse({
      students,
      teachers,
      lessons,
      exercises,
    });
  } catch (error: any) {
    console.error('Critical Error fetching public statistics:', error);
    // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ù†Ø§Ø¬Ø­Ø© Ù…Ø¹ Ø£ØµÙØ§Ø± Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† 500 Ù„Ø¶Ù…Ø§Ù† Ø§Ø³ØªÙ‚Ø±Ø§Ø± Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ©
    return successResponse({
      students: 0,
      teachers: 0,
      lessons: 0,
      exercises: 0,
    });
  }
}

// ==========================================
// FILE: src/app/api/users/[id]/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireRole, getSession } from '@/lib/api-auth';
import { successResponse, errorResponse, notFoundResponse } from '@/lib/api-response';
import bcrypt from 'bcryptjs';
import { GoogleDriveService } from '@/lib/google-drive'; // Import GoogleDriveService

// GET /api/users/[id] - Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ø³ØªØ®Ø¯Ù…
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getSession();
    if (!session) {
      return errorResponse('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹', 401);
    }

    const { id: userId } = await params;

    // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠÙ…ÙƒÙ†Ù‡ Ø±Ø¤ÙŠØ© Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙ‡ Ø£Ùˆ Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø±Ø¤ÙŠØ© Ø§Ù„Ø¬Ù…ÙŠØ¹
    if (session.user.id !== userId && session.user.role !== 'directeur') {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„', 403);
    }

    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        role: true,
        userDetails: {
          include: {
            stage: true,
            level: true,
            subject: true,
          },
        },
      },
    });

    if (!user) {
      return notFoundResponse('Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    }

    // Ø¥Ø²Ø§Ù„Ø© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
    const { password, ...userWithoutPassword } = user;

    return successResponse(userWithoutPassword);
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…', 500);
  }
}

// PATCH /api/users/[id] - ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ø³ØªØ®Ø¯Ù…
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getSession();
    if (!session) {
      return errorResponse('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹', 401);
    }

    const { id: userId } = await params;

    // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠÙ…ÙƒÙ†Ù‡ ØªØ¹Ø¯ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙ‡ Ø£Ùˆ Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¬Ù…ÙŠØ¹
    if (session.user.id !== userId && session.user.role !== 'directeur') {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„', 403);
    }

    const body = await request.json();
    const {
      firstName,
      lastName,
      email,
      password,
      image,
      role,
      stageId,
      levelId,
      subjectId,
      aiEvalMode,
      isBanned,
    } = body;

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø¥Ø°Ø§ ØªÙ… ØªØºÙŠÙŠØ±Ù‡
    if (email) {
      const existingUser = await prisma.user.findFirst({
        where: {
          email,
          id: { not: userId },
        },
      });

      if (existingUser) {
        return errorResponse('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„', 400);
      }
    }

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØ­Ø¯ÙŠØ«
    const updateData: any = {};
    if (firstName) updateData.firstName = firstName;
    if (lastName) updateData.lastName = lastName;
    if (email) updateData.email = email;
    if (image !== undefined) updateData.image = image;
    if (password) {
      updateData.password = await bcrypt.hash(password, 10);
    }
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯ÙˆØ± Ø¥Ø°Ø§ ØªÙ… ØªÙ‚Ø¯ÙŠÙ…Ù‡ (Ø§Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·)
    if (role && session.user.role === 'directeur') {
      const roleRecord = await prisma.role.findFirst({
        where: { name: role },
      });
      if (roleRecord) {
        updateData.roleId = roleRecord.id;
      }
    }

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const user = await prisma.user.update({
      where: { id: userId },
      data: updateData,
      include: {
        role: true,
        userDetails: true,
      },
    });

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
    if (stageId !== undefined || levelId !== undefined || subjectId !== undefined || aiEvalMode !== undefined) {
      const detailsUpdateData: any = {};
      if (stageId !== undefined) detailsUpdateData.stageId = stageId;
      if (levelId !== undefined) detailsUpdateData.levelId = levelId;
      if (subjectId !== undefined) detailsUpdateData.subjectId = subjectId;
      if (aiEvalMode !== undefined) detailsUpdateData.aiEvalMode = aiEvalMode;

      await prisma.userDetails.upsert({
        where: { userId },
        update: detailsUpdateData,
        create: {
          userId,
          ...detailsUpdateData,
        },
      });
    }

    // Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø­Ø¯Ø« Ù…Ø¹ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª
    const updatedUser = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        role: true,
        userDetails: {
          include: {
            stage: true,
            level: true,
            subject: true,
          },
        },
      },
    });

    // Ø¥Ø²Ø§Ù„Ø© ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    const { password: _, ...userWithoutPassword } = updatedUser!;

    return successResponse(userWithoutPassword, 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Error updating user:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…', 500);
  }
}

// DELETE /api/users/[id] - Ø­Ø°Ù Ù…Ø³ØªØ®Ø¯Ù… (Ø§Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·)
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    await requireRole(['directeur']);

    const userId = params.id;

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { 
        userDetails: {
          select: { teacherDriveFolderId: true }
        }
      } 
    });

    if (!user) {
      return notFoundResponse('Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    }

    // 1. Delete associated Google Drive folder if exists
    if (user.userDetails?.teacherDriveFolderId) {
      try {
        await GoogleDriveService.deleteFolder(user.userDetails.teacherDriveFolderId);
      } catch (gdError: any) {
        console.error(`Failed to delete Google Drive folder for user ${userId}:`, gdError);
        // Log and proceed to delete from DB to maintain data integrity within the app
      }
    }

    // 2. Delete the user from the database (details will be deleted due to onDelete: Cascade)
    await prisma.user.delete({
      where: { id: userId },
    });

    return successResponse(null, 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆØ§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø±ØªØ¨Ø· Ø¨Ù‡ Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Error deleting user:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…', 500);
  }
}


// ==========================================
// FILE: src/app/api/users/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireRole } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';
import bcrypt from 'bcryptjs';
import { GoogleDriveService } from '@/lib/google-drive';
import { log, LogLevel, LogCategory } from '@/lib/logger';

/**
 * Handles the creation of the necessary folder structure in Google Drive for a new teacher.
 * Stage > Subject > Teacher Name > Level
 * This function is designed to be resilient; it logs errors but does not throw them,
 * ensuring that a failure in Google Drive integration does not prevent user creation.
 * @param user - The newly created user object, including role and userDetails with relations.
 */
async function handleTeacherFolderCreation(user: any) {
  // Ensure user is a teacher and has the necessary details
  if (user.role.name !== 'teacher' || !user.userDetails) {
    return;
  }

  const { userDetails } = user;
  const { stage, subject, level } = userDetails;

  if (!stage?.name || !subject?.name || !level?.name) {
    await log({
        level: LogLevel.WARNING,
        category: LogCategory.DRIVE,
        action: 'DRIVE_SETUP_INCOMPLETE',
        userId: user.id,
        details: `Teacher ${user.id} created, but missing stage, subject, or level name for Drive folder setup.`
    });
    return;
  }

  try {
    await log({
        level: LogLevel.INFO,
        category: LogCategory.DRIVE,
        action: 'DRIVE_SETUP_START',
        userId: user.id,
        details: `Starting Google Drive folder setup for teacher ${user.id}.`
    });

    const rootFolderId = process.env.GOOGLE_DRIVE_ROOT_FOLDER_ID;
    if (!rootFolderId) {
      throw new Error('GOOGLE_DRIVE_ROOT_FOLDER_ID is not set.');
    }

    // 1. Get or create Stage folder
    const stageFolderId = await GoogleDriveService.getOrCreateFolder(stage.name, rootFolderId);

    // 2. Get or create Subject folder within Stage
    const subjectFolderId = await GoogleDriveService.getOrCreateFolder(subject.name, stageFolderId);

    // 3. Create Teacher's main folder (e.g., "John Doe")
    const teacherName = `${user.firstName} ${user.lastName}`;
    const teacherFolderId = await GoogleDriveService.getOrCreateFolder(teacherName, subjectFolderId);

    // 4. Create Level sub-folder within the teacher's folder
    await GoogleDriveService.getOrCreateFolder(level.name, teacherFolderId);

    // 5. Update the user's details with their main Drive folder ID
    await prisma.userDetails.update({
      where: { userId: user.id },
      data: { teacherDriveFolderId: teacherFolderId },
    });

    await log({
        level: LogLevel.SUCCESS,
        category: LogCategory.DRIVE,
        action: 'DRIVE_SETUP_SUCCESS',
        userId: user.id,
        details: `Successfully created Drive folders for teacher ${user.id}. Folder ID: ${teacherFolderId}`
    });

  } catch (error: any) {
    await log({
        level: LogLevel.ERROR,
        category: LogCategory.DRIVE,
        action: 'DRIVE_SETUP_FAILED',
        userId: user.id,
        details: {
            message: `Failed to create Google Drive folders for teacher ${user.id}.`,
            error: error.message,
        }
    });
    // Do not re-throw; user creation should not fail due to this.
  }
}


// GET /api/users - Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ø§Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·)
export async function GET(request: NextRequest) {
  try {
    console.log('ğŸ”µ Starting GET /api/users');
    await requireRole(['directeur']);

    const { searchParams } = new URL(request.url);
    const role = searchParams.get('role');
    const search = searchParams.get('search');
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '100');
    const skip = (page - 1) * limit;

    console.log('Query params:', { role, search, page, limit });

    const where: any = {};
    
    // Role filter
    if (role) {
      // Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± ÙˆØ§Ù„Ø¨Ø­Ø« ÙŠØ¯ÙˆÙŠØ§Ù‹ Ù„Ø¶Ù…Ø§Ù† Ø¹Ø¯Ù… Ø§Ù„ØªØ£Ø«Ø± Ø¨Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ø­Ø±Ù (Student vs student)
      const allRoles = await prisma.role.findMany();
      const roleRecord = allRoles.find(r => r.name.toLowerCase() === role.toLowerCase());
      
      console.log(`Role filter: requested "${role}", found record:`, roleRecord);
      
      if (roleRecord) {
        where.roleId = roleRecord.id;
      } else {
        // Ø¥Ø°Ø§ ØªÙ… Ø·Ù„Ø¨ Ø¯ÙˆØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ØŒ Ù†Ø¹ÙŠØ¯ Ù‚Ø§Ø¦Ù…Ø© ÙØ§Ø±ØºØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ØªØ¬Ø§Ù‡Ù„ Ø§Ù„ÙÙ„ØªØ±
        where.roleId = -1; 
      }
    }

    // Search filter
    if (search) {
      where.OR = [
        { firstName: { contains: search } },
        { lastName: { contains: search } },
        { email: { contains: search } },
      ];
    }

    console.log('Where clause:', JSON.stringify(where));
    console.log('ğŸ”µ Fetching users from database...');

    // Ø®Ø·ÙˆØ© 1: Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ø¯ÙˆÙ† includes Ù…Ø¹Ù‚Ø¯Ø©
    const users = await prisma.user.findMany({
      where,
      include: {
        role: true
      },
      skip,
      take: limit,
      orderBy: { createdAt: 'desc' },
    });

    console.log(`âœ… Found ${users.length} users`);

    // Ø®Ø·ÙˆØ© 2: Ø¬Ù„Ø¨ userDetails Ø¨Ø´ÙƒÙ„ Ù…Ù†ÙØµÙ„
    const userIds = users.map(u => u.id);

    // Ø¬Ù„Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø¯Ø±ÙˆØ³ Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù… (Ø¨Ø´ÙƒÙ„ Ù…Ù†ÙØµÙ„ Ù„ØªØ¬Ù†Ø¨ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª)
    const lessonsCounts = await prisma.lesson.groupBy({
      by: ['authorId'],
      _count: { id: true },
      where: { authorId: { in: userIds } }
    });

    const lessonsCountMap = new Map<string, number>();
    lessonsCounts.forEach(l => {
      lessonsCountMap.set(l.authorId, l._count.id);
    });
    
    // Ø¬Ù„Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ù„ÙƒÙ„ Ù…Ø³ØªØ®Ø¯Ù… (Ø¹Ù† Ø·Ø±ÙŠÙ‚ ØªØ¬Ù…ÙŠØ¹ ØªÙ…Ø§Ø±ÙŠÙ† Ø¯Ø±ÙˆØ³Ù‡Ù…)
    const lessonsWithCounts = await prisma.lesson.findMany({
      where: { authorId: { in: userIds } },
      select: {
        authorId: true,
        _count: { select: { exercises: true } }
      }
    });

    const exercisesCountMap = new Map<string, number>();
    lessonsWithCounts.forEach(l => {
      const current = exercisesCountMap.get(l.authorId) || 0;
      exercisesCountMap.set(l.authorId, current + l._count.exercises);
    });

    const userDetails = await prisma.userDetails.findMany({
      where: {
        userId: { in: userIds }
      },
      include: {
        stage: true,
        level: true,
        subject: true,
      },
    });

    console.log(`âœ… Found ${userDetails.length} user details`);

    // Ø®Ø·ÙˆØ© 3: Ø±Ø¨Ø· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙŠØ¯ÙˆÙŠØ§Ù‹
    const usersWithDetails = users.map(user => {
      const details = userDetails.find(d => d.userId === user.id);
      return {
        ...user,
        userDetails: details || null,
      };
    });

    // Ø®Ø·ÙˆØ© 4: ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
    const formattedUsers = usersWithDetails.map(user => ({
      id: user.id,
      email: user.email,
      name: `${user.firstName} ${user.lastName}`,
      image: user.image,
      role: user.role.name,
      profileComplete: user.profileComplete,
      isBanned: user.userDetails?.isBanned || false,
      lessonsCount: lessonsCountMap.get(user.id) || 0,
      exercisesCount: exercisesCountMap.get(user.id) || 0,
      createdAt: user.createdAt.toISOString(),
      updatedAt: user.updatedAt.toISOString(),
      details: user.userDetails ? {
        phone: user.userDetails.phone,
        address: user.userDetails.address,
        bio: user.userDetails.bio,
        stageId: user.userDetails.stageId,
        levelId: user.userDetails.levelId,
        subjectId: user.userDetails.subjectId,
        parentCode: user.userDetails.parentCode,
        teacherCode: user.userDetails.teacherCode,
        stage: user.userDetails.stage,
        level: user.userDetails.level,
        subject: user.userDetails.subject,
      } : null,
    }));

    const total = await prisma.user.count({ where });

    console.log('âœ… Returning response');

    return NextResponse.json({
      success: true,
      data: formattedUsers,
      total,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (error: any) {
    console.error('âŒâŒâŒ CRITICAL ERROR in GET /api/users âŒâŒâŒ');
    console.error('Error name:', error.name);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);
    console.error('Full error object:', JSON.stringify(error, null, 2));
    return NextResponse.json(
      { 
        success: false, 
        message: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†',
        error: error.toString(),
      },
      { status: 500 }
    );
  }
}


// POST /api/users - Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
export async function POST(request: NextRequest) {
  try {
    await requireRole(['directeur']);

    const body = await request.json();
    const {
      firstName,
      lastName,
      email,
      password,
      roleName,
      stageId,
      levelId,
      subjectId,
    } = body;

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    if (!firstName || !lastName || !email || !password || !roleName) {
      return errorResponse('Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨Ø©', 400);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return errorResponse('Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„', 400);
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¯ÙˆØ±
    const role = await prisma.role.findFirst({
      where: { name: roleName },
    });

    if (!role) {
      return errorResponse('Ø§Ù„Ø¯ÙˆØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 400);
    }

    // ØªØ´ÙÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
    const hashedPassword = await bcrypt.hash(password, 10);

    // Ø¥Ù†Ø´Ø§Ø¡ ÙƒÙˆØ¯ ÙØ±ÙŠØ¯ Ù„Ù„Ù…Ø¹Ù„Ù… Ø£Ùˆ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±
    let teacherCode: string | undefined;
    let parentCode: string | undefined;

    if (roleName === 'teacher' || roleName === 'supervisor_specific') {
      teacherCode = `T${Date.now().toString().slice(-6)}`;
    } else if (roleName === 'parent') {
      parentCode = `P${Date.now().toString().slice(-6)}`;
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ Ø§Ù„ØªÙØ§ØµÙŠÙ„
    const user = await prisma.user.create({
      data: {
        firstName,
        lastName,
        email,
        password: hashedPassword,
        roleId: role.id,
        userDetails: {
          create: {
            stageId: stageId || null,
            levelId: levelId || null,
            subjectId: subjectId || null,
            teacherCode,
            parentCode,
          },
        },
      },
      include: {
        role: true,
        userDetails: {
          include: {
            stage: true,
            level: true,
            subject: true,
          },
        },
      },
    });

    // Fire-and-forget Google Drive folder creation
    handleTeacherFolderCreation(user);

    return successResponse(user, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø¬Ø§Ø­', 201);
  } catch (error: any) {
    console.error('Error creating user:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…', 500);
  }
}


// ==========================================
// FILE: src/app/api/users/generate-teacher-code/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// Generate a unique teacher code
function generateTeacherCode(): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 8; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// POST /api/users/generate-teacher-code
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth();

    if (session.user.role !== 'teacher') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ø£Ø³Ø§ØªØ°Ø© ÙŠÙ…ÙƒÙ†Ù‡Ù… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø·', 403);
    }

    // Generate unique code
    let teacherCode = generateTeacherCode();
    let exists = await prisma.userDetails.findFirst({
      where: { teacherCode }
    });

    // Ensure uniqueness
    while (exists) {
      teacherCode = generateTeacherCode();
      exists = await prisma.userDetails.findFirst({
        where: { teacherCode }
      });
    }

    // Unlink all students connected with this teacher
    await prisma.teacherStudentLink.deleteMany({
      where: { teacherId: session.user.id },
    });

    // Update user details with new teacher code
    await prisma.userDetails.upsert({
      where: { userId: session.user.id },
      create: {
        userId: session.user.id,
        teacherCode,
      },
      update: {
        teacherCode,
      },
    });

    return successResponse({ teacherCode }, 'ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­ ÙˆÙÙƒ Ø§Ø±ØªØ¨Ø§Ø· Ø§Ù„ØªÙ„Ø§Ù…ÙŠØ° Ø§Ù„Ø³Ø§Ø¨Ù‚ÙŠÙ†');
  } catch (error: any) {
    console.error('Error generating teacher code:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ø±Ø¨Ø·', 500);
  }
}


// ==========================================
// FILE: src/app/api/teachers/[id]/messaging-status/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// Get teacher's messaging status
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const teacherId = params.id;

    const teacher = await prisma.user.findUnique({
      where: { id: teacherId },
      include: {
        userDetails: {
          select: {
            allowMessaging: true,
          },
        },
      },
    });

    if (!teacher) {
      return NextResponse.json(
        { success: false, error: "Teacher not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      data: {
        allowMessaging: teacher.userDetails?.allowMessaging || false,
      },
    });
  } catch (error) {
    console.error("Error fetching teacher messaging status:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch messaging status" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/teachers/dashboard/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const teacherId = session.user.id;

    // Get teacher details with code
    const teacher = await prisma.user.findUnique({
      where: { id: teacherId },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        userDetails: {
          select: {
            teacherCode: true,
            allowMessaging: true,
          },
        },
      },
    });

    if (!teacher) {
      return NextResponse.json(
        { success: false, error: "Teacher not found" },
        { status: 404 }
      );
    }

    // Get teacher's lessons count
    const lessonsCount = await prisma.lesson.count({
      where: { authorId: teacherId },
    });

    // Get teacher's exercises count (from their lessons)
    const teacherLessons = await prisma.lesson.findMany({
      where: { authorId: teacherId },
      select: { id: true },
    });
    const lessonIds = teacherLessons.map(l => l.id);

    const exercisesCount = await prisma.exercise.count({
      where: { lessonId: { in: lessonIds } },
    });

    // Get connected students count via TeacherStudentLink
    const studentsCount = await prisma.teacherStudentLink.count({
      where: { teacherId },
    });

    // Get submissions count for teacher's exercises
    const exercises = await prisma.exercise.findMany({
      where: { lessonId: { in: lessonIds } },
      select: { id: true },
    });
    const exerciseIds = exercises.map(e => e.id);

    const submissionsCount = await prisma.submission.count({
      where: { exerciseId: { in: exerciseIds } },
    });

    // Get pending submissions count
    const pendingSubmissionsCount = await prisma.submission.count({
      where: {
        exerciseId: { in: exerciseIds },
        status: 'pending',
      },
    });

    // Get recent submissions
    const recentSubmissions = await prisma.submission.findMany({
      where: {
        exerciseId: { in: exerciseIds },
      },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
          },
        },
        exercise: {
          include: {
            lesson: {
              select: {
                title: true,
              },
            },
          },
        },
      },
      orderBy: {
        submittedAt: 'desc',
      },
      take: 5,
    });

    return NextResponse.json({
      success: true,
      data: {
        teacher: {
          id: teacher.id,
          firstName: teacher.firstName,
          lastName: teacher.lastName,
          email: teacher.email,
          teacherCode: teacher.userDetails?.teacherCode || null,
          allowMessaging: teacher.userDetails?.allowMessaging || false,
        },
        stats: {
          lessons: lessonsCount,
          exercises: exercisesCount,
          students: studentsCount,
          submissions: submissionsCount,
          pendingSubmissions: pendingSubmissionsCount,
        },
        recentSubmissions: recentSubmissions.map(sub => ({
          id: sub.id,
          studentName: `${sub.student.firstName} ${sub.student.lastName}`,
          lessonTitle: sub.exercise.lesson.title,
          exerciseQuestion: sub.exercise.question,
          status: sub.status,
          score: sub.finalScore || sub.aiScore,
          submittedAt: sub.submittedAt,
        })),
      },
    });
  } catch (error) {
    console.error("Error fetching teacher dashboard:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch teacher dashboard" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/teachers/toggle-messaging/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

// Toggle teacher messaging setting
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const teacherId = session.user.id;

    // Get current setting
    const currentDetails = await prisma.userDetails.findUnique({
      where: { userId: teacherId },
    });

    const newAllowMessaging = !currentDetails?.allowMessaging;

    // Update teacher's messaging setting
    const updatedDetails = await prisma.userDetails.upsert({
      where: { userId: teacherId },
      update: { allowMessaging: newAllowMessaging },
      create: {
        userId: teacherId,
        allowMessaging: newAllowMessaging,
        aiEvalMode: 'auto',
      },
    });

    return NextResponse.json({
      success: true,
      data: {
        allowMessaging: updatedDetails.allowMessaging,
        message: updatedDetails.allowMessaging
          ? "ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±"
          : "ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±",
      },
    });
  } catch (error) {
    console.error("Error updating messaging setting:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update setting" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/subject-supervisor/statistics/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getSession } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/subject-supervisor/statistics
export async function GET(request: NextRequest) {
  try {
    const session = await getSession();
    
    if (!session?.user?.id) {
      return errorResponse('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„', 401);
    }

    const supervisorId = session.user.id;

    // Get supervisor with subject and level details
    const supervisor = await prisma.user.findUnique({
      where: { id: supervisorId },
      include: {
        userDetails: {
          include: {
            subject: true,
            level: {
              include: {
                stage: true,
              },
            },
          },
        },
      },
    });

    if (!supervisor || !supervisor.userDetails?.subjectId || !supervisor.userDetails?.levelId) {
      return errorResponse('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù…Ù‰ Ø´Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ Ø§Ù„Ù…Ø³ØªÙˆÙ‰', 404);
    }

    const subjectId = supervisor.userDetails.subjectId;
    const levelId = supervisor.userDetails.levelId;

    // Get lessons count for this level (all lessons, not just supervisor's)
    const lessonsCount = await prisma.lesson.count({
      where: {
        subjectId,
        levelId,
      },
    });

    // Get exercises count for lessons in this level
    const exercisesCount = await prisma.exercise.count({
      where: {
        lesson: {
          subjectId,
          levelId,
        },
      },
    });

    // Get teachers count who teach this subject
    const teachersCount = await prisma.user.count({
      where: {
        role: {
          name: 'teacher',
        },
        userDetails: {
          subjectId,
        },
      },
    });

    // Get students count linked to teachers of this subject
    const teachersInSubject = await prisma.user.findMany({
      where: {
        role: {
          name: 'teacher',
        },
        userDetails: {
          subjectId,
        },
      },
      select: {
        userDetails: {
          select: {
            teacherCode: true,
          },
        },
      },
    });

    const teacherCodes = teachersInSubject
      .map(t => t.userDetails?.teacherCode)
      .filter(Boolean) as string[];

    const studentsCount = await prisma.user.count({
      where: {
        role: {
          name: 'student',
        },
        userDetails: {
          teacherCode: {
            in: teacherCodes,
          },
        },
      },
    });

    // Get top teachers by lesson count
    const teachers = await prisma.user.findMany({
      where: {
        role: {
          name: 'teacher',
        },
        userDetails: {
          subjectId,
        },
      },
      include: {
        _count: {
          select: {
            authoredLessons: true,
          },
        },
      },
      orderBy: {
        authoredLessons: {
          _count: 'desc',
        },
      },
      take: 5,
    });

    const topTeachers = teachers.map(teacher => ({
      id: teacher.id,
      name: `${teacher.firstName} ${teacher.lastName}`,
      email: teacher.email,
      image: teacher.image,
      lessonCount: teacher._count.authoredLessons,
    }));

    return successResponse({
      supervisor: {
        id: supervisor.id,
        name: `${supervisor.firstName} ${supervisor.lastName}`,
        email: supervisor.email,
        subject: supervisor.userDetails.subject,
        level: supervisor.userDetails.level,
      },
      stats: {
        lessons: lessonsCount,
        exercises: exercisesCount,
        teachers: teachersCount,
        students: studentsCount,
      },
      topTeachers,
    });
  } catch (error: any) {
    console.error('Error fetching supervisor statistics:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª', 500);
  }
}


// ==========================================
// FILE: src/app/api/subject-supervisor/dashboard/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getSession } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/subject-supervisor/dashboard
export async function GET(request: NextRequest) {
  try {
    const session = await getSession();
    
    if (!session?.user?.id) {
      return errorResponse('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„', 401);
    }

    const supervisorId = session.user.id;

    // Get supervisor with subject and level details
    const supervisor = await prisma.user.findUnique({
      where: { id: supervisorId },
      include: {
        userDetails: {
          include: {
            subject: true,
            level: {
              include: {
                stage: true,
              },
            },
          },
        },
      },
    });

    if (!supervisor || !supervisor.userDetails?.subjectId || !supervisor.userDetails?.levelId) {
      return errorResponse('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ Ø§Ù„Ù…Ø³ØªÙˆÙ‰', 404);
    }

    const subjectId = supervisor.userDetails.subjectId;
    const levelId = supervisor.userDetails.levelId;

    // Get lessons count for this level (lessons created by supervisor)
    const lessonsCount = await prisma.lesson.count({
      where: {
        subjectId,
        levelId,
        authorId: supervisorId,
      },
    });

    // Get exercises count for supervisor's lessons in this level
    const supervisorLessons = await prisma.lesson.findMany({
      where: {
        subjectId,
        levelId,
        authorId: supervisorId,
      },
      select: { id: true },
    });

    const lessonIds = supervisorLessons.map(l => l.id);
    
    const exercisesCount = await prisma.exercise.count({
      where: {
        lessonId: { in: lessonIds },
      },
    });

    // Get all teachers teaching this subject
    const teachersCount = await prisma.userDetails.count({
      where: {
        subjectId,
        user: {
          role: {
            name: 'teacher',
          },
        },
      },
    });

    // Get all students enrolled in this subject (through teacher links)
    const teachersWithSubject = await prisma.userDetails.findMany({
      where: {
        subjectId,
        user: {
          role: {
            name: 'teacher',
          },
        },
      },
      select: {
        userId: true,
      },
    });

    const teacherIds = teachersWithSubject.map(t => t.userId);
    
    // Get unique students count
    const uniqueStudents = await prisma.teacherStudentLink.findMany({
      where: {
        teacherId: { in: teacherIds },
      },
      select: {
        studentId: true,
      },
      distinct: ['studentId'],
    });
    
    const studentsCount = uniqueStudents.length;

    // Get recent lessons for this level
    const recentLessons = await prisma.lesson.findMany({
      where: {
        subjectId,
        levelId,
        authorId: supervisorId,
      },
      include: {
        level: {
          include: {
            stage: true,
          },
        },
        _count: {
          select: {
            exercises: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
      take: 5,
    });

    return successResponse({
      supervisor: {
        id: supervisor.id,
        name: `${supervisor.firstName} ${supervisor.lastName}`,
        email: supervisor.email,
        subject: supervisor.userDetails.subject,
        level: supervisor.userDetails.level,
        allowMessaging: supervisor.userDetails.allowMessaging || false,
        teacherCode: supervisor.userDetails.teacherCode,
      },
      stats: {
        lessons: lessonsCount,
        exercises: exercisesCount,
        teachers: teachersCount,
        students: studentsCount,
      },
      recentLessons: recentLessons.map(lesson => ({
        id: lesson.id,
        title: lesson.title,
        description: lesson.description,
        levelName: lesson.level?.name,
        stageName: lesson.level?.stage?.name,
        exercisesCount: lesson._count.exercises,
        createdAt: lesson.createdAt.toISOString(),
      })),
    });
  } catch (error: any) {
    console.error('Error fetching supervisor dashboard:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 500);
  }
}


// ==========================================
// FILE: src/app/api/subject-supervisor/exercises/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getSession } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';

// GET /api/subject-supervisor/exercises
export async function GET(request: NextRequest) {
  try {
    const session = await getSession();
    
    if (!session?.user?.id) {
      return errorResponse('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„', 401);
    }

    const supervisorId = session.user.id;

    // Get supervisor with subject and level details
    const supervisor = await prisma.user.findUnique({
      where: { id: supervisorId },
      include: {
        userDetails: {
          include: {
            subject: true,
            level: true,
          },
        },
      },
    });

    if (!supervisor || !supervisor.userDetails?.subjectId || !supervisor.userDetails?.levelId) {
      return errorResponse('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ Ø§Ù„Ù…Ø§Ø¯Ø© Ø£Ùˆ Ø§Ù„Ù…Ø³ØªÙˆÙ‰', 404);
    }

    const subjectId = supervisor.userDetails.subjectId;
    const levelId = supervisor.userDetails.levelId;

    // Get only exercises for lessons created by this supervisor
    const exercises = await prisma.exercise.findMany({
      where: {
        lesson: {
          authorId: supervisorId, // ÙÙ‚Ø· Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„ØªÙŠ Ø£Ù†Ø´Ø£Ù‡Ø§ Ø§Ù„Ù…Ø´Ø±Ù
          subjectId,
          levelId,
        },
      },
      include: {
        lesson: {
          select: {
            id: true,
            title: true,
          },
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    const formattedExercises = exercises.map(exercise => ({
      id: exercise.id,
      question: exercise.question,
      lesson: {
        id: exercise.lesson.id,
        title: exercise.lesson.title,
      },
    }));

    return successResponse(formattedExercises, `ØªÙ… Ø¬Ù„Ø¨ ${formattedExercises.length} ØªÙ…Ø±ÙŠÙ†`);
  } catch (error: any) {
    console.error('Error fetching exercises:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†', 500);
  }
}


// ==========================================
// FILE: src/app/api/lessons/[id]/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { requireAuth } from '@/lib/api-auth';
import { errorResponse, successResponse } from '@/lib/api-response';

const prisma = new PrismaClient();

// Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø¯Ø±Ø³ Ù…Ø­Ø¯Ø¯ (Ù„ØµÙØ­Ø© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„)
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await requireAuth();

    if (!user) {
      console.error('[API - Lessons ID - GET] Authentication failed: User is null');
      return errorResponse('Authentication failed: User is null', 401);
    }

    const { id } = await params;
    const lessonId = parseInt(id);

    if (isNaN(lessonId)) {
      return errorResponse('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø³ ØºÙŠØ± ØµØ§Ù„Ø­', 400);
    }

    const lesson = await prisma.lesson.findUnique({
      where: { id: lessonId },
      include: {
        subject: true,
        level: true,
      }
    });

    if (!lesson) {
      return errorResponse('Ø§Ù„Ø¯Ø±Ø³ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 404);
    }

    return successResponse(lesson);
  } catch (error: any) {
    console.error('Error fetching lesson:', error);
    return errorResponse('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø¯Ø±Ø³', 500);
  }
}

// ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø³
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
     const user = await requireAuth();

    if (!user) {
      console.error('[API - Lessons ID - PUT] Authentication failed: User is null');
      return errorResponse('Authentication failed: User is null', 401);
    }

    const { id } = await params;
    const lessonId = parseInt(id);

    if (isNaN(lessonId)) {
      return errorResponse('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø³ ØºÙŠØ± ØµØ§Ù„Ø­', 400);
    }

    const body = await request.json();
    const { title, content, videoUrl, imageUrl, pdfUrl, subjectId, levelId } = body;

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¯Ø±Ø³ ÙˆÙ…Ù„ÙƒÙŠØªÙ‡
    const existingLesson = await prisma.lesson.findUnique({
        where: { id: lessonId },
        select: { authorId: true }
    });

    if (!existingLesson) {
        return errorResponse('Ø§Ù„Ø¯Ø±Ø³ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 404);
    }

    if (!user || !user.id) {
      return errorResponse('Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø¹Ø±Ù. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„.', 401);
    }

    console.log(`[DEBUG] Update Lesson: User ID (${user.id}) vs Author ID (${existingLesson.authorId})`);

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ùˆ ØµØ§Ø­Ø¨ Ø§Ù„Ø¯Ø±Ø³
    if (existingLesson.authorId && existingLesson.authorId !== user.id) {
      return errorResponse(`ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø¨ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø¯Ø±Ø³. (Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${user.id}ØŒ Ø§Ù„Ù…Ø¤Ù„Ù: ${existingLesson.authorId})`, 403);
    }

    const updatedLesson = await prisma.lesson.update({
      where: { id: lessonId },
      data: {
        title,
        content,
        videoUrl,
        imageUrl,
        pdfUrl,
        subjectId,
        levelId,
      },
    });

    return successResponse(updatedLesson, 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Error updating lesson:', error);
    return errorResponse('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯Ø±Ø³', 500);
  }
}

// Ø­Ø°Ù Ø§Ù„Ø¯Ø±Ø³ (Ø¥Ø¶Ø§ÙÙŠ)
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await requireAuth();

    if (!user) {
      console.error('[API - Lessons ID - DELETE] Authentication failed: User is null');
      return errorResponse('Authentication failed: User is null', 401);
    }

    const { id } = await params;
    const lessonId = parseInt(id);

    if (isNaN(lessonId)) {
      return errorResponse('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø³ ØºÙŠØ± ØµØ§Ù„Ø­', 400);
    }

    const existingLesson = await prisma.lesson.findUnique({
        where: { id: lessonId },
        select: { authorId: true }
    });

    if (!existingLesson) {
        return errorResponse('Ø§Ù„Ø¯Ø±Ø³ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 404);
    }

    if (!user || !user.id) {
      return errorResponse('Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø¹Ø±Ù. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„.', 401);
    }

    console.log(`[DEBUG] Delete Lesson: User ID (${user.id}) vs Author ID (${existingLesson.authorId})`);

    if (existingLesson.authorId && existingLesson.authorId !== user.id) {
      return errorResponse(`ØºÙŠØ± Ù…ØµØ±Ø­ Ù„Ùƒ Ø¨Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø¯Ø±Ø³. (Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${user.id}ØŒ Ø§Ù„Ù…Ø¤Ù„Ù: ${existingLesson.authorId})`, 403);
    }

    await prisma.lesson.delete({
      where: { id: lessonId },
    });

    return successResponse(null, 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Error deleting lesson:', error);
    return errorResponse('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ø¯Ø±Ø³', 500);
  }
}


// ==========================================
// FILE: src/app/api/lessons/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth, requireRole } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';
import { GoogleDriveService, getRootFolderId } from '@/lib/google-drive';
import { log, LogLevel, LogCategory } from '@/lib/logger';
import { saveBase64ToFile } from '@/lib/file-handler';

// Configure API route to accept larger payloads
export const config = {
  api: {
    bodyParser: {
      sizeLimit: '10mb',
    },
  },
};

// GET /api/lessons - Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¯Ø±ÙˆØ³
export async function GET(request: NextRequest) {
  try {
    const session = await requireAuth();
    const { searchParams } = new URL(request.url);

    const subjectId = searchParams.get('subjectId');
    const levelId = searchParams.get('levelId');
    const type = searchParams.get('type'); // public | private
    const authorId = searchParams.get('authorId');
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const skip = (page - 1) * limit;

    const where: any = {};
    const userRole = session.user.role?.toLowerCase();

    // ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ù…Ø¹Ù„Ù…Ø§Øª
    if (subjectId) where.subjectId = parseInt(subjectId);
    if (levelId) where.levelId = parseInt(levelId);
    if (type) where.type = type;
    if (authorId) where.authorId = authorId;

    // Ø§Ù„Ø·Ù„Ø§Ø¨ ÙŠØ±ÙˆÙ† ÙÙ‚Ø· Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ø¹Ø§Ù…Ø© + Ø¯Ø±ÙˆØ³ Ù…Ø¹Ù„Ù…Ù‡Ù…
    if (userRole === 'student') {
      const userDetails = await prisma.userDetails.findUnique({
        where: { userId: session.user.id },
        select: { levelId: true },
      });

      if (!userDetails?.levelId) {
        return successResponse({
          lessons: [],
          pagination: {
            page,
            limit,
            total: 0,
            totalPages: 0,
          },
        });
      }

      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ† Ø§Ù„Ù…Ø±ØªØ¨Ø·ÙŠÙ† Ø¨Ø§Ù„ØªÙ„Ù…ÙŠØ°
      const teacherLinks = await prisma.teacherStudentLink.findMany({
        where: { studentId: session.user.id },
        select: { teacherId: true },
      });

      const teacherIds = teacherLinks.map(link => link.teacherId);

      console.log('=== Student Lessons Debug ===');
      console.log('Student ID:', session.user.id);
      console.log('Student Level ID:', userDetails.levelId);
      console.log('Teacher Links:', teacherLinks);
      console.log('Teacher IDs:', teacherIds);
      console.log('Subject ID Filter:', subjectId);

      // Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø´Ø±Ø· WHERE Ù„Ù„Ø·Ù„Ø§Ø¨
      const studentWhere: any = {
        OR: [
          // 1. Ø§Ù„Ø¯Ø±ÙˆØ³ Ø§Ù„Ø¹Ø§Ù…Ø© Ù…Ù† Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªÙ„Ù…ÙŠØ°
          {
            type: 'public',
            levelId: userDetails.levelId,
            ...(subjectId && { subjectId: parseInt(subjectId) }),
          },
          // 2. Ø¬Ù…ÙŠØ¹ Ø¯Ø±ÙˆØ³ Ø£Ø³Ø§ØªØ°Ø© Ø§Ù„ØªÙ„Ù…ÙŠØ° (Ø¹Ø§Ù…Ø© Ø£Ùˆ Ø®Ø§ØµØ©)
          ...(teacherIds.length > 0 ? [{
            authorId: { in: teacherIds },
            levelId: userDetails.levelId,
            ...(subjectId && { subjectId: parseInt(subjectId) }),
          }] : []),
        ],
      };

      console.log('Student WHERE condition:', JSON.stringify(studentWhere, null, 2));

      // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ where Ø¨Ø§Ù„Ø´Ø±Ø· Ø§Ù„Ø¬Ø¯ÙŠØ¯
      Object.keys(where).forEach(key => delete where[key]);
      Object.assign(where, studentWhere);
    }

    // Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø© ÙŠØ±Ù‰ ÙÙ‚Ø· Ø¯Ø±ÙˆØ³Ù‡ Ù„Ù…Ø§Ø¯ØªÙ‡ ÙˆÙ…Ø³ØªÙˆØ§Ù‡
    if (userRole === 'supervisor_specific') {
      const userDetails = await prisma.userDetails.findUnique({
        where: { userId: session.user.id },
        select: {
          subjectId: true,
          levelId: true,
        },
      });

      if (!userDetails?.subjectId || !userDetails?.levelId) {
        return successResponse({
          lessons: [],
          pagination: {
            page,
            limit,
            total: 0,
            totalPages: 0,
          },
        });
      }

      // ØªØµÙÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¤Ù„Ù ÙˆØ§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø³ØªÙˆÙ‰
      where.authorId = session.user.id;
      where.subjectId = userDetails.subjectId;
      where.levelId = userDetails.levelId;
    }

    // Ø§Ù„Ù…Ø¹Ù„Ù… ÙŠØ±Ù‰ ÙÙ‚Ø· Ø¯Ø±ÙˆØ³Ù‡
    if (userRole === 'teacher') {
      where.authorId = session.user.id;
    }

    const [lessons, total] = await Promise.all([
      prisma.lesson.findMany({
        where,
        include: {
          author: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              image: true,
            },
          },
          subject: true,
          level: true,
          _count: {
            select: {
              exercises: true,
            },
          },
        },
        skip,
        take: limit,
        orderBy: [
          { level: { displayOrder: 'asc' } }, // ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ ØªØ³Ù„Ø³Ù„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø£ÙˆÙ„Ø§Ù‹
          { createdAt: 'desc' }               // Ø«Ù… Ø§Ù„Ø£Ø­Ø¯Ø« ÙØ§Ù„Ø£Ù‚Ø¯Ù…
        ],
      }),
      prisma.lesson.count({ where }),
    ]);

    return successResponse({
      lessons,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¯Ø±ÙˆØ³', 500);
  }
}

// POST /api/lessons - Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±Ø³ Ø¬Ø¯ÙŠØ¯
export async function POST(request: NextRequest) {
  try {
    const session = await requireRole(['teacher', 'supervisor_specific', 'supervisor_general', 'directeur']);

    const body = await request.json();
    console.log('--- DIAGNOSTIC: LESSON CREATION BODY ---', body);
    const {
      title,
      content,
      videoUrl,
      imageUrl, // Prioritize direct URL
      pdfUrl,   // Prioritize direct URL
      imageBase64,
      pdfBase64,
      subjectId,
      levelId,
      type = 'private',
      isLocked = false,
    } = body;

    if (!title || !subjectId || !levelId) {
      return errorResponse('Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø³ØªÙˆÙ‰ Ù…Ø·Ù„ÙˆØ¨Ø©', 400);
    }

    let driveFolderId: string | null = null;
    let finalImageUrl: string | null = imageUrl?.trim() || null;
    let finalPdfUrl: string | null = pdfUrl?.trim() || null;
    const lessonFileIds: string[] = [];

    // --- Google Drive Automation ---
    try {
      const subject = await prisma.subject.findUnique({
        where: { id: parseInt(subjectId) },
        include: { stage: true },
      });

      if (subject) {
        let subjectFolderId = subject.driveFolderId;

        // Self-healing: Ensure Subject folder exists if missing
        if (!subjectFolderId) {
          try {
            console.log(`Subject "${subject.name}" missing Drive folder. Attempting to fix...`);
            const rootId = getRootFolderId();
            let stageFolderId = subject.stage?.driveFolderId;

            // Ensure Stage folder exists
            if (!stageFolderId && subject.stage) {
              stageFolderId = await GoogleDriveService.getOrCreateFolder(subject.stage.name, rootId);
              await prisma.stage.update({ where: { id: subject.stage.id }, data: { driveFolderId: stageFolderId } });
            }

            if (stageFolderId) {
              subjectFolderId = await GoogleDriveService.getOrCreateFolder(subject.name, stageFolderId);
              await prisma.subject.update({ where: { id: subject.id }, data: { driveFolderId: subjectFolderId } });
            }
          } catch (fixError) {
            console.error('Failed to auto-fix Drive folders:', fixError);
          }
        }

        if (subjectFolderId) {
        // 1. Create/Get Teacher folder inside Subject folder
        let teacherName = 'Unknown Teacher';
        
        // Ensure we have the correct name even if session is missing fields
        if (session.user.firstName && session.user.lastName) {
             teacherName = `${session.user.firstName} ${session.user.lastName}`;
        } else {
             // Fallback: fetch from DB to ensure we don't get "undefined undefined"
             const author = await prisma.user.findUnique({
                 where: { id: session.user.id },
                 select: { firstName: true, lastName: true }
             });
             if (author && author.firstName && author.lastName) {
                 teacherName = `${author.firstName} ${author.lastName}`;
             } else if (session.user.name) {
                 teacherName = session.user.name;
             } else {
                 teacherName = `Teacher ${session.user.id}`;
             }
        }

        const teacherFolderId = await GoogleDriveService.getOrCreateFolder(teacherName, subjectFolderId);

        // 2. Create Lesson folder inside Teacher folder
        const safeTitle = title.replace(/[\\/:"*?<>|]+/g, '_').trim();
        driveFolderId = await GoogleDriveService.createFolder(safeTitle, teacherFolderId);

        // 3. Upload files (if any) into the new lesson folder
        if (!finalImageUrl && imageBase64 && typeof imageBase64 === 'string') {
          const mimeTypeMatch = imageBase64.match(/^data:(image\/[a-zA-Z0-9+.-]+);base64,/);
          const mimeType = mimeTypeMatch ? mimeTypeMatch[1] : 'image/png';
          const base64Data = imageBase64.split(';base64,').pop() || '';
          const buffer = Buffer.from(base64Data, 'base64');

          const uploadResult = await GoogleDriveService.uploadFile(
            `Cover Image - ${safeTitle}`,
            buffer,
            mimeType,
            driveFolderId
          );
          if (uploadResult?.fileId) {
            finalImageUrl = `https://drive.google.com/uc?export=view&id=${uploadResult.fileId}`;
            lessonFileIds.push(uploadResult.fileId);
          }
        }

        if (!finalPdfUrl && pdfBase64 && typeof pdfBase64 === 'string') {
          const base64Data = pdfBase64.split(';base64,').pop() || '';
          const buffer = Buffer.from(base64Data, 'base64');
          const uploadResult = await GoogleDriveService.uploadFile(
            `Lesson PDF - ${safeTitle}.pdf`,
            buffer,
            'application/pdf',
            driveFolderId
          );
          if (uploadResult?.fileId) {
            finalPdfUrl = `https://drive.google.com/uc?export=view&id=${uploadResult.fileId}`;
            lessonFileIds.push(uploadResult.fileId);
          }
        }
        } else {
          console.warn(`Could not create Drive folder for lesson "${title}" because parent subject (ID: ${subjectId}) has no driveFolderId.`);
        }
      }
    } catch (driveError) {
      console.error('Google Drive Integration Error:', driveError);
    }

    // Fallback: Save files locally if Drive upload failed or was skipped
    if (!finalImageUrl && imageBase64 && typeof imageBase64 === 'string') {
      console.log('Saving image locally (Drive upload skipped or failed)...');
      try {
        const extensionMatch = imageBase64.match(/data:image\/(.*?);base64,/);
        const extension = extensionMatch ? `.${extensionMatch[1]}` : '.png';
        finalImageUrl = saveBase64ToFile(imageBase64, 'lessons-images', extension);
      } catch (e: any) {
        console.error("Failed to save image from Base64:", e.message);
        return errorResponse(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ù…Ù„Ù Ø§Ù„ØµÙˆØ±Ø©: ${e.message}`, 500);
      }
    }

    if (!finalPdfUrl && pdfBase64 && typeof pdfBase64 === 'string') {
      try {
        const extensionMatch = pdfBase64.match(/data:application\/(.*?);base64,/);
        const extension = extensionMatch ? `.${extensionMatch[1]}` : '.pdf';
        finalPdfUrl = saveBase64ToFile(pdfBase64, 'lessons-pdfs', extension);
      } catch (e: any) {
        console.error("Failed to save PDF from Base64:", e.message);
        return errorResponse(`ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ù…Ù„Ù PDF: ${e.message}`, 500);
      }
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³
    const lesson = await prisma.lesson.create({
      data: {
        title,
        content: content || '',
        videoUrl: videoUrl || null,
        imageUrl: finalImageUrl,
        pdfUrl: finalPdfUrl,
        subjectId: parseInt(subjectId),
        levelId: parseInt(levelId),
        authorId: session.user.id,
        type,
        isLocked,
        status: 'approved', // Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯Ø±ÙˆØ³ Ù…Ø¹ØªÙ…Ø¯Ø© Ù…Ø¨Ø§Ø´Ø±Ø©
        driveFolderId: driveFolderId, // Ø­ÙØ¸ Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø¬Ù„Ø¯
        lessonFileIds: lessonFileIds, // Ø­ÙØ¸ Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ù…Ù„ÙØ§Øª
      },
    });

    console.log(`âœ… Lesson created successfully: "${lesson.title}" (ID: ${lesson.id})`);

    return successResponse(lesson, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³ Ø¨Ù†Ø¬Ø§Ø­', 201);
  } catch (error: any) {
    console.error('Error creating lesson:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³', 500);
  }
}


// ==========================================
// FILE: src/app/api/profile/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const userId = session.user.id; // Already a string

    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        userDetails: {
          include: {
            level: true,
            stage: true,
          },
        },
      },
    });

    if (!user) {
      return NextResponse.json(
        { success: false, error: "User not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      data: {
        user: {
          id: user.id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          image: user.image,
          userDetails: user.userDetails,
        },
      },
    });
  } catch (error) {
    console.error("Error fetching profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch profile" },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const userId = session.user.id; // Already a string
    const body = await request.json();
    const { prenom, nom, email } = body;

    // Validate input
    if (!prenom || !nom || !email) {
      return NextResponse.json(
        { success: false, error: "All fields are required" },
        { status: 400 }
      );
    }

    // Update user
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: {
        firstName: prenom,
        lastName: nom,
        email,
      },
    });

    return NextResponse.json({
      success: true,
      data: {
        user: {
          id: updatedUser.id,
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          email: updatedUser.email,
        },
      },
    });
  } catch (error) {
    console.error("Error updating profile:", error);
    return NextResponse.json(
      { success: false, error: "Failed to update profile" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/parents/notifications/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const parentId = session.user.id;

    // Get all linked children
    const parentChildLinks = await prisma.parentChildLink.findMany({
      where: { parentId },
      select: {
        childId: true,
      },
    });

    const childrenIds = parentChildLinks.map(link => link.childId);

    if (childrenIds.length === 0) {
      return NextResponse.json({
        success: true,
        data: {
          notifications: [],
        },
      });
    }

    // Get recent submissions from all children
    const submissions = await prisma.submission.findMany({
      where: {
        studentId: { in: childrenIds },
        status: 'graded', // Only show graded submissions
      },
      include: {
        student: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            image: true,
          },
        },
        exercise: {
          include: {
            lesson: {
              include: {
                subject: true,
              },
            },
          },
        },
      },
      orderBy: {
        submittedAt: 'desc',
      },
      take: 50, // Get last 50 notifications
    });

    const notifications = submissions.map(sub => {
      const score = Number(sub.finalScore || sub.aiScore || 0);
      let status: 'excellent' | 'good' | 'needs_improvement';
      
      if (score >= 8) {
        status = 'excellent';
      } else if (score >= 5) {
        status = 'good';
      } else {
        status = 'needs_improvement';
      }

      return {
        id: sub.id,
        student: {
          id: sub.student.id,
          firstName: sub.student.firstName,
          lastName: sub.student.lastName,
          image: sub.student.image,
        },
        exercise: {
          question: sub.exercise.question,
        },
        lesson: {
          title: sub.exercise.lesson.title,
        },
        subject: {
          name: sub.exercise.lesson.subject.name,
        },
        score,
        status,
        attemptNumber: sub.attemptNumber,
        submittedAt: sub.submittedAt,
      };
    });

    return NextResponse.json({
      success: true,
      data: {
        notifications,
      },
    });
  } catch (error) {
    console.error("Error fetching notifications:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch notifications" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/parents/generate-code/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";

// Generate random 8-character code
function generateParentCode(): string {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let code = "P-"; // Prefix for Parent
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const parentId = session.user.id;

    // Check if user is a parent
    const user = await prisma.user.findUnique({
      where: { id: parentId },
      include: { role: true },
    });

    if (!user || user.role.name !== "parent") {
      return NextResponse.json(
        { success: false, error: "Only parents can generate parent codes" },
        { status: 403 }
      );
    }

    // Get current parent code
    const currentDetails = await prisma.userDetails.findUnique({
      where: { userId: parentId },
      select: { parentCode: true },
    });

    // If regenerating, unlink all children first
    if (currentDetails?.parentCode) {
      await prisma.parentChildLink.deleteMany({
        where: { parentId },
      });
    }

    // Generate new unique code
    let newCode = generateParentCode();
    let isUnique = false;

    while (!isUnique) {
      const existing = await prisma.userDetails.findUnique({
        where: { parentCode: newCode },
      });
      if (!existing) {
        isUnique = true;
      } else {
        newCode = generateParentCode();
      }
    }

    // Update parent code in userDetails
    await prisma.userDetails.upsert({
      where: { userId: parentId },
      update: { parentCode: newCode },
      create: {
        userId: parentId,
        parentCode: newCode,
      },
    });

    return NextResponse.json({
      success: true,
      data: {
        parentCode: newCode,
        message: currentDetails?.parentCode
          ? "ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø¬Ø¯ÙŠØ¯ ÙˆÙÙƒ Ø§Ù„Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø³Ø§Ø¨Ù‚ÙŠÙ†"
          : "ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ø¨Ù†Ø¬Ø§Ø­",
      },
    });
  } catch (error) {
    console.error("Error generating parent code:", error);
    return NextResponse.json(
      { success: false, error: "Failed to generate parent code" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/parents/children/[id]/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const parentId = session.user.id;
    const childId = params.id;

    // Verify parent-child relationship
    const link = await prisma.parentChildLink.findUnique({
      where: {
        parentId_childId: {
          parentId,
          childId,
        },
      },
    });

    if (!link) {
      return NextResponse.json(
        { success: false, error: "Child not found or not linked to you" },
        { status: 404 }
      );
    }

    // Get child details
    const child = await prisma.user.findUnique({
      where: { id: childId },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        image: true,
        userDetails: {
          select: {
            level: {
              select: {
                id: true,
                name: true,
                stage: {
                  select: {
                    id: true,
                    name: true,
                  },
                },
              },
            },
          },
        },
      },
    });

    if (!child) {
      return NextResponse.json(
        { success: false, error: "Child not found" },
        { status: 404 }
      );
    }

    // Get all submissions with exercise and lesson details
    const submissions = await prisma.submission.findMany({
      where: {
        studentId: childId,
      },
      include: {
        exercise: {
          include: {
            lesson: {
              include: {
                subject: true,
              },
            },
          },
        },
      },
      orderBy: {
        submittedAt: 'desc',
      },
    });

    // Calculate statistics
    const gradedSubmissions = submissions.filter(s => s.status === 'graded');
    let totalScore = 0;
    gradedSubmissions.forEach((sub) => {
      totalScore += Number(sub.finalScore || sub.aiScore || 0);
    });
    
    const averageScore = gradedSubmissions.length > 0 
      ? Math.round((totalScore / gradedSubmissions.length)) 
      : 0;

    // Group submissions by subject
    const submissionsBySubject: Record<string, any[]> = {};
    submissions.forEach((sub) => {
      const subjectName = sub.exercise.lesson.subject.name;
      if (!submissionsBySubject[subjectName]) {
        submissionsBySubject[subjectName] = [];
      }
      submissionsBySubject[subjectName].push({
        id: sub.id,
        exerciseQuestion: sub.exercise.question,
        lessonTitle: sub.exercise.lesson.title,
        score: Number(sub.finalScore || sub.aiScore || 0),
        status: sub.status,
        submittedAt: sub.submittedAt,
        attemptNumber: sub.attemptNumber,
      });
    });

    // Calculate subject averages
    const subjectStats = Object.entries(submissionsBySubject).map(([subject, subs]) => {
      const gradedSubs = subs.filter(s => s.status === 'graded');
      const total = gradedSubs.reduce((acc, s) => acc + s.score, 0);
      const avg = gradedSubs.length > 0 ? Math.round(total / gradedSubs.length) : 0;
      
      return {
        subject,
        averageScore: avg,
        submissionCount: subs.length,
        gradedCount: gradedSubs.length,
      };
    });

    // Get recent submissions (last 10)
    const recentSubmissions = submissions.slice(0, 10).map(sub => ({
      id: sub.id,
      exerciseQuestion: sub.exercise.question,
      lessonTitle: sub.exercise.lesson.title,
      subjectName: sub.exercise.lesson.subject.name,
      score: Number(sub.finalScore || sub.aiScore || 0),
      status: sub.status,
      submittedAt: sub.submittedAt,
      attemptNumber: sub.attemptNumber,
      aiFeedback: sub.aiFeedback,
      teacherNotes: sub.teacherNotes,
    }));

    return NextResponse.json({
      success: true,
      data: {
        child: {
          id: child.id,
          firstName: child.firstName,
          lastName: child.lastName,
          email: child.email,
          image: child.image,
          level: child.userDetails?.level || null,
        },
        stats: {
          totalSubmissions: submissions.length,
          gradedSubmissions: gradedSubmissions.length,
          averageScore,
          completedLessons: new Set(submissions.map(s => s.exercise.lessonId)).size,
        },
        subjectStats,
        recentSubmissions,
      },
    });
  } catch (error) {
    console.error("Error fetching child details:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch child details" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/parents/children/[id]/subjects/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// Get teacher's subjects with messaging status
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const parentId = session.user.id;
    const childId = params.id;

    // Verify parent-child relationship
    const link = await prisma.parentChildLink.findUnique({
      where: {
        parentId_childId: {
          parentId,
          childId,
        },
      },
    });

    if (!link) {
      return NextResponse.json(
        { success: false, error: "Child not found or not linked" },
        { status: 404 }
      );
    }

    // Get child's level
    const child = await prisma.user.findUnique({
      where: { id: childId },
      include: {
        userDetails: {
          include: {
            level: {
              include: {
                subjects: true,
              },
            },
          },
        },
      },
    });

    if (!child || !child.userDetails?.level || !child.userDetails.levelId) {
      return NextResponse.json({
        success: true,
        data: {
          subjects: [],
        },
      });
    }

    const childLevelId = child.userDetails.levelId;

    // Get all subjects for this level
    const subjects = child.userDetails.level.subjects;

    // Get all teachers linked to this student
    const teacherLinks = await prisma.teacherStudentLink.findMany({
      where: {
        studentId: childId,
      },
      include: {
        teacher: {
          include: {
            userDetails: true,
          },
        },
      },
    });

    // For each subject, get teacher info and stats
    const subjectsWithDetails = await Promise.all(
      subjects.map(async (subject) => {
        // Find teacher for this subject from linked teachers
        const teacherLink = teacherLinks.find(
          (link) => link.teacher.userDetails?.subjectId === subject.id
        );
        const teacher = teacherLink?.teacher || null;

        // Get teacher's lessons for this subject and level
        const lessons = teacher
          ? await prisma.lesson.findMany({
              where: {
                authorId: teacher.id,
                subjectId: subject.id,
                levelId: childLevelId, // Filter by child's level
              },
              select: {
                id: true,
              },
            })
          : [];

        const lessonIds = lessons.map((l) => l.id);

        // Get exercises for these lessons
        const exercises = lessonIds.length
          ? await prisma.exercise.findMany({
              where: {
                lessonId: { in: lessonIds },
              },
              select: {
                id: true,
              },
            })
          : [];

        const exerciseIds = exercises.map((e) => e.id);

        // Get submissions for this child in these exercises
        const submissions = exerciseIds.length
          ? await prisma.submission.findMany({
              where: {
                studentId: childId,
                exerciseId: { in: exerciseIds },
              },
              select: {
                id: true,
                finalScore: true,
                aiScore: true,
                status: true,
              },
            })
          : [];

        // Calculate stats
        const gradedSubmissions = submissions.filter((s) => s.status === "graded");
        let totalScore = 0;
        gradedSubmissions.forEach((sub) => {
          totalScore += Number(sub.finalScore || sub.aiScore || 0);
        });

        const averageScore =
          gradedSubmissions.length > 0
            ? Math.round(totalScore / gradedSubmissions.length)
            : 0;

        return {
          id: subject.id,
          name: subject.name,
          teacher: teacher
            ? {
                id: teacher.id,
                firstName: teacher.firstName,
                lastName: teacher.lastName,
                allowMessaging: (teacher.userDetails as any)?.allowMessaging || false,
              }
            : null,
          stats: {
            totalLessons: lessons.length,
            totalExercises: exercises.length,
            totalSubmissions: submissions.length,
            gradedSubmissions: gradedSubmissions.length,
            averageScore,
          },
        };
      })
    );

    return NextResponse.json({
      success: true,
      data: {
        child: {
          id: child.id,
          firstName: child.firstName,
          lastName: child.lastName,
        },
        subjects: subjectsWithDetails,
      },
    });
  } catch (error) {
    console.error("Error fetching child subjects:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch subjects" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/parents/children/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const parentId = session.user.id;

    // Get linked children with their details
    const parentChildLinks = await prisma.parentChildLink.findMany({
      where: { parentId },
      include: {
        child: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            image: true,
            userDetails: {
              select: {
                level: {
                  select: {
                    id: true,
                    name: true,
                    stage: {
                      select: {
                        id: true,
                        name: true,
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    // Get statistics for each child
    const childrenWithStats = await Promise.all(
      parentChildLinks.map(async (link) => {
        const childId = link.child.id;

        // Get all submissions for this child
        const submissions = await prisma.submission.findMany({
          where: {
            studentId: childId,
            status: 'graded',
          },
          select: {
            id: true,
            finalScore: true,
            aiScore: true,
            exerciseId: true,
          },
        });

        // Count completed lessons (unique exercises)
        const uniqueExercises = new Set(submissions.map(s => s.exerciseId));
        const completedLessons = uniqueExercises.size;

        // Calculate average score
        let totalScore = 0;
        submissions.forEach((sub) => {
          totalScore += Number(sub.finalScore || sub.aiScore || 0);
        });
        const averageScore = submissions.length > 0 
          ? Math.round((totalScore / submissions.length)) 
          : 0;

        return {
          id: link.child.id,
          firstName: link.child.firstName,
          lastName: link.child.lastName,
          email: link.child.email,
          image: link.child.image,
          level: link.child.userDetails?.level || null,
          stats: {
            completedLessons,
            averageScore,
            submissionCount: submissions.length,
          },
        };
      })
    );

    return NextResponse.json({
      success: true,
      data: {
        children: childrenWithStats,
      },
    });
  } catch (error) {
    console.error("Error fetching children:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch children" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/parents/dashboard/route.ts
// ==========================================

import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";


import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session || !session.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    const parentId = session.user.id;

    console.log('Parent Dashboard - Session User:', session.user);
    console.log('Parent ID:', parentId);

    // Get parent details
    const parent = await prisma.user.findUnique({
      where: { id: parentId },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        role: {
          select: {
            name: true,
          },
        },
        userDetails: {
          select: {
            parentCode: true,
          },
        },
      },
    });

    console.log('Found parent:', parent);

    if (!parent) {
      console.log('Parent not found for ID:', parentId);
      return NextResponse.json(
        { success: false, error: "Parent not found" },
        { status: 404 }
      );
    }

    // Get linked children
    const parentChildLinks = await prisma.parentChildLink.findMany({
      where: { parentId },
      select: {
        child: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            userDetails: {
              select: {
                level: {
                  select: {
                    id: true,
                    name: true,
                    stage: {
                      select: {
                        id: true,
                        name: true,
                      },
                    },
                  },
                },
              },
            },
          },
        },
      },
    });

    const children = parentChildLinks.map((link) => ({
      id: link.child.id,
      firstName: link.child.firstName,
      lastName: link.child.lastName,
      email: link.child.email,
      level: link.child.userDetails?.level || null,
    }));

    // Get all submissions for all children
    const childrenIds = children.map((c) => c.id);
    
    const allSubmissions = await prisma.submission.findMany({
      where: {
        studentId: { in: childrenIds },
        status: 'graded', // Only count graded submissions
      },
      select: {
        finalScore: true,
        aiScore: true,
      },
    });

    // Calculate statistics
    const totalSubmissions = allSubmissions.length;
    
    // Calculate average score with proper percentage calculation
    let totalScore = 0;
    let totalMaxScore = 0;
    
    // Get max scores for each submission
    const submissionsWithExercises = await prisma.submission.findMany({
      where: {
        studentId: { in: childrenIds },
        status: 'graded',
      },
      select: {
        finalScore: true,
        aiScore: true,
        exercise: {
          select: {
            maxScore: true,
          },
        },
      },
    });
    
    submissionsWithExercises.forEach((sub) => {
      const score = Number(sub.finalScore || sub.aiScore || 0);
      const maxScore = Number(sub.exercise.maxScore || 20);
      totalScore += score;
      totalMaxScore += maxScore;
    });
    
    // Calculate percentage properly
    const averageScore =
      totalMaxScore > 0 ? Math.round((totalScore / totalMaxScore) * 100) : 0;

    // Get unread messages count
    const unreadMessages = await prisma.message.count({
      where: {
        recipientId: parentId,
        isRead: false,
      },
    });

    return NextResponse.json({
      success: true,
      data: {
        parent: {
          id: parent.id,
          firstName: parent.firstName,
          lastName: parent.lastName,
          email: parent.email,
          parentCode: parent.userDetails?.parentCode || null,
        },
        children,
        stats: {
          totalChildren: children.length,
          totalSubmissions,
          averageScore,
          unreadMessages,
        },
      },
    });
  } catch (error) {
    console.error("Error fetching parent dashboard:", error);
    return NextResponse.json(
      { success: false, error: "Failed to fetch parent dashboard" },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/backup/import/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/logger';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as path from 'path';

const execAsync = promisify(exec);

/**
 * Restore database from backup
 * POST /api/backup/import
 * Only accessible by Director role
 */
export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    // Check if user is Director
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { role: true }
    });

    if (user?.role.name !== 'directeur') {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - Ù…Ø®ØµØµ Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·' }, { status: 403 });
    }

    const { backupId } = await req.json();

    if (!backupId) {
      return NextResponse.json({ error: 'Ù…Ø¹Ø±Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…Ø·Ù„ÙˆØ¨' }, { status: 400 });
    }

    // Get backup details
    const backup = await prisma.backup.findUnique({
      where: { id: backupId }
    });

    if (!backup) {
      return NextResponse.json({ error: 'Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©' }, { status: 404 });
    }

    await logger.backup.started(session.user.id, 'IMPORT');

    // Get database connection details
    let dbConfig;
    try {
      const url = new URL(process.env.DATABASE_URL || '');
      dbConfig = {
        user: url.username,
        password: url.password,
        host: url.hostname,
        port: url.port,
        database: url.pathname.substring(1),
      };
    } catch (e) {
      throw new Error('Invalid DATABASE_URL');
    }

    const absolutePath = path.join(process.cwd(), 'backups', backup.filename);

    // Execute mysql import
    const importCommand = `mysql -h "${dbConfig.host}" -P "${dbConfig.port}" -u "${dbConfig.user}" "${dbConfig.database}" < "${absolutePath}"`;
    
    await execAsync(importCommand, {
      env: { ...process.env, MYSQL_PWD: dbConfig.password }
    });

    await logger.backup.restored(session.user.id, backup.filename);

    return NextResponse.json({
      success: true,
      message: 'ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
      backup: {
        filename: backup.filename,
        restoredAt: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('Backup import error:', error);
    
    const session = await getServerSession(authOptions);
    if (session?.user) {
      await logger.backup.failed(session.user.id, error);
    }

    return NextResponse.json(
      { 
        error: 'ÙØ´Ù„ ÙÙŠ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©',
        details: error.message 
      },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/backup/[id]/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Download a backup file
 * GET /api/backup/[id]
 * Only accessible by Director role
 */
export async function GET(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    // Check if user is Director
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { role: true }
    });

    if (user?.role.name !== 'directeur') {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - Ù…Ø®ØµØµ Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·' }, { status: 403 });
    }

    const backupId = params.id;

    const backup = await prisma.backup.findUnique({
      where: { id: backupId }
    });

    if (!backup) {
      return NextResponse.json({ error: 'Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©' }, { status: 404 });
    }

    const absolutePath = path.join(process.cwd(), 'backups', backup.filename);

    try {
      const fileBuffer = await fs.readFile(absolutePath);
      
      return new NextResponse(fileBuffer, {
        headers: {
          'Content-Disposition': `attachment; filename="${backup.filename}"`,
          'Content-Type': 'application/sql',
          'Content-Length': fileBuffer.length.toString(),
        },
      });
    } catch (error) {
      return NextResponse.json({ error: 'Ù…Ù„Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±' }, { status: 404 });
    }

  } catch (error: any) {
    console.error('Backup download error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©' },
      { status: 500 }
    );
  }
}

/**
 * Delete a backup file
 * DELETE /api/backup/[id]
 * Only accessible by Director role
 */
export async function DELETE(
  req: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    // Check if user is Director
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { role: true }
    });

    if (user?.role.name !== 'directeur') {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - Ù…Ø®ØµØµ Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·' }, { status: 403 });
    }

    const backupId = params.id;

    // Get backup details
    const backup = await prisma.backup.findUnique({
      where: { id: backupId }
    });

    if (!backup) {
      return NextResponse.json({ error: 'Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©' }, { status: 404 });
    }

    // Delete file from disk
    try {
      // Construct absolute path from the stored web path
      const absolutePath = path.join(process.cwd(), 'backups', backup.filename);
      await fs.unlink(absolutePath);
    } catch (error) {
      console.warn('File already deleted or not found');
    }

    // Delete from database
    await prisma.backup.delete({
      where: { id: backupId }
    });

    return NextResponse.json({
      success: true,
      message: 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­'
    });

  } catch (error: any) {
    console.error('Backup delete error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©' },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/backup/export/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { logger } from '@/lib/logger';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';

const execAsync = promisify(exec);

/**
 * Export database backup
 * POST /api/backup/export
 * Only accessible by Director role
 */
export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    // Check if user is Director
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { role: true }
    });

    if (user?.role.name !== 'directeur') {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - Ù…Ø®ØµØµ Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·' }, { status: 403 });
    }

    await logger.backup.started(session.user.id, 'EXPORT');

    // 1. Check if mysqldump is installed
    try {
      await execAsync('mysqldump --version');
    } catch (e) {
      throw new Error('Ø£Ø¯Ø§Ø© mysqldump ØºÙŠØ± Ù…Ø«Ø¨ØªØ© Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ± Ø£Ùˆ ØºÙŠØ± Ù…ØªØ§Ø­Ø© ÙÙŠ Ù…Ø³Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù… (PATH).');
    }

    // Create backups directory if not exists
    const backupsDir = path.join(process.cwd(), 'backups');
    try {
      await fs.access(backupsDir);
    } catch {
      await fs.mkdir(backupsDir, { recursive: true });
    }

    // Generate filename with timestamp
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `smartedu_backup_${timestamp}.sql`;
    const filepath = path.join(backupsDir, filename);

    // Get database connection details from environment
    let dbConfig;
    try {
      const url = new URL(process.env.DATABASE_URL || '');
      dbConfig = {
        user: url.username,
        password: url.password,
        // 2. Force TCP connection by using 127.0.0.1 instead of localhost
        host: url.hostname === 'localhost' ? '127.0.0.1' : url.hostname,
        port: url.port || '3306',
        database: url.pathname.substring(1),
      };
    } catch (e) {
      throw new Error('Invalid DATABASE_URL');
    }

    // Execute mysqldump
    // Added --column-statistics=0 which is often needed for compatibility between different MySQL versions
    const dumpCommand = `mysqldump -h "${dbConfig.host}" -P "${dbConfig.port}" -u "${dbConfig.user}" --single-transaction --quick --lock-tables=false "${dbConfig.database}" > "${filepath}"`;
    
    // 3. Capture stderr to see warnings/errors
    const { stderr } = await execAsync(dumpCommand, {
      env: { ...process.env, MYSQL_PWD: dbConfig.password },
      // Increase buffer size for large outputs if needed
      maxBuffer: 1024 * 1024 * 10 // 10MB
    }).catch((err) => {
       throw new Error(`ÙØ´Ù„ ØªÙ†ÙÙŠØ° mysqldump: ${err.message}`);
    });

    // Get file size
    const stats = await fs.stat(filepath);

    if (stats.size === 0) {
      await fs.unlink(filepath);
      // Return the actual error from stderr
      throw new Error(`ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© (Ù…Ù„Ù ÙØ§Ø±Øº). ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø®Ø·Ø£: ${stderr || 'ØªØ£ÙƒØ¯ Ù…Ù† ØµÙ„Ø§Ø­ÙŠØ§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.'}`);
    }

    const sizeInMB = (stats.size / (1024 * 1024)).toFixed(2);

    // Save backup record to database
    const backup = await prisma.backup.create({
      data: {
        filename,
        filepath: `backups/${filename}`, // Store relative path
        size: stats.size,
        type: 'FULL',
        status: 'COMPLETED',
        createdById: session.user.id
      }
    });

    await logger.backup.completed(session.user.id, filename, stats.size);

    return NextResponse.json({
      success: true,
      message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
      backup: {
        id: backup.id,
        filename,
        filepath: `backups/${filename}`,
        size: `${sizeInMB} MB`,
        timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('Backup export error:', error);
    
    const session = await getServerSession(authOptions);
    if (session?.user) {
      await logger.backup.failed(session.user.id, error);
    }

    return NextResponse.json(
      { 
        error: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©',
        details: error.message 
      },
      { status: 500 }
    );
  }
}

/**
 * List all backups
 * GET /api/backup/export
 */
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);

    if (!session?.user) {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­' }, { status: 401 });
    }

    // Check if user is Director
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      include: { role: true }
    });

    if (user?.role.name !== 'directeur') {
      return NextResponse.json({ error: 'ØºÙŠØ± Ù…ØµØ±Ø­ - Ù…Ø®ØµØµ Ù„Ù„Ù…Ø¯ÙŠØ± ÙÙ‚Ø·' }, { status: 403 });
    }

    const backups = await prisma.backup.findMany({
      orderBy: { createdAt: 'desc' },
      include: {
        createdBy: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });

    // Convert size to MB
    const backupsWithSize = backups.map(backup => ({
      ...backup,
      size: Number(backup.size), // Fix: Convert BigInt to Number explicitly to avoid JSON serialization error
      sizeInMB: (Number(backup.size) / (1024 * 1024)).toFixed(2)
    }));

    return NextResponse.json({ backups: backupsWithSize });

  } catch (error: any) {
    console.error('Backup list error:', error);
    return NextResponse.json(
      { error: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©' },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/stages/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';
import { GoogleDriveService } from '@/lib/google-drive';

// GET /api/stages
export async function GET() {
  try {
    // No auth required for signup page
    const stages = await prisma.stage.findMany({
      orderBy: { displayOrder: 'asc' },
      include: {
        _count: {
          select: {
            levels: true,
            subjects: true,
          },
        },
      },
    });

    return successResponse(stages, `ØªÙ… Ø¬Ù„Ø¨ ${stages.length} Ù…Ø±Ø­Ù„Ø©`);
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø±Ø§Ø­Ù„', 500);
  }
}

// POST /api/stages
export async function POST(request: NextRequest) {
  let stageId: number | undefined;
  try {
    const session = await requireAuth();
    if (session.user.role !== 'directeur') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø±Ø§Ø­Ù„', 403);
    }

    const body = await request.json();
    const { name, displayOrder } = body;

    if (!name) {
      return errorResponse('Ø§Ø³Ù… Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ù…Ø·Ù„ÙˆØ¨', 400);
    }
    
    const rootFolderId = process.env.GOOGLE_DRIVE_ROOT_FOLDER_ID;
    if (!rootFolderId) {
        return errorResponse('Ù„Ù… ÙŠØªÙ… ØªÙƒÙˆÙŠÙ† Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø¬Ø°Ø± Ù„Ù€ Google Drive', 500);
    }

    // --- Step 1: Create the stage record in the database ---
    let order = displayOrder;
    if (!order) {
      const lastStage = await prisma.stage.findFirst({
        orderBy: { displayOrder: 'desc' },
      });
      order = lastStage ? lastStage.displayOrder + 1 : 1;
    }

    const newStage = await prisma.stage.create({
      data: {
        name,
        displayOrder: order,
      },
    });
    stageId = newStage.id; // Store ID for potential rollback

    // --- Step 2: Create the corresponding folder in Google Drive ---
    const driveFolderId = await GoogleDriveService.getOrCreateFolder(name, rootFolderId);

    // --- Step 3: Update the stage record with the Drive Folder ID ---
    const updatedStage = await prisma.stage.update({
      where: { id: stageId },
      data: { driveFolderId: driveFolderId },
    });

    return successResponse(updatedStage, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø­Ù„Ø© ÙˆØ§Ù„Ù…Ø¬Ù„Ø¯ Ø¨Ù†Ø¬Ø§Ø­', 201);
  } catch (error: any) {
    // --- Rollback Logic ---
    // If an error occurs after the stage was created in the DB, delete it.
    if (stageId) {
      await prisma.stage.delete({ where: { id: stageId } }).catch(rollbackError => {
        // Log the rollback error, but don't overshadow the original error
        console.error('Rollback failed for stage deletion:', rollbackError);
      });
    }
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©', 500);
  }
}

/**
 * Delete an academic stage
 * DELETE /api/stages?id=<stageId>
 * Only accessible by Director
 */
export async function DELETE(request: NextRequest) {
    try {
        const session = await requireAuth();
        if (session.user.role !== 'directeur') {
            return errorResponse('ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø­Ø°Ù Ø§Ù„Ù…Ø±Ø§Ø­Ù„', 403);
        }

        const { searchParams } = new URL(request.url);
        const stageId = searchParams.get('id');

        if (!stageId) {
            return errorResponse('Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ù…Ø·Ù„ÙˆØ¨', 400);
        }

        const stageToDelete = await prisma.stage.findUnique({
            where: { id: parseInt(stageId) },
        });

        if (!stageToDelete) {
            return errorResponse('Ø§Ù„Ù…Ø±Ø­Ù„Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©', 404);
        }

        // 1. Delete associated Google Drive folder if exists
        if (stageToDelete.driveFolderId) {
            try {
                await GoogleDriveService.deleteFolder(stageToDelete.driveFolderId);
            } catch (gdError: any) {
                console.error(`Failed to delete Google Drive folder for stage ${stageId}:`, gdError);
                // Depending on requirements, you might want to return an error here or proceed with DB deletion
                // For now, we will log and proceed to delete from DB to maintain data integrity within the app
            }
        }

        // 2. Delete the stage from the database
        await prisma.stage.delete({
            where: { id: parseInt(stageId) },
        });

        return successResponse(null, 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø±Ø­Ù„Ø© ÙˆØ§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø±ØªØ¨Ø· Ø¨Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (error: any) {
        console.error('Academic stage deletion error:', error);
        return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø±Ø­Ù„Ø©', 500);
    }
}



// ==========================================
// FILE: src/app/api/exercises/[id]/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

const prisma = new PrismaClient();

// GET /api/exercises/[id] - Get single exercise
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const resolvedParams = await params;
    const exerciseId = parseInt(resolvedParams.id);

    if (isNaN(exerciseId)) {
      return NextResponse.json(
        { success: false, error: 'Invalid exercise ID' },
        { status: 400 }
      );
    }

    const exercise = await prisma.exercise.findUnique({
      where: { id: exerciseId },
      include: {
        lesson: {
          select: {
            id: true,
            title: true,
            authorId: true,
          },
        },
      },
    });

    if (!exercise) {
      return NextResponse.json(
        { success: false, error: 'Exercise not found' },
        { status: 404 }
      );
    }

    // Check if user has access (is the author or admin)
    if (exercise.lesson.authorId !== session.user.id && session.user.role !== 'directeur') {
      return NextResponse.json(
        { success: false, error: 'Forbidden' },
        { status: 403 }
      );
    }

    // Convert Decimal fields to numbers
    const exerciseData = {
      ...exercise,
      maxScore: exercise.maxScore ? parseFloat(exercise.maxScore.toString()) : null,
      lessonId: exercise.lessonId,
      question: exercise.question || exercise.questionRichContent || '',
      modelAnswer: exercise.modelAnswer || '',
      questionFileUrl: exercise.questionFileUrl || '',
    };

    return NextResponse.json({
      success: true,
      data: exerciseData,
    });
  } catch (error) {
    console.error('Error fetching exercise:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// PUT /api/exercises/[id] - Update exercise
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const resolvedParams = await params;
    const exerciseId = parseInt(resolvedParams.id);

    if (isNaN(exerciseId)) {
      return NextResponse.json(
        { success: false, error: 'Invalid exercise ID' },
        { status: 400 }
      );
    }

    // Check if exercise exists and user has access
    const existingExercise = await prisma.exercise.findUnique({
      where: { id: exerciseId },
      include: {
        lesson: {
          select: { authorId: true },
        },
      },
    });

    if (!existingExercise) {
      return NextResponse.json(
        { success: false, error: 'Exercise not found' },
        { status: 404 }
      );
    }

    if (existingExercise.lesson.authorId !== session.user.id && session.user.role !== 'directeur') {
      return NextResponse.json(
        { success: false, error: 'Forbidden' },
        { status: 403 }
      );
    }

    const body = await request.json();
    const {
      lessonId,
      type,
      question,
      questionRichContent,
      modelAnswer,
      modelAnswerImage,
      expectedResults,
      maxScore,
      allowRetry,
      maxAttempts,
      questionFileUrl,
    } = body;

    // Build update data dynamically
    const updateData: any = {
      updatedAt: new Date(),
    };

    if (lessonId !== undefined) updateData.lessonId = lessonId;
    if (type !== undefined) updateData.type = type;
    if (question !== undefined) updateData.question = question;
    if (questionRichContent !== undefined) updateData.questionRichContent = questionRichContent;
    if (questionFileUrl !== undefined) updateData.questionFileUrl = questionFileUrl;

    // Type-specific fields
    if (type === 'main' || existingExercise.type === 'main') {
      if (modelAnswer !== undefined) updateData.modelAnswer = modelAnswer;
      if (modelAnswerImage !== undefined) updateData.modelAnswerImage = modelAnswerImage;
      if (maxScore !== undefined) updateData.maxScore = maxScore;
      if (allowRetry !== undefined) updateData.allowRetry = allowRetry;
      if (maxAttempts !== undefined) updateData.maxAttempts = maxAttempts;
    }

    if (type === 'support_with_results' || existingExercise.type === 'support_with_results') {
      if (expectedResults !== undefined) updateData.expectedResults = expectedResults;
    }

    const updatedExercise = await prisma.exercise.update({
      where: { id: exerciseId },
      data: updateData,
      include: {
        lesson: {
          select: {
            id: true,
            title: true,
          },
        },
      },
    });

    // Convert Decimal to number
    const exerciseData = {
      ...updatedExercise,
      maxScore: updatedExercise.maxScore ? parseFloat(updatedExercise.maxScore.toString()) : null,
    };

    return NextResponse.json({
      success: true,
      exercise: exerciseData,
    });
  } catch (error) {
    console.error('Error updating exercise:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// DELETE /api/exercises/[id] - Delete exercise
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const resolvedParams = await params;
    const exerciseId = parseInt(resolvedParams.id);

    if (isNaN(exerciseId)) {
      return NextResponse.json(
        { success: false, error: 'Invalid exercise ID' },
        { status: 400 }
      );
    }

    // Check if exercise exists and user has access
    const existingExercise = await prisma.exercise.findUnique({
      where: { id: exerciseId },
      select: { googleDriveFolderId: true, lesson: { select: { authorId: true } } }, // Select googleDriveFolderId and authorId from lesson
    });

    if (!existingExercise) {
      return NextResponse.json(
        { success: false, error: 'Exercise not found' },
        { status: 404 }
      );
    }

    if (existingExercise.lesson.authorId !== session.user.id && session.user.role !== 'directeur') {
      return NextResponse.json(
        { success: false, error: 'Forbidden' },
        { status: 403 }
      );
    }

    // 1. Delete associated Google Drive folder if exists
    if (existingExercise.googleDriveFolderId) {
      try {
        await GoogleDriveService.deleteFolder(existingExercise.googleDriveFolderId);
      } catch (gdError) {
        console.error(`Failed to delete Google Drive folder for exercise ${exerciseId}:`, gdError);
        // Log and proceed to delete from DB to maintain data integrity within the app
      }
    }

    // Delete all submissions first
    await prisma.submission.deleteMany({
      where: { exerciseId: exerciseId },
    });

    // Delete exercise
    await prisma.exercise.delete({
      where: { id: exerciseId },
    });

    return NextResponse.json({
      success: true,
      message: 'Exercise deleted successfully',
    });
  } catch (error) {
    console.error('Error deleting exercise:', error);
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    );
  }
}


// ==========================================
// FILE: src/app/api/exercises/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';
import { GoogleDriveService } from '@/lib/google-drive';
import { log, LogLevel, LogCategory } from '@/lib/logger';

/**
 * Handles the creation of a Google Drive folder for a new exercise.
 * Path: /<LESSON_FOLDER>/Exercise <EXERCISE_ID>
 * @param exercise - The newly created exercise object, with its parent lesson included.
 */
async function handleExerciseFolderCreation(exercise: any) {
  if (!exercise.lesson?.driveFolderId) {
    await log({
      level: LogLevel.WARNING,
      category: LogCategory.DRIVE,
      action: 'EXERCISE_DRIVE_SETUP_SKIPPED',
      details: `Skipping Drive folder creation for exercise ${exercise.id} because parent lesson ${exercise.lessonId} has no Drive folder.`,
    });
    return;
  }

  try {
    const lessonFolderId = exercise.lesson.driveFolderId;
    const exerciseFolderName = `Exercise ${exercise.id}`;

    await log({
      level: LogLevel.INFO,
      category: LogCategory.DRIVE,
      action: 'EXERCISE_DRIVE_SETUP_START',
      details: `Starting Drive folder setup for exercise "${exerciseFolderName}" (ID: ${exercise.id}).`,
    });

    // 1. Get or create the Exercise folder inside the parent Lesson folder
    const exerciseFolderId = await GoogleDriveService.getOrCreateFolder(exerciseFolderName, lessonFolderId);

    // 2. Update the exercise record with the new folder ID
    await prisma.exercise.update({
      where: { id: exercise.id },
      data: { driveFolderId: exerciseFolderId },
    });

    await log({
      level: LogLevel.SUCCESS,
      category: LogCategory.DRIVE,
      action: 'EXERCISE_DRIVE_SETUP_SUCCESS',
      details: `Successfully created Drive folder for exercise ${exercise.id}. Folder ID: ${exerciseFolderId}`,
    });
  } catch (error: any) {
    await log({
      level: LogLevel.ERROR,
      category: LogCategory.DRIVE,
      action: 'EXERCISE_DRIVE_SETUP_FAILED',
      details: {
        message: `Failed to create Google Drive folder for exercise ${exercise.id}.`,
        error: error.message,
      },
    });
  }
}

// GET /api/exercises?lessonId=1&authorId=xxx
export async function GET(request: NextRequest) {
  try {
    await requireAuth();

    const { searchParams } = new URL(request.url);
    const lessonId = searchParams.get('lessonId');
    const authorId = searchParams.get('authorId');

    const where: any = {};
    if (lessonId) {
      where.lessonId = parseInt(lessonId);
    }
    
    // ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ù…Ø¤Ù„Ù Ø§Ù„Ø¯Ø±ÙˆØ³
    if (authorId) {
      where.lesson = {
        authorId: authorId,
      };
    }

    const exercises = await prisma.exercise.findMany({
      where,
      orderBy: { displayOrder: 'asc' },
      include: {
        lesson: {
          select: {
            id: true,
            title: true,
          },
        },
      },
    });

    return successResponse({ exercises });
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†', 500);
  }
}

// POST /api/exercises
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth();

    // ÙÙ‚Ø· Ø§Ù„Ù…Ø¹Ù„Ù…ÙˆÙ† ÙˆØ§Ù„Ù…Ø´Ø±ÙÙˆÙ† ÙˆØ§Ù„Ù…Ø¯ÙŠØ±
    if (!['teacher', 'supervisor_specific', 'supervisor_general', 'directeur'].includes(session.user.role)) {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†', 403);
    }

    const body = await request.json();
    console.log('ğŸ“¥ Received exercise data:', JSON.stringify(body, null, 2));
    
    const { 
      lessonId, 
      type = 'main',
      questionRichContent,
      question, 
      questionFileIds, 
      modelAnswer,
      modelAnswerFileIds,
      expectedResults,
      maxScore = 20,
      allowRetry = true,
      maxAttempts = 3,
      displayOrder 
    } = body;

    if (!lessonId || (!questionRichContent && !question)) {
      return errorResponse('Ù…Ø¹Ø±Ù Ø§Ù„Ø¯Ø±Ø³ ÙˆØ§Ù„Ø³Ø¤Ø§Ù„ Ù…Ø·Ù„ÙˆØ¨Ø§Ù†', 400);
    }

    if (type === 'main' && !modelAnswer) {
      return errorResponse('Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ Ù…Ø·Ù„ÙˆØ¨ Ù„Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ', 400);
    }

    if (type === 'support_with_results' && (!expectedResults || expectedResults.length === 0)) {
      return errorResponse('Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© Ù…Ø·Ù„ÙˆØ¨Ø© Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø¯Ø¹Ù… + Ù†ØªØ§Ø¦Ø¬', 400);
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ù„ÙƒÙŠØ© Ø§Ù„Ø¯Ø±Ø³
    const lesson = await prisma.lesson.findUnique({
      where: { id: parseInt(lessonId) },
    });

    if (!lesson) {
      return errorResponse('Ø§Ù„Ø¯Ø±Ø³ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯', 404);
    }

    if (lesson.authorId !== session.user.id && session.user.role !== 'directeur') {
      return errorResponse('ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø¥Ø¶Ø§ÙØ© ØªÙ…Ø§Ø±ÙŠÙ† Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¯Ø±Ø³', 403);
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¢Ø®Ø± displayOrder
    let order = displayOrder;
    if (!order) {
      const lastExercise = await prisma.exercise.findFirst({
        where: { lessonId: parseInt(lessonId) },
        orderBy: { displayOrder: 'desc' },
      });
      order = lastExercise ? lastExercise.displayOrder + 1 : 1;
    }

    const exerciseData: any = {
      lessonId: parseInt(lessonId),
      type,
      question: question || null,
      questionRichContent: questionRichContent || null,
      questionFileIds: questionFileIds || [],
      displayOrder: order,
    };

    // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„ØªÙ…Ø±ÙŠÙ†
    if (type === 'main') {
      exerciseData.modelAnswer = modelAnswer;
      exerciseData.modelAnswerFileIds = modelAnswerFileIds || [];
      exerciseData.maxScore = parseFloat(String(maxScore));
      exerciseData.allowRetry = allowRetry;
      exerciseData.maxAttempts = parseInt(String(maxAttempts));
    } else if (type === 'support_with_results') {
      exerciseData.expectedResults = expectedResults;
    }

    console.log('ğŸ’¾ Creating exercise with data:', JSON.stringify(exerciseData, null, 2));

    const exercise = await prisma.exercise.create({
      data: exerciseData,
      include: {
        lesson: true, // Include the full lesson to get its driveFolderId
      },
    });

    // Fire-and-forget Google Drive folder creation
    handleExerciseFolderCreation(exercise);

    return successResponse(exercise, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­', 201);
  } catch (error: any) {
    console.error('Error creating exercise:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø±ÙŠÙ†', 500);
  }
}


// ==========================================
// FILE: src/app/api/subjects/[id]/route.ts
// ==========================================

import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse, notFoundResponse } from '@/lib/api-response';
import { GoogleDriveService } from '@/lib/google-drive'; // Import GoogleDriveService

// GET /api/subjects/[id]
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    await requireAuth();

    const subjectId = parseInt(params.id);

    const subject = await prisma.subject.findUnique({
      where: { id: subjectId },
      include: {
        levels: true, // ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù‡Ø°Ø§ Ø§Ù„Ø³Ø·Ø±
        stage: true,
      },
    });

    if (!subject) {
      return notFoundResponse('Ø§Ù„Ù…Ø§Ø¯Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    return successResponse(subject);
  } catch (error: any) {
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø§Ø¯Ø©', 500);
  }
}

// PUT /api/subjects/[id]
export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await requireAuth();
    if (session.user.role !== 'directeur') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…ÙˆØ§Ø¯', 403);
    }

    const subjectId = parseInt(params.id);
    const body = await request.json();
    const { name, description, stageId, levelIds } = body; // ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ levelIds

    // Basic validation
    if (!name) {
      return errorResponse('Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø© Ù…Ø·Ù„ÙˆØ¨', 400);
    }

    // Prepare data for Prisma update
    const dataToUpdate: any = {
      name,
      description,
    };

    // Handle stage relationship
    if (stageId) {
      dataToUpdate.stage = { connect: { id: stageId } };
    } else {
      // If stageId is not provided, disconnect any existing stage
      dataToUpdate.stage = { disconnect: true };
    }

    // Handle many-to-many relationship with levels
    if (Array.isArray(levelIds)) {
      dataToUpdate.levels = {
        set: levelIds.map((id: number) => ({ id: Number(id) })),
      };
    }

    const updatedSubject = await prisma.subject.update({
      where: { id: subjectId },
      data: dataToUpdate,
      include: { stage: true, levels: true }, // ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
    });

    return successResponse({ subject: updatedSubject }, 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­');

  } catch (error: any) {
    console.error('Subject update error:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø§Ø¯Ø©', 500);
  }
}
// DELETE /api/subjects/[id]
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await requireAuth();
    if (session.user.role !== 'directeur') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø­Ø°Ù Ø§Ù„Ù…ÙˆØ§Ø¯', 403);
    }

    const subjectId = parseInt(params.id);

    const subjectToDelete = await prisma.subject.findUnique({
      where: { id: subjectId },
    });

    if (!subjectToDelete) {
      return notFoundResponse('Ø§Ù„Ù…Ø§Ø¯Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
    }

    // 1. Delete associated Google Drive folder if exists
    if (subjectToDelete.driveFolderId) {
      try {
        await GoogleDriveService.deleteFolder(subjectToDelete.driveFolderId);
      } catch (gdError: any) {
        console.error(`Failed to delete Google Drive folder for subject ${subjectId}:`, gdError);
        // Log and proceed to delete from DB to maintain data integrity within the app
      }
    }

    // 2. Delete the subject from the database
    await prisma.subject.delete({
      where: { id: subjectId },
    });

    return successResponse(null, 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø§Ø¯Ø© ÙˆØ§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ù…Ø±ØªØ¨Ø· Ø¨Ù‡Ø§ Ø¨Ù†Ø¬Ø§Ø­');
  } catch (error: any) {
    console.error('Subject deletion error:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø§Ø¯Ø©', 500);
  }
}


// ==========================================
// FILE: src/app/api/subjects/route.ts
// ==========================================

import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth } from '@/lib/api-auth';
import { successResponse, errorResponse } from '@/lib/api-response';
import { GoogleDriveService, getRootFolderId } from '@/lib/google-drive';

export const dynamic = 'force-dynamic';

// GET /api/subjects?levelId=1&stageId=1
export async function GET(request: NextRequest) {
  try {
    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù„Ø³Ø©ØŒ Ù„ÙƒÙ† Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø·Ù„Ø¨ Ø¥Ø°Ø§ ÙØ´Ù„Øª (Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨ØµÙØ­Ø© Ø§Ù„ØªØ³Ø¬ÙŠÙ„)
    let session = null;
    try {
      session = await requireAuth();
    } catch (e) {
      // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„ØŒ Ù†Ø³ØªÙ…Ø± ÙƒØ²Ø§Ø¦Ø±
    }

    const { searchParams } = new URL(request.url);
    const mode = searchParams.get('mode');
    console.log(`[API Subjects] Request Params: ${JSON.stringify(Object.fromEntries(searchParams))}`);

    const where: any = {};
    const userRole = session?.user?.role?.toLowerCase();

    if (userRole === 'student') {
      // For students, ignore query params and fetch subjects for their level
      const userDetails = await prisma.userDetails.findUnique({
        where: { userId: session.user.id },
        select: { levelId: true },
      });

      if (!userDetails?.levelId) {
        // Student has no level assigned, return no subjects
        return successResponse([], 'Ù„Ù… ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ† Ù…Ø³ØªÙˆÙ‰ Ù„Ù„Ø·Ø§Ù„Ø¨');
      }
      where.levels = {
        some: {
          id: userDetails.levelId
        }
      };

    } else {
      // For other roles (admin, etc.), use query params for filtering
      const levelId = searchParams.get('levelId');
      const stageId = searchParams.get('stageId');
      if (levelId) {
        where.levels = {
          some: {
            id: parseInt(levelId)
          }
        };
      }
      if (stageId) {
        where.stageId = parseInt(stageId);
      }
    }

    const subjects = await prisma.subject.findMany({
      where,
      distinct: mode === 'distinct' ? ['name'] : undefined,
      include: {
        levels: true,
        stage: true,
        _count: {
          select: {
            lessons: true,
          },
        },
      },
      orderBy: { id: 'asc' },
    });

    return successResponse(subjects, `ØªÙ… Ø¬Ù„Ø¨ ${subjects.length} Ù…Ø§Ø¯Ø©`);
  } catch (error: any) {
    console.error('Error fetching subjects:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…ÙˆØ§Ø¯', 500);
  }
}

// POST /api/subjects
export async function POST(request: NextRequest) {
  try {
    const session = await requireAuth();

    if (session.user.role !== 'directeur') {
      return errorResponse('ÙÙ‚Ø· Ø§Ù„Ù…Ø¯ÙŠØ± ÙŠÙ…ÙƒÙ†Ù‡ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…ÙˆØ§Ø¯', 403);
    }

    const body = await request.json();
    const { name, description, levelIds, stageId } = body;

    if (!name) {
      return errorResponse('Ø§Ø³Ù… Ø§Ù„Ù…Ø§Ø¯Ø© Ù…Ø·Ù„ÙˆØ¨', 400);
    }

    // Create single subject with connections to multiple levels
    const subject = await prisma.subject.create({
      data: {
        name,
        description: description || null,
        stageId: stageId ? parseInt(stageId) : null,
        levels: {
          connect: Array.isArray(levelIds) 
            ? levelIds.map((id: any) => ({ id: parseInt(id) }))
            : []
        }
      },
      include: {
        levels: true,
        stage: true,
      },
    });

    // --- Google Drive Automation: Create Subject Folders ---
    try {
      // We assume all subjects belong to the same stage (since stageId is passed once)
      if (subject.stage) {
        // 1. Get Root ID
        const rootId = getRootFolderId();
        const stage = subject.stage;

        // 2. Ensure Stage Folder Exists (Once for the batch)
        let stageFolderId = stage.driveFolderId;
        if (!stageFolderId) {
          console.log(`Creating missing Drive folder for Stage: ${stage.name}`);
          stageFolderId = await GoogleDriveService.getOrCreateFolder(stage.name, rootId);
          await prisma.stage.update({
            where: { id: stage.id },
            data: { driveFolderId: stageFolderId },
          });
        }

        // 3. Create Subject Folders inside Stage Folder (Parallel)
        const subjectFolderId = await GoogleDriveService.createFolder(subject.name, stageFolderId!);
        await prisma.subject.update({
          where: { id: subject.id },
          data: { driveFolderId: subjectFolderId },
        });
      }
    } catch (driveError) {
      console.error('Failed to auto-create Drive folders for Subjects:', driveError);
      // We continue without failing the request, as the DB record is created successfully.
    }
    // ----------------------------------------------------

    return successResponse({ subject }, 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø§Ø¯Ø© Ø¨Ù†Ø¬Ø§Ø­', 201);
  } catch (error: any) {
    console.error('Error creating subject:', error);
    return errorResponse(error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø§Ø¯Ø©', 500);
  }
}


// ==========================================
// FILE: src/components/providers/SessionProvider.tsx
// ==========================================

'use client';

import { SessionProvider } from 'next-auth/react';
import { ReactNode } from 'react';

export function AuthProvider({ children }: { children: ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}


// ==========================================
// FILE: src/components/GeometricDiagramRenderer.tsx
// ==========================================



// ==========================================
// FILE: src/components/MathContent.tsx
// ==========================================

'use client';

import { useEffect, useRef } from 'react';
import katex from 'katex';
import 'katex/dist/katex.min.css';

interface MathContentProps {
  content: string;
  className?: string;
}

/**
 * Ù…ÙƒÙˆÙ† Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ HTML Ù…Ø¹ Ø¯Ø¹Ù… LaTeX/KaTeX
 * ÙŠØ¹Ø§Ù„Ø¬ Ø§Ù„ØµÙŠØº Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙˆÙŠØ¹Ø±Ø¶Ù‡Ø§ Ø¨Ø´ÙƒÙ„ Ø¬Ù…ÙŠÙ„
 */
export default function MathContent({ content, className = '' }: MathContentProps) {
  const contentRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!contentRef.current || !content) return;

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø­ØªÙˆÙ‰
    contentRef.current.innerHTML = content;

    // Ù…Ø¹Ø§Ù„Ø¬Ø© LaTeX inline: \( ... \)
    const processInlineMath = () => {
      if (!contentRef.current) return;
      
      const walker = document.createTreeWalker(
        contentRef.current,
        NodeFilter.SHOW_TEXT,
        null
      );

      const nodesToReplace: { node: Node; matches: RegExpMatchArray[] }[] = [];
      let currentNode: Node | null;

      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†ØµÙˆØµ Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ LaTeX
      while ((currentNode = walker.nextNode())) {
        const text = currentNode.textContent || '';
        const inlineMatches = Array.from(text.matchAll(/\\\((.*?)\\\)/g));
        
        if (inlineMatches.length > 0) {
          nodesToReplace.push({ node: currentNode, matches: inlineMatches });
        }
      }

      // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ LaTeX Ø¨Ù€ KaTeX
      nodesToReplace.forEach(({ node, matches }) => {
        if (!node.parentNode) return;

        const text = node.textContent || '';
        const parts: (string | HTMLElement)[] = [];
        let lastIndex = 0;

        matches.forEach((match) => {
          const fullMatch = match[0];
          const mathContent = match[1];
          const index = match.index || 0;

          // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Øµ Ù‚Ø¨Ù„ Ø§Ù„ØµÙŠØºØ© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
          if (index > lastIndex) {
            parts.push(text.substring(lastIndex, index));
          }

          // Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù†ØµØ± Ù„Ù„ØµÙŠØºØ© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
          const span = document.createElement('span');
          span.className = 'math-inline';
          try {
            katex.render(mathContent, span, {
              throwOnError: false,
              displayMode: false,
            });
            parts.push(span);
          } catch (error) {
            console.error('KaTeX inline error:', error);
            parts.push(fullMatch);
          }

          lastIndex = index + fullMatch.length;
        });

        // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Øµ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ
        if (lastIndex < text.length) {
          parts.push(text.substring(lastIndex));
        }

        // Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø¨Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
        const fragment = document.createDocumentFragment();
        parts.forEach((part) => {
          if (typeof part === 'string') {
            fragment.appendChild(document.createTextNode(part));
          } else {
            fragment.appendChild(part);
          }
        });

        node.parentNode.replaceChild(fragment, node);
      });
    };

    // Ù…Ø¹Ø§Ù„Ø¬Ø© LaTeX block: $$ ... $$
    const processBlockMath = () => {
      if (!contentRef.current) return;
      
      const walker = document.createTreeWalker(
        contentRef.current,
        NodeFilter.SHOW_TEXT,
        null
      );

      const nodesToReplace: { node: Node; matches: RegExpMatchArray[] }[] = [];
      let currentNode: Node | null;

      while ((currentNode = walker.nextNode())) {
        const text = currentNode.textContent || '';
        const blockMatches = Array.from(text.matchAll(/\$\$(.*?)\$\$/g));
        
        if (blockMatches.length > 0) {
          nodesToReplace.push({ node: currentNode, matches: blockMatches });
        }
      }

      nodesToReplace.forEach(({ node, matches }) => {
        if (!node.parentNode) return;

        const text = node.textContent || '';
        const parts: (string | HTMLElement)[] = [];
        let lastIndex = 0;

        matches.forEach((match) => {
          const fullMatch = match[0];
          const mathContent = match[1];
          const index = match.index || 0;

          if (index > lastIndex) {
            parts.push(text.substring(lastIndex, index));
          }

          const div = document.createElement('div');
          div.className = 'math-block text-center my-4';
          try {
            katex.render(mathContent, div, {
              throwOnError: false,
              displayMode: true,
            });
            parts.push(div);
          } catch (error) {
            console.error('KaTeX block error:', error);
            parts.push(fullMatch);
          }

          lastIndex = index + fullMatch.length;
        });

        if (lastIndex < text.length) {
          parts.push(text.substring(lastIndex));
        }

        const fragment = document.createDocumentFragment();
        parts.forEach((part) => {
          if (typeof part === 'string') {
            fragment.appendChild(document.createTextNode(part));
          } else {
            fragment.appendChild(part);
          }
        });

        node.parentNode.replaceChild(fragment, node);
      });
    };

    // ØªÙ†ÙÙŠØ° Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
    processBlockMath();
    processInlineMath();
  }, [content]);

  return (
    <div
      ref={contentRef}
      className={`prose prose-sm max-w-none math-content-rtl ${className}`}
    />
  );
}


// ==========================================
// FILE: src/components/PromotionGuard.tsx
// ==========================================

'use client';

import { useEffect, useState } from 'react';
import { useSession } from 'next-auth/react';
import { usePathname, useRouter } from 'next/navigation';
import PromotionResponse from '@/components/PromotionResponse';
import { Loader2 } from 'lucide-react';

interface PendingPromotion {
  id: string;
  student: {
    id: string;
    firstName: string;
    lastName: string;
  };
  fromLevel: {
    id: number;
    name: string;
  };
  toLevel: {
    id: number;
    name: string;
  } | null;
  messageId: number;
}

export default function PromotionGuard({ children }: { children: React.ReactNode }) {
  const { data: session, status } = useSession();
  const pathname = usePathname();
  const router = useRouter();
  
  const [pendingPromotions, setPendingPromotions] = useState<PendingPromotion[]>([]);
  const [currentPromotionIndex, setCurrentPromotionIndex] = useState(0);
  const [loading, setLoading] = useState(false);
  const [checking, setChecking] = useState(false);

  // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©
  useEffect(() => {
    const fetchPendingPromotions = async () => {
      // Ù„Ø§ ØªÙØ­Øµ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† authenticated
      if (status !== 'authenticated' || !session?.user) {
        return;
      }

      // ÙÙ‚Ø· Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±
      if (session.user.role !== 'parent') {
        return;
      }

      try {
        setLoading(true);
        const response = await fetch('/api/academic-years/promotions/pending');
        
        if (!response.ok) {
          console.error('Failed to fetch promotions:', response.status);
          return;
        }

        const result = await response.json();
        console.log('Pending promotions result:', result);

        if (result.success && result.data && result.data.length > 0) {
          console.log(`Found ${result.data.length} pending promotions`);
          setPendingPromotions(result.data);
        } else {
          console.log('No pending promotions found');
        }
      } catch (error) {
        console.error('Error fetching pending promotions:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchPendingPromotions();
  }, [session, status]);

  // Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ ØªØ±Ù‚ÙŠØ©
  const handlePromotionResponse = () => {
    console.log('Response received, moving to next promotion...');
    
    // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ø§Ø¨Ù† Ø§Ù„ØªØ§Ù„ÙŠ
    if (currentPromotionIndex < pendingPromotions.length - 1) {
      setCurrentPromotionIndex(currentPromotionIndex + 1);
    } else {
      // ØªÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù…ÙŠØ¹
      console.log('All promotions answered!');
      setPendingPromotions([]);
      setCurrentPromotionIndex(0);
    }
  };

  // Loading state - ÙÙ‚Ø· Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙØ­Øµ
  if (loading) {
    return (
      <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[9999]">
        <div className="bg-white p-8 rounded-lg shadow-xl flex flex-col items-center gap-4">
          <Loader2 className="h-12 w-12 animate-spin text-primary" />
          <p className="text-lg">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©...</p>
        </div>
      </div>
    );
  }

  // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‡Ù†Ø§Ùƒ ØªØ±Ù‚ÙŠØ§Øª Ù…Ø¹Ù„Ù‚Ø©
  if (pendingPromotions.length > 0) {
    const currentPromotion = pendingPromotions[currentPromotionIndex];

    return (
      <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-[9999] overflow-y-auto p-4">
        <div className="max-w-4xl w-full my-8">
          {/* Progress indicator */}
          <div className="bg-white rounded-t-lg p-4 text-center">
            <h3 className="text-xl font-bold text-gray-800">
              Ø§Ø³ØªÙØ³Ø§Ø± Ø¹Ù† Ù†ØªØ§Ø¦Ø¬ Ø£Ø¨Ù†Ø§Ø¦Ùƒ
            </h3>
            <p className="text-sm text-gray-600 mt-2">
              Ø§Ù„Ø·Ø§Ù„Ø¨ {currentPromotionIndex + 1} Ù…Ù† {pendingPromotions.length}
            </p>
            <div className="w-full bg-gray-200 rounded-full h-2 mt-3">
              <div
                className="bg-blue-500 h-2 rounded-full transition-all duration-300"
                style={{
                  width: `${((currentPromotionIndex + 1) / pendingPromotions.length) * 100}%`,
                }}
              />
            </div>
          </div>

          {/* Promotion Response Component */}
          <div className="bg-white rounded-b-lg">
            <PromotionResponse
              promotionId={currentPromotion.id}
              messageId={currentPromotion.messageId}
              studentName={`${currentPromotion.student.firstName} ${currentPromotion.student.lastName}`}
              currentLevel={currentPromotion.fromLevel.name}
              nextLevel={currentPromotion.toLevel?.name || 'Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø±Ø­Ù„Ø©'}
              onResponse={handlePromotionResponse}
            />
          </div>

          {/* Cannot close notice */}
          <div className="bg-yellow-50 border-2 border-yellow-300 rounded-lg p-4 mt-4 text-center">
            <p className="text-yellow-800 font-semibold">
              âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø£Ø¨Ù†Ø§Ø¦Ùƒ Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
            </p>
            <p className="text-yellow-700 text-sm mt-1">
              Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥ØºÙ„Ø§Ù‚ Ù‡Ø°Ù‡ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø£Ùˆ ØªØµÙØ­ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø­ØªÙ‰ ØªØ¬ÙŠØ¨ Ø¹Ù† Ù†ØªØ§Ø¦Ø¬ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¨Ù†Ø§Ø¡
            </p>
          </div>
        </div>
      </div>
    );
  }

  // Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ±Ù‚ÙŠØ§Øª Ù…Ø¹Ù„Ù‚Ø© - Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¹Ø§Ø¯ÙŠ
  return <>{children}</>;
}


// ==========================================
// FILE: src/components/editor/index.ts
// ==========================================

export { default as RichTextEditor } from './RichTextEditor';


// ==========================================
// FILE: src/components/editor/MathPreviewBox.tsx
// ==========================================

'use client';

import { useEffect, useRef } from 'react';
import katex from 'katex';
import 'katex/dist/katex.min.css';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Eye } from 'lucide-react';

interface MathPreviewBoxProps {
  content: string;
}

/**
 * Ù…Ø±Ø¨Ø¹ Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ø¹ Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ© Ø§Ù„Ù…ÙØ¹Ø±Ù‘Ø¶Ø©
 */
export default function MathPreviewBox({ content }: MathPreviewBoxProps) {
  const previewRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!previewRef.current || !content) return;

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø­ØªÙˆÙ‰
    previewRef.current.innerHTML = content;

    // Ù…Ø¹Ø§Ù„Ø¬Ø© LaTeX inline: \( ... \)
    const processInlineMath = () => {
      if (!previewRef.current) return;
      
      const walker = document.createTreeWalker(
        previewRef.current,
        NodeFilter.SHOW_TEXT,
        null
      );

      const nodesToReplace: { node: Node; matches: RegExpMatchArray[] }[] = [];
      let currentNode: Node | null;

      while ((currentNode = walker.nextNode())) {
        const text = currentNode.textContent || '';
        const inlineMatches = Array.from(text.matchAll(/\\\((.*?)\\\)/g));
        
        if (inlineMatches.length > 0) {
          nodesToReplace.push({ node: currentNode, matches: inlineMatches });
        }
      }

      nodesToReplace.forEach(({ node, matches }) => {
        if (!node.parentNode) return;

        const text = node.textContent || '';
        const parts: (string | HTMLElement)[] = [];
        let lastIndex = 0;

        matches.forEach((match) => {
          const fullMatch = match[0];
          const mathContent = match[1];
          const index = match.index || 0;

          if (index > lastIndex) {
            parts.push(text.substring(lastIndex, index));
          }

          const span = document.createElement('span');
          span.className = 'math-inline';
          try {
            katex.render(mathContent, span, {
              throwOnError: false,
              displayMode: false,
            });
            parts.push(span);
          } catch (error) {
            console.error('KaTeX inline error:', error);
            parts.push(fullMatch);
          }

          lastIndex = index + fullMatch.length;
        });

        if (lastIndex < text.length) {
          parts.push(text.substring(lastIndex));
        }

        const fragment = document.createDocumentFragment();
        parts.forEach((part) => {
          if (typeof part === 'string') {
            fragment.appendChild(document.createTextNode(part));
          } else {
            fragment.appendChild(part);
          }
        });

        node.parentNode.replaceChild(fragment, node);
      });
    };

    // Ù…Ø¹Ø§Ù„Ø¬Ø© LaTeX block: $$ ... $$
    const processBlockMath = () => {
      if (!previewRef.current) return;
      
      const walker = document.createTreeWalker(
        previewRef.current,
        NodeFilter.SHOW_TEXT,
        null
      );

      const nodesToReplace: { node: Node; matches: RegExpMatchArray[] }[] = [];
      let currentNode: Node | null;

      while ((currentNode = walker.nextNode())) {
        const text = currentNode.textContent || '';
        const blockMatches = Array.from(text.matchAll(/\$\$(.*?)\$\$/g));
        
        if (blockMatches.length > 0) {
          nodesToReplace.push({ node: currentNode, matches: blockMatches });
        }
      }

      nodesToReplace.forEach(({ node, matches }) => {
        if (!node.parentNode) return;

        const text = node.textContent || '';
        const parts: (string | HTMLElement)[] = [];
        let lastIndex = 0;

        matches.forEach((match) => {
          const fullMatch = match[0];
          const mathContent = match[1];
          const index = match.index || 0;

          if (index > lastIndex) {
            parts.push(text.substring(lastIndex, index));
          }

          const div = document.createElement('div');
          div.className = 'math-block text-center my-4';
          try {
            katex.render(mathContent, div, {
              throwOnError: false,
              displayMode: true,
            });
            parts.push(div);
          } catch (error) {
            console.error('KaTeX block error:', error);
            parts.push(fullMatch);
          }

          lastIndex = index + fullMatch.length;
        });

        if (lastIndex < text.length) {
          parts.push(text.substring(lastIndex));
        }

        const fragment = document.createDocumentFragment();
        parts.forEach((part) => {
          if (typeof part === 'string') {
            fragment.appendChild(document.createTextNode(part));
          } else {
            fragment.appendChild(part);
          }
        });

        node.parentNode.replaceChild(fragment, node);
      });
    };

    processBlockMath();
    processInlineMath();
  }, [content]);

  if (!content || content.trim() === '' || content === '<p></p>') {
    return null;
  }

  return (
    <Card className="mt-4 bg-blue-50 dark:bg-blue-950 border-blue-200 dark:border-blue-800">
      <CardHeader className="pb-3">
        <CardTitle className="text-sm font-medium flex items-center gap-2">
          <Eye className="h-4 w-4" />
          Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© (ÙƒÙ…Ø§ Ø³ÙŠØ±Ø§Ù‡Ø§ Ø§Ù„Ø·Ø§Ù„Ø¨)
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div
          ref={previewRef}
          className="prose prose-sm max-w-none math-content-rtl"
        />
      </CardContent>
    </Card>
  );
}


// ==========================================
// FILE: src/components/editor/MathSymbolsToolbar.tsx
// ==========================================

'use client';

import { useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Calculator } from "lucide-react";
import katex from 'katex';
import 'katex/dist/katex.min.css';

interface MathSymbolsToolbarProps {
  onInsert: (latex: string) => void;
}

// Ù…ÙƒÙˆÙ† Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø±Ù…Ø² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ
function MathPreview({ latex }: { latex: string }) {
  const ref = useRef<HTMLSpanElement>(null);

  useEffect(() => {
    if (ref.current) {
      try {
        katex.render(latex, ref.current, {
          throwOnError: false,
          displayMode: false,
        });
      } catch (error) {
        console.error('KaTeX render error:', error);
      }
    }
  }, [latex]);

  return <span ref={ref} className="text-xl" />;
}

export default function MathSymbolsToolbar({ onInsert }: MathSymbolsToolbarProps) {
  // Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
  const basicSymbols = [
    { label: "ÙƒØ³Ø±", latex: "\\frac{Ø¨Ø³Ø·}{Ù…Ù‚Ø§Ù…}", preview: "a/b", displayLatex: "\\frac{a}{b}" },
    { label: "Ø¬Ø°Ø±", latex: "\\sqrt{Ø¹Ø¯Ø¯}", preview: "âˆšx", displayLatex: "\\sqrt{x}" },
    { label: "Ø¬Ø°Ø± Ù†ÙˆÙ†ÙŠ", latex: "\\sqrt[n]{Ø¹Ø¯Ø¯}", preview: "â¿âˆšx", displayLatex: "\\sqrt[3]{x}" },
    { label: "Ø£Ø³", latex: "x^{Ø£Ø³}", preview: "xÂ²", displayLatex: "x^{2}" },
    { label: "Ø£Ø³ÙÙ„", latex: "x_{Ø±Ù‚Ù…}", preview: "xâ‚", displayLatex: "x_{1}" },
    { label: "Ù…Ø¬Ù…ÙˆØ¹", latex: "\\sum_{i=1}^{n} x_i", preview: "Î£", displayLatex: "\\sum_{i=1}^{n} x_i" },
    { label: "ØªÙƒØ§Ù…Ù„", latex: "\\int_{a}^{b} f(x) dx", preview: "âˆ«", displayLatex: "\\int_{0}^{1} x dx" },
    { label: "Ù†Ù‡Ø§ÙŠØ©", latex: "\\lim_{x \\to a} f(x)", preview: "lim", displayLatex: "\\lim_{x \\to 0} \\frac{\\sin x}{x}" },
  ];

  // Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„ÙŠÙˆÙ†Ø§Ù†ÙŠØ©
  const greekLetters = [
    { label: "Ø£Ù„ÙØ§", latex: "\\alpha", preview: "Î±", displayLatex: "\\alpha" },
    { label: "Ø¨ÙŠØªØ§", latex: "\\beta", preview: "Î²", displayLatex: "\\beta" },
    { label: "Ø¬Ø§Ù…Ø§", latex: "\\gamma", preview: "Î³", displayLatex: "\\gamma" },
    { label: "Ø¯Ù„ØªØ§", latex: "\\Delta", preview: "Î”", displayLatex: "\\Delta" },
    { label: "Ø«ÙŠØªØ§", latex: "\\theta", preview: "Î¸", displayLatex: "\\theta" },
    { label: "Ø¨Ø§ÙŠ", latex: "\\pi", preview: "Ï€", displayLatex: "\\pi" },
    { label: "Ø³ÙŠØ¬Ù…Ø§", latex: "\\Sigma", preview: "Î£", displayLatex: "\\Sigma" },
    { label: "Ø£ÙˆÙ…ÙŠØ¬Ø§", latex: "\\omega", preview: "Ï‰", displayLatex: "\\omega" },
    { label: "Ù„Ø§Ù…Ø¯Ø§", latex: "\\lambda", preview: "Î»", displayLatex: "\\lambda" },
    { label: "Ù…ÙŠ", latex: "\\mu", preview: "Î¼", displayLatex: "\\mu" },
    { label: "ÙØ§ÙŠ", latex: "\\phi", preview: "Ï†", displayLatex: "\\phi" },
    { label: "ØªØ§Ùˆ", latex: "\\tau", preview: "Ï„", displayLatex: "\\tau" },
  ];

  // Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
  const mathOperators = [
    { label: "Ø²Ø§Ø¦Ø¯ Ù†Ø§Ù‚Øµ", latex: "\\pm", preview: "Â±", displayLatex: "\\pm" },
    { label: "Ø¶Ø±Ø¨", latex: "\\times", preview: "Ã—", displayLatex: "\\times" },
    { label: "Ù‚Ø³Ù…Ø©", latex: "\\div", preview: "Ã·", displayLatex: "\\div" },
    { label: "ÙŠØ³Ø§ÙˆÙŠ ØªÙ‚Ø±ÙŠØ¨Ø§", latex: "\\approx", preview: "â‰ˆ", displayLatex: "\\approx" },
    { label: "Ù„Ø§ ÙŠØ³Ø§ÙˆÙŠ", latex: "\\neq", preview: "â‰ ", displayLatex: "\\neq" },
    { label: "Ø£ÙƒØ¨Ø± Ø£Ùˆ ÙŠØ³Ø§ÙˆÙŠ", latex: "\\geq", preview: "â‰¥", displayLatex: "\\geq" },
    { label: "Ø£ØµØºØ± Ø£Ùˆ ÙŠØ³Ø§ÙˆÙŠ", latex: "\\leq", preview: "â‰¤", displayLatex: "\\leq" },
    { label: "Ù…Ø§ Ù„Ø§ Ù†Ù‡Ø§ÙŠØ©", latex: "\\infty", preview: "âˆ", displayLatex: "\\infty" },
    { label: "ÙŠÙ†ØªÙ…ÙŠ", latex: "\\in", preview: "âˆˆ", displayLatex: "\\in" },
    { label: "Ù„Ø§ ÙŠÙ†ØªÙ…ÙŠ", latex: "\\notin", preview: "âˆ‰", displayLatex: "\\notin" },
    { label: "Ø§Ø­ØªÙˆØ§Ø¡", latex: "\\subset", preview: "âŠ‚", displayLatex: "\\subset" },
    { label: "Ø§ØªØ­Ø§Ø¯", latex: "\\cup", preview: "âˆª", displayLatex: "\\cup" },
    { label: "ØªÙ‚Ø§Ø·Ø¹", latex: "\\cap", preview: "âˆ©", displayLatex: "\\cap" },
    { label: "Ù„ÙƒÙ„", latex: "\\forall", preview: "âˆ€", displayLatex: "\\forall" },
    { label: "ÙŠÙˆØ¬Ø¯", latex: "\\exists", preview: "âˆƒ", displayLatex: "\\exists" },
    { label: "Ø³Ù‡Ù…", latex: "\\rightarrow", preview: "â†’", displayLatex: "\\rightarrow" },
  ];

  // Ø§Ù„Ù…ØµÙÙˆÙØ§Øª
  const matrices = [
    { 
      label: "Ù…ØµÙÙˆÙØ© 2Ã—2", 
      latex: "\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}",
      displayLatex: "\\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix}"
    },
    { 
      label: "Ù…ØµÙÙˆÙØ© 3Ã—3", 
      latex: "\\begin{pmatrix} a & b & c \\\\ d & e & f \\\\ g & h & i \\end{pmatrix}",
      displayLatex: "\\begin{pmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{pmatrix}"
    },
    { 
      label: "Ù…ØµÙÙˆÙØ© Ù…Ø¹Ù‚ÙˆÙØ© 2Ã—2", 
      latex: "\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}",
      displayLatex: "\\begin{bmatrix} 1 & 2 \\\\ 3 & 4 \\end{bmatrix}"
    },
    { 
      label: "Ù…ØµÙÙˆÙØ© Ù…Ø¹Ù‚ÙˆÙØ© 3Ã—3", 
      latex: "\\begin{bmatrix} a & b & c \\\\ d & e & f \\\\ g & h & i \\end{bmatrix}",
      displayLatex: "\\begin{bmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{bmatrix}"
    },
    { 
      label: "Ù…Ø­Ø¯Ø¯ (Determinant)", 
      latex: "\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}",
      displayLatex: "\\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}"
    },
    { 
      label: "Ù…ØªØ¬Ù‡ Ø¹Ù…ÙˆØ¯ÙŠ", 
      latex: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}",
      displayLatex: "\\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}"
    },
    { 
      label: "Ù†Ø¸Ø§Ù… Ù…Ø¹Ø§Ø¯Ù„Ø§Øª", 
      latex: "\\begin{cases} x + y = 5 \\\\ 2x - y = 1 \\end{cases}",
      displayLatex: "\\begin{cases} x + y = 5 \\\\ 2x - y = 1 \\end{cases}"
    },
    { 
      label: "Ù…ØµÙÙˆÙØ© Ù…Ø¹ Ù†Ù‚Ø§Ø·", 
      latex: "\\begin{pmatrix} a_{11} & \\cdots & a_{1n} \\\\ \\vdots & \\ddots & \\vdots \\\\ a_{m1} & \\cdots & a_{mn} \\end{pmatrix}",
      displayLatex: "\\begin{pmatrix} a_{11} & \\cdots & a_{1n} \\\\ \\vdots & \\ddots & \\vdots \\\\ a_{m1} & \\cdots & a_{mn} \\end{pmatrix}"
    },
  ];

  // Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
  const commonEquations = [
    { 
      label: "Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„ØªØ±Ø¨ÙŠØ¹ÙŠØ©", 
      latex: "x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}",
      displayLatex: "x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}"
    },
    { 
      label: "ÙÙŠØ«Ø§ØºÙˆØ±Ø³", 
      latex: "a^2 + b^2 = c^2",
      displayLatex: "a^2 + b^2 = c^2"
    },
    { 
      label: "Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ø¯Ø§Ø¦Ø±Ø©", 
      latex: "A = \\pi r^2",
      displayLatex: "A = \\pi r^2"
    },
    { 
      label: "Ø­Ø¬Ù… Ø§Ù„ÙƒØ±Ø©", 
      latex: "V = \\frac{4}{3}\\pi r^3",
      displayLatex: "V = \\frac{4}{3}\\pi r^3"
    },
    { 
      label: "Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¯", 
      latex: "\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}",
      displayLatex: "\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}"
    },
    { 
      label: "Ù…ØªÙˆØ³Ø· Ø­Ø³Ø§Ø¨ÙŠ", 
      latex: "\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i",
      displayLatex: "\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i"
    },
    { 
      label: "ØªÙƒØ§Ù…Ù„", 
      latex: "\\int_{a}^{b} f(x) dx",
      displayLatex: "\\int_{0}^{1} x^2 dx = \\frac{1}{3}"
    },
    { 
      label: "Ù†Ø¸Ø±ÙŠØ© Ø§Ù„Ù†Ù‡Ø§ÙŠØ§Øª", 
      latex: "\\lim_{x \\to 0} \\frac{\\sin x}{x} = 1",
      displayLatex: "\\lim_{x \\to 0} \\frac{\\sin x}{x} = 1"
    },
    { 
      label: "Ù…Ø¹Ø§Ø¯Ù„Ø© Ø®Ø·ÙŠØ©", 
      latex: "y = mx + b",
      displayLatex: "y = mx + b"
    },
    { 
      label: "ØµÙŠØºØ© Ø§Ù„Ù…Ø³Ø§ÙØ©", 
      latex: "d = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}",
      displayLatex: "d = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}"
    },
    { 
      label: "Ù‚Ø§Ù†ÙˆÙ† ÙƒÙˆØ²ÙŠÙ†", 
      latex: "c^2 = a^2 + b^2 - 2ab\\cos(\\theta)",
      displayLatex: "c^2 = a^2 + b^2 - 2ab\\cos(\\theta)"
    },
    { 
      label: "Ù…Ø´ØªÙ‚Ø©", 
      latex: "\\frac{d}{dx}(x^n) = nx^{n-1}",
      displayLatex: "\\frac{d}{dx}(x^n) = nx^{n-1}"
    },
  ];

  // Ø§Ù„Ø£Ù‚ÙˆØ§Ø³ ÙˆØ§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø®Ø§ØµØ©
  const brackets = [
    { label: "Ø£Ù‚ÙˆØ§Ø³ Ø¹Ø§Ø¯ÙŠØ©", latex: "\\left( Ù…Ø­ØªÙˆÙ‰ \\right)", preview: "( )", displayLatex: "\\left( x \\right)" },
    { label: "Ø£Ù‚ÙˆØ§Ø³ Ù…Ø±Ø¨Ø¹Ø©", latex: "\\left[ Ù…Ø­ØªÙˆÙ‰ \\right]", preview: "[ ]", displayLatex: "\\left[ x \\right]" },
    { label: "Ø£Ù‚ÙˆØ§Ø³ Ù…Ø¹Ù‚ÙˆÙØ©", latex: "\\left\\{ Ù…Ø­ØªÙˆÙ‰ \\right\\}", preview: "{ }", displayLatex: "\\left\\{ x \\right\\}" },
    { label: "Ù‚ÙŠÙ…Ø© Ù…Ø·Ù„Ù‚Ø©", latex: "\\left| Ø¹Ø¯Ø¯ \\right|", preview: "| |", displayLatex: "\\left| x \\right|" },
    { label: "ÙƒØ³Ø± Ø¹Ø§Ø¯ÙŠ", latex: "\\frac{Ø£}{Ø¨}", preview: "Ø£/Ø¨", displayLatex: "\\frac{a}{b}" },
    { label: "Ù†Ù‚Ø§Ø· Ø£ÙÙ‚ÙŠØ©", latex: "\\cdots", preview: "Â·Â·Â·", displayLatex: "1 + 2 + \\cdots + n" },
    { label: "Ù†Ù‚Ø§Ø· Ø¹Ù…ÙˆØ¯ÙŠØ©", latex: "\\vdots", preview: "â‹®", displayLatex: "\\vdots" },
    { label: "Ù†Ù‚Ø§Ø· Ù‚Ø·Ø±ÙŠØ©", latex: "\\ddots", preview: "â‹±", displayLatex: "\\ddots" },
  ];

  const handleInsert = (latex: string, isInline: boolean = true) => {
    // Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„ØµÙŠØºØ© Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØµØ­ÙŠØ­
    const formatted = isInline ? `\\(${latex}\\)` : `$$${latex}$$`;
    onInsert(formatted);
  };

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          type="button"
          variant="outline"
          size="sm"
          className="gap-2"
        >
          <Calculator className="h-4 w-4" />
          Ø±Ù…ÙˆØ² Ø±ÙŠØ§Ø¶ÙŠØ©
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-[600px] p-4" align="start">
        <Tabs defaultValue="basic" dir="rtl">
          <TabsList className="grid w-full grid-cols-6">
            <TabsTrigger value="basic">Ø£Ø³Ø§Ø³ÙŠ</TabsTrigger>
            <TabsTrigger value="greek">ÙŠÙˆÙ†Ø§Ù†ÙŠ</TabsTrigger>
            <TabsTrigger value="operators">Ø¹Ù…Ù„ÙŠØ§Øª</TabsTrigger>
            <TabsTrigger value="matrices">Ù…ØµÙÙˆÙØ§Øª</TabsTrigger>
            <TabsTrigger value="equations">Ù…Ø¹Ø§Ø¯Ù„Ø§Øª</TabsTrigger>
            <TabsTrigger value="brackets">Ø£Ù‚ÙˆØ§Ø³</TabsTrigger>
          </TabsList>

          {/* Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© */}
          <TabsContent value="basic" className="space-y-2">
            <div className="text-sm text-muted-foreground mb-2">
              Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø±Ù…Ø² Ù„Ø¥Ø¯Ø±Ø§Ø¬Ù‡ ÙÙŠ Ø§Ù„Ù…Ø­Ø±Ø±
            </div>
            <div className="grid grid-cols-4 gap-2 max-h-[300px] overflow-y-auto">
              {basicSymbols.map((symbol, index) => (
                <Button
                  key={index}
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => handleInsert(symbol.latex, true)}
                  className="flex flex-col items-center h-auto py-3 gap-1"
                >
                  <MathPreview latex={symbol.displayLatex} />
                  <span className="text-xs mt-1">{symbol.label}</span>
                </Button>
              ))}
            </div>
          </TabsContent>

          {/* Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„ÙŠÙˆÙ†Ø§Ù†ÙŠØ© */}
          <TabsContent value="greek" className="space-y-2">
            <div className="text-sm text-muted-foreground mb-2">
              Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„ÙŠÙˆÙ†Ø§Ù†ÙŠØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª
            </div>
            <div className="grid grid-cols-6 gap-2 max-h-[300px] overflow-y-auto">
              {greekLetters.map((letter, index) => (
                <Button
                  key={index}
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => handleInsert(letter.latex, true)}
                  className="flex flex-col items-center h-auto py-3 gap-1"
                >
                  <MathPreview latex={letter.displayLatex} />
                  <span className="text-xs mt-1">{letter.label}</span>
                </Button>
              ))}
            </div>
          </TabsContent>

          {/* Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙˆØ§Ù„Ø±Ù…ÙˆØ² */}
          <TabsContent value="operators" className="space-y-2">
            <div className="text-sm text-muted-foreground mb-2">
              Ø±Ù…ÙˆØ² Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©
            </div>
            <div className="grid grid-cols-4 gap-2 max-h-[300px] overflow-y-auto">
              {mathOperators.map((operator, index) => (
                <Button
                  key={index}
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => handleInsert(operator.latex, true)}
                  className="flex flex-col items-center h-auto py-3 gap-1"
                >
                  <MathPreview latex={operator.displayLatex} />
                  <span className="text-xs mt-1">{operator.label}</span>
                </Button>
              ))}
            </div>
          </TabsContent>

          {/* Ø§Ù„Ù…ØµÙÙˆÙØ§Øª */}
          <TabsContent value="matrices" className="space-y-2">
            <div className="text-sm text-muted-foreground mb-2">
              Ù…ØµÙÙˆÙØ§Øª ÙˆÙ†Ø¸Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª
            </div>
            <div className="grid grid-cols-2 gap-2 max-h-[300px] overflow-y-auto">
              {matrices.map((matrix, index) => (
                <Button
                  key={index}
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => handleInsert(matrix.latex, false)}
                  className="flex flex-col items-center h-auto py-3 gap-1"
                >
                  <MathPreview latex={matrix.displayLatex} />
                  <span className="text-xs mt-1">{matrix.label}</span>
                </Button>
              ))}
            </div>
          </TabsContent>

          {/* Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© */}
          <TabsContent value="equations" className="space-y-2">
            <div className="text-sm text-muted-foreground mb-2">
              Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø¬Ø§Ù‡Ø²Ø© - Ø§Ø¶ØºØ· Ù„Ø¥Ø¯Ø±Ø§Ø¬Ù‡Ø§
            </div>
            <div className="grid grid-cols-2 gap-2 max-h-[300px] overflow-y-auto">
              {commonEquations.map((eq, index) => (
                <Button
                  key={index}
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => handleInsert(eq.latex, false)}
                  className="flex flex-col items-center h-auto py-3 gap-1"
                >
                  <MathPreview latex={eq.displayLatex} />
                  <span className="text-xs mt-1">{eq.label}</span>
                </Button>
              ))}
            </div>
          </TabsContent>

          {/* Ø§Ù„Ø£Ù‚ÙˆØ§Ø³ */}
          <TabsContent value="brackets" className="space-y-2">
            <div className="text-sm text-muted-foreground mb-2">
              Ø£Ù‚ÙˆØ§Ø³ ÙˆØ±Ù…ÙˆØ² Ø®Ø§ØµØ©
            </div>
            <div className="grid grid-cols-4 gap-2 max-h-[300px] overflow-y-auto">
              {brackets.map((bracket, index) => (
                <Button
                  key={index}
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => handleInsert(bracket.latex, true)}
                  className="flex flex-col items-center h-auto py-3 gap-1"
                >
                  <MathPreview latex={bracket.displayLatex} />
                  <span className="text-xs mt-1">{bracket.label}</span>
                </Button>
              ))}
            </div>
          </TabsContent>
        </Tabs>

        <div className="mt-4 p-3 bg-muted rounded-lg text-xs">
          <strong>ğŸ’¡ Ù†ØµÙŠØ­Ø©:</strong> Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ù…ÙØ¹Ø±Ù‘Ø¶Ø© ØªÙØ¸Ù‡Ø± ÙƒÙŠÙ Ø³ØªØ¨Ø¯Ùˆ ÙÙŠ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ. ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù†Øµ Ø¨Ø¹Ø¯ Ø§Ù„Ø¥Ø¯Ø±Ø§Ø¬.
        </div>
      </PopoverContent>
    </Popover>
  );
}


// ==========================================
// FILE: src/components/editor/RichTextEditor.tsx
// ==========================================

'use client';

import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image';
import { Table } from '@tiptap/extension-table';
import { TableRow } from '@tiptap/extension-table-row';
import { TableCell } from '@tiptap/extension-table-cell';
import { TableHeader } from '@tiptap/extension-table-header';
import TextAlign from '@tiptap/extension-text-align';
import { Color } from '@tiptap/extension-color';
import { TextStyle } from '@tiptap/extension-text-style';
import Highlight from '@tiptap/extension-highlight';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Bold,
  Italic,
  List,
  ListOrdered,
  ImageIcon,
  Link2,
  Table as TableIcon,
  Undo,
  Redo,
  Heading1,
  Heading2,
  Heading3,
  Underline as UnderlineIcon,
  Highlighter,
  AlignLeft,
  AlignCenter,
  AlignRight,
  AlignJustify,
  Upload,
  MoveLeft,
  MoveRight,
  Sigma,
} from 'lucide-react';
import { useCallback, useEffect, useRef, useState } from 'react';
import { MathExtension } from './extensions/MathExtension';
import { uploadFileToDrive } from '@/lib/upload'; // Import the new upload utility
import { Loader2 } from 'lucide-react'; // Import Loader2 icon

interface RichTextEditorProps {
  content: string;
  onChange: (content: string) => void;
  placeholder?: string;
  editable?: boolean;
  className?: string;
  googleDriveParentFolderId?: string; // New prop for Google Drive parent folder
}

export default function RichTextEditor({
  content,
  onChange,
  placeholder = 'Ø§Ø¨Ø¯Ø£ Ø§Ù„ÙƒØªØ§Ø¨Ø© Ù‡Ù†Ø§...',
  editable = true,
  className = '',
  googleDriveParentFolderId, // Destructure the new prop
}: RichTextEditorProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [colorPicker, setColorPicker] = useState('#000000');
  const [bgColorPicker, setBgColorPicker] = useState('#ffff00');
  const [isUploading, setIsUploading] = useState(false); // New state for upload loading

  const editor = useEditor({
    immediatelyRender: false,
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [1, 2, 3],
        },
      }),
      Image.configure({
        inline: true,
        allowBase64: true,
      }),
      Table.configure({
        resizable: true,
      }),
      TableRow,
      TableHeader,
      TableCell,
      TextAlign.configure({
        types: ['heading', 'paragraph'],
      }),
      TextStyle,
      Color,
      Highlight.configure({
        multicolor: true,
      }),
      MathExtension,
    ],
    content,
    editable,
    onUpdate: ({ editor }) => {
      onChange(editor.getHTML());
    },
    editorProps: {
      attributes: {
        class: 'prose prose-sm max-w-none focus:outline-none min-h-[200px] p-4',
      },
    },
  });

  // ØªØ­Ø¯ÙŠØ« Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ø­Ø±Ø± Ø¹Ù†Ø¯Ù…Ø§ ÙŠØªØºÙŠØ± content Ù…Ù† Ø§Ù„Ø®Ø§Ø±Ø¬ (Ù…Ø«Ù„ ØªÙˆÙ„ÙŠØ¯ AI)
  useEffect(() => {
    if (editor && content !== editor.getHTML()) {
      editor.commands.setContent(content);
    }
  }, [content, editor]);

  const handleImageUpload = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file || !editor || !googleDriveParentFolderId) {
      alert('Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù. ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø¬Ù„Ø¯ Ø§Ù„Ø£Ø¨ Ù„Ù€ Google Drive.');
      return;
    }

    // Check file size (client-side validation for immediate feedback)
    const maxSize = 2 * 1024 * 1024; // 2MB
    if (file.size > maxSize) {
      alert('Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹! Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 2 Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª');
      return;
    }

    setIsUploading(true);
    try {
      const { fileUrl } = await uploadFileToDrive(file, googleDriveParentFolderId);
      editor.chain().focus().setImage({ src: fileUrl }).run();
    } catch (error) {
      console.error('Error uploading to Google Drive:', error);
      alert('ÙØ´Ù„ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Google Drive.');
    } finally {
      setIsUploading(false);
      // Clear the file input value to allow re-uploading the same file
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  }, [editor, googleDriveParentFolderId]);

  const addImageFromDrive = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const addImageUrl = useCallback(() => {
    const url = window.prompt('Ø£Ø¯Ø®Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø©:');
    if (url && editor) {
      editor.chain().focus().setImage({ src: url }).run();
    }
  }, [editor]);

  const addLink = useCallback(() => {
    const url = window.prompt('Ø£Ø¯Ø®Ù„ Ø§Ù„Ø±Ø§Ø¨Ø·:');
    if (url && editor) {
      editor.chain().focus().setLink({ href: url }).run();
    }
  }, [editor]);

  const addTable = useCallback(() => {
    if (editor) {
      editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run();
    }
  }, [editor]);

  const setTextDirection = useCallback((direction: 'ltr' | 'rtl') => {
    if (editor) {
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ù„Ù…Ø­Ø±Ø±
      const editorElement = editor.view.dom;
      
      // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­Ø±Ø± Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
      if (direction === 'rtl') {
        editorElement.setAttribute('dir', 'rtl');
        editorElement.style.textAlign = 'right';
      } else {
        editorElement.setAttribute('dir', 'ltr');
        editorElement.style.textAlign = 'left';
      }
      
      // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­Ø±Ø±
      editor.commands.focus();
    }
  }, [editor]);

  if (!editor) {
    return null;
  }

  const uploadInputId = 'rich-text-image-upload';

  return (
    <div className={`border rounded-lg ${className}`}>
      <input
        ref={fileInputRef}
        id={uploadInputId}
        type="file"
        accept="image/*"
        className="hidden"
        onChange={handleImageUpload}
        aria-label="ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø©"
        aria-labelledby="upload-image-button"
        disabled={isUploading}
      />
      {editable && (
        <div className="flex flex-wrap gap-1 p-2 border-b bg-muted/50">
          {/* Text Formatting */}
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().toggleBold().run()}
            className={editor.isActive('bold') ? 'bg-muted' : ''}
            title="ØºØ§Ù…Ù‚"
            disabled={isUploading}
          >
            <Bold className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().toggleItalic().run()}
            className={editor.isActive('italic') ? 'bg-muted' : ''}
            title="Ù…Ø§Ø¦Ù„"
            disabled={isUploading}
          >
            <Italic className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().toggleUnderline().run()}
            className={editor.isActive('underline') ? 'bg-muted' : ''}
            title="ØªØ³Ø·ÙŠØ±"
            disabled={isUploading}
          >
            <UnderlineIcon className="h-4 w-4" />
          </Button>

          {/* Headings */}
          <div className="w-px h-8 bg-border mx-1" />
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().toggleHeading({ level: 1 }).run()}
            className={editor.isActive('heading', { level: 1 }) ? 'bg-muted' : ''}
            disabled={isUploading}
          >
            <Heading1 className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
            className={editor.isActive('heading', { level: 2 }) ? 'bg-muted' : ''}
            disabled={isUploading}
          >
            <Heading2 className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}
            className={editor.isActive('heading', { level: 3 }) ? 'bg-muted' : ''}
            disabled={isUploading}
          >
            <Heading3 className="h-4 w-4" />
          </Button>

          {/* Colors */}
          <div className="flex items-center gap-1">
            <input
              type="color"
              value={colorPicker}
              onChange={(e) => {
                setColorPicker(e.target.value);
                editor.chain().focus().setColor(e.target.value).run();
              }}
              className="w-8 h-8 rounded cursor-pointer"
              title="Ù„ÙˆÙ† Ø§Ù„Ù†Øµ"
              disabled={isUploading}
            />
            <Button
              type="button"
              variant="ghost"
              size="sm"
              onClick={() => editor.chain().focus().toggleHighlight({ color: bgColorPicker }).run()}
              className={editor.isActive('highlight') ? 'bg-muted' : ''}
              title="ØªÙ…ÙŠÙŠØ²"
              disabled={isUploading}
            >
              <Highlighter className="h-4 w-4" />
            </Button>
            <input
              type="color"
              value={bgColorPicker}
              onChange={(e) => setBgColorPicker(e.target.value)}
              className="w-8 h-8 rounded cursor-pointer"
              title="Ù„ÙˆÙ† Ø§Ù„ØªÙ…ÙŠÙŠØ²"
              disabled={isUploading}
            />
          </div>

          {/* Lists */}
          <div className="w-px h-8 bg-border mx-1" />
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().toggleBulletList().run()}
            className={editor.isActive('bulletList') ? 'bg-muted' : ''}
            title="Ù‚Ø§Ø¦Ù…Ø© Ù†Ù‚Ø·ÙŠØ©"
            disabled={isUploading}
          >
            <List className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().toggleOrderedList().run()}
            className={editor.isActive('orderedList') ? 'bg-muted' : ''}
            title="Ù‚Ø§Ø¦Ù…Ø© Ù…Ø±Ù‚Ù…Ø©"
            disabled={isUploading}
          >
            <ListOrdered className="h-4 w-4" />
          </Button>

          {/* Text Alignment */}
          <div className="w-px h-8 bg-border mx-1" />
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().setTextAlign('left').run()}
            className={editor.isActive({ textAlign: 'left' }) ? 'bg-muted' : ''}
            title="Ù…Ø­Ø§Ø°Ø§Ø© Ù„Ù„ÙŠØ³Ø§Ø±"
            disabled={isUploading}
          >
            <AlignLeft className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().setTextAlign('center').run()}
            className={editor.isActive({ textAlign: 'center' }) ? 'bg-muted' : ''}
            title="Ù…Ø­Ø§Ø°Ø§Ø© Ù„Ù„ÙˆØ³Ø·"
            disabled={isUploading}
          >
            <AlignCenter className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().setTextAlign('right').run()}
            className={editor.isActive({ textAlign: 'right' }) ? 'bg-muted' : ''}
            title="Ù…Ø­Ø§Ø°Ø§Ø© Ù„Ù„ÙŠÙ…ÙŠÙ†"
            disabled={isUploading}
          >
            <AlignRight className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().setTextAlign('justify').run()}
            className={editor.isActive({ textAlign: 'justify' }) ? 'bg-muted' : ''}
            title="Ø¶Ø¨Ø·"
            disabled={isUploading}
          >
            <AlignJustify className="h-4 w-4" />
          </Button>

          {/* Text Direction */}
          <div className="w-px h-8 bg-border mx-1" />
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => setTextDirection('ltr')}
            title="Ø§ØªØ¬Ø§Ù‡ Ù…Ù† Ø§Ù„ÙŠØ³Ø§Ø± Ù„Ù„ÙŠÙ…ÙŠÙ† (LTR)"
            disabled={isUploading}
          >
            <MoveRight className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => setTextDirection('rtl')}
            title="Ø§ØªØ¬Ø§Ù‡ Ù…Ù† Ø§Ù„ÙŠÙ…ÙŠÙ† Ù„Ù„ÙŠØ³Ø§Ø± (RTL)"
            disabled={isUploading}
          >
            <MoveLeft className="h-4 w-4" />
          </Button>

          {/* Insert */}
          <div className="w-px h-8 bg-border mx-1" />
          
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={addImageFromDrive}
            id="upload-image-button" // Add ID for aria-labelledby
            title="Ø±ÙØ¹ ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Google Drive"
            disabled={isUploading || !googleDriveParentFolderId}
          >
            {isUploading ? (
              <Loader2 className="h-4 w-4 animate-spin" />
            ) : (
              <Upload className="h-4 w-4" />
            )}
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={addImageUrl}
            title="Ø¥Ø¯Ø±Ø§Ø¬ ØµÙˆØ±Ø© Ù…Ù† Ø±Ø§Ø¨Ø·"
            disabled={isUploading}
          >
            <ImageIcon className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={addLink}
            className={editor.isActive('link') ? 'bg-muted' : ''}
            title="Ø±Ø§Ø¨Ø·"
            disabled={isUploading}
          >
            <Link2 className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={addTable}
            title="Ø¬Ø¯ÙˆÙ„"
            disabled={isUploading}
          >
            <TableIcon className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => {
              if (typeof editor.chain().focus().setMathLive === 'function') {
                editor.chain().focus().setMathLive().run();
              }
            }}
            className={editor.isActive('mathLive') ? 'bg-muted' : ''}
            title="Ù…Ø¹Ø§Ø¯Ù„Ø© Ø±ÙŠØ§Ø¶ÙŠØ©"
            disabled={isUploading}
          >
            <Sigma className="h-4 w-4" />
          </Button>

          {/* Undo/Redo */}
          <div className="w-px h-8 bg-border mx-1" />
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().undo().run()}
            disabled={!editor.can().undo() || isUploading}
          >
            <Undo className="h-4 w-4" />
          </Button>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={() => editor.chain().focus().redo().run()}
            disabled={!editor.can().redo() || isUploading}
          >
            <Redo className="h-4 w-4" />
          </Button>
        </div>
      )}
      <EditorContent editor={editor} className="min-h-[200px]" />
    </div>
  );
}


// ==========================================
// FILE: src/components/editor/extensions/GeoGebra.ts
// ==========================================



// ==========================================
// FILE: src/components/editor/extensions/MathExtension.ts
// ==========================================

'use client';

import { Node, mergeAttributes } from '@tiptap/core';
import { ReactNodeViewRenderer } from '@tiptap/react';
import MathComponent from './MathComponent';

// ØªÙˆØ³ÙŠØ¹ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ù„Ø¥Ø¶Ø§ÙØ© Ø¯Ø¹Ù… TypeScript Ù„Ù„Ø£Ù…Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯
declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    mathLive: {
      /**
       * Ø¥Ø¯Ø±Ø§Ø¬ Ù…Ø¹Ø§Ø¯Ù„Ø© Ø±ÙŠØ§Ø¶ÙŠØ©
       */
      setMathLive: (options?: { latex: string }) => ReturnType;
    };
  }
}

export const MathExtension = Node.create({
  name: 'mathLive',

  group: 'inline',

  inline: true,

  atom: true, // Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªÙ‚Ø³ÙŠÙ…Ù‡Ø§ Ø£Ùˆ ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø¤Ø´Ø± Ø¨Ø¯Ø§Ø®Ù„Ù‡Ø§ (Ù…Ù† ÙˆØ¬Ù‡Ø© Ù†Ø¸Ø± Tiptap)

  addAttributes() {
    return {
      latex: {
        default: '',
        // Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‚ÙŠÙ…Ø© Ù…Ù† Ø§Ù„Ù€ Attribute Ø£Ùˆ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù†Øµ Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ù† HTML
        parseHTML: (element) => element.getAttribute('data-latex') || element.textContent,
        // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù‚ÙŠÙ…Ø© ÙÙŠ Attribute Ø¹Ù†Ø¯ Ø§Ù„Ø­ÙØ¸
        renderHTML: (attributes) => {
          return {
            'data-latex': attributes.latex,
          };
        },
      },
    };
  },

  parseHTML() {
    return [
      {
        tag: 'span[data-type="math-live"]',
      },
    ];
  },

  renderHTML({ HTMLAttributes, node }) {
    // Ø§Ù„Ø­ÙØ¸ ÙƒØ¹Ù†ØµØ± span ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙˆØ¯ Ù„Ø¶Ù…Ø§Ù† Ø¥Ù…ÙƒØ§Ù†ÙŠØ© Ù‚Ø±Ø§Ø¡ØªÙ‡ Ø­ØªÙ‰ Ø¨Ø¯ÙˆÙ† JS
    return ['span', mergeAttributes(HTMLAttributes, { 'data-type': 'math-live' }), node.attrs.latex];
  },

  addNodeView() {
    return ReactNodeViewRenderer(MathComponent, {
      // Ù…Ù†Ø¹ Tiptap Ù…Ù† Ø§Ø¹ØªØ±Ø§Ø¶ Ø§Ù„Ø£Ø­Ø¯Ø§Ø« (Ù…Ø«Ù„ Ø§Ù„ÙƒØªØ§Ø¨Ø©) Ø¯Ø§Ø®Ù„ Ù…ÙƒÙˆÙ† MathLive
      stopEvent: ({ event }) => {
        return (event.target as HTMLElement).tagName?.toLowerCase() === 'math-field';
      },
    });
  },

  addCommands() {
    return {
      setMathLive:
        (options) =>
        ({ commands }) => {
          return commands.insertContent({
            type: 'mathLive',
            attrs: options,
          });
        },
    };
  },
});

// ==========================================
// FILE: src/components/editor/extensions/MathComponent.tsx
// ==========================================

'use client';

import { NodeViewWrapper, NodeViewProps } from '@tiptap/react';
import React, { useEffect, useRef, useState, useCallback } from 'react';

// ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù…Ø®ØµØµ Ù„Ù€ TypeScript Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡
declare global {
  namespace JSX {
    interface IntrinsicElements {
      'math-field': React.DetailedHTMLProps<React.HTMLAttributes<HTMLElement>, HTMLElement>;
    }
  }
}

export default function MathComponent({ node, updateAttributes, selected, editor, getPos }: NodeViewProps) {
  const [isLibLoaded, setIsLibLoaded] = useState(false);
  const mfRef = useRef<HTMLElement>(null);
  
  // Ø§Ø³ØªØ®Ø¯Ø§Ù… refs Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù…ØªØºÙŠØ±Ø© ÙˆØªØ¬Ù†Ø¨ Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ù€ useEffect Ø¹Ù†Ø¯ ÙƒÙ„ ØªØºÙŠÙŠØ±
  const editorRef = useRef(editor);
  const getPosRef = useRef(getPos);
  const nodeRef = useRef(node);

  // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù€ refs Ø¹Ù†Ø¯ ÙƒÙ„ render Ù„Ø¶Ù…Ø§Ù† Ø¯Ù‚Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  useEffect(() => {
    editorRef.current = editor;
    getPosRef.current = getPos;
    nodeRef.current = node;
  });

  // 1. ØªØ­Ù…ÙŠÙ„ Ù…ÙƒØªØ¨Ø© MathLive Ø¨Ø´ÙƒÙ„ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ (Lazy Loading)
  useEffect(() => {
    if (typeof window !== 'undefined') {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…ÙƒØªØ¨Ø© Ù…Ø­Ù…Ù„Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹ Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªÙƒØ±Ø§Ø±
      if (window.customElements.get('math-field')) {
        setIsLibLoaded(true);
      } else {
        import('mathlive')
          .then((mod) => {
            // ØªØ¹ÙŠÙŠÙ† Ù…Ø³Ø§Ø± Ø§Ù„Ø®Ø·ÙˆØ· Ø¥Ù„Ù‰ CDN Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© Ø¹Ø¯Ù… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„ÙŠÙ‡Ø§ ÙÙŠ Ø¨ÙŠØ¦Ø© Next.js
            mod.MathfieldElement.fontsDirectory = 'https://cdn.jsdelivr.net/npm/mathlive/dist/fonts/';

            setIsLibLoaded(true);
          })
          .catch((err) => console.error('Failed to load mathlive:', err));
      }
    }
  }, []);

  // 2. Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ­Ø¯ÙŠØ«Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø§Ù„ÙƒØªØ§Ø¨Ø© ÙÙŠ Ø§Ù„Ù…Ø­Ø±Ø±)
  const handleInput = useCallback((e: Event) => {
    const target = e.target as any;
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚ÙŠÙ…Ø© ÙÙŠ Tiptap ÙÙ‚Ø·
    updateAttributes({ latex: target.value });
  }, [updateAttributes]);

  // 3. Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø³ØªÙ…Ø¹ÙŠÙ† (Listeners) Ø¹Ù†Ø¯ Ø¬Ø§Ù‡Ø²ÙŠØ© Ø§Ù„Ø¹Ù†ØµØ±
  useEffect(() => {
    const mf = mfRef.current;
    if (mf && isLibLoaded) {
      // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
      if ((mf as any).value !== node.attrs.latex) {
        (mf as any).value = node.attrs.latex || '';
      }

      // ØªØ­Ø¯ÙŠØ« ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© (Read-Only) Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø­Ø±Ø±
      (mf as any).readOnly = !editor.isEditable;

      // ØªÙØ¹ÙŠÙ„ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„ØªØ³Ù‡ÙŠÙ„ Ø¥Ø¯Ø±Ø§Ø¬ Ø§Ù„Ø±Ù…ÙˆØ²
      (mf as any).mathVirtualKeyboardPolicy = editor.isEditable ? 'manual' : 'auto';

      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…ÙØªØ§Ø­ Enter Ù„Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø³Ø·Ø± Ø¬Ø¯ÙŠØ¯
      const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          
          const currentGetPos = getPosRef.current;
          const currentNode = nodeRef.current;
          const currentEditor = editorRef.current;

          if (typeof currentGetPos === 'function') {
            currentEditor
              .chain()
              .focus()
              .setTextSelection(currentGetPos() + currentNode.nodeSize)
              .enter()
              .run();
          }
        }
      };

      // Ø¥Ø®ÙØ§Ø¡ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø¹Ù†Ø¯ ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ØªØ±ÙƒÙŠØ² (Ø§Ù„Ù†Ù‚Ø± Ø®Ø§Ø±Ø¬ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©)
      const handleFocusOut = () => {
        if (typeof window !== 'undefined' && (window as any).mathVirtualKeyboard) {
          (window as any).mathVirtualKeyboard.hide();
        }
      };

      // Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªÙ…Ø¹ Ø§Ù„Ø­Ø¯Ø«
      mf.addEventListener('keydown', handleKeyDown);
      mf.addEventListener('input', handleInput);
      mf.addEventListener('focusout', handleFocusOut);

      return () => {
        mf.removeEventListener('keydown', handleKeyDown);
        mf.removeEventListener('input', handleInput);
        mf.removeEventListener('focusout', handleFocusOut);
      };
    }
  }, [isLibLoaded, handleInput, editor.isEditable]); // ØªÙ… ØªÙ‚Ù„ÙŠØµ Ø§Ù„Ø§Ø¹ØªÙ…Ø§Ø¯Ø§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±

  // 4. Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© (Ù…Ø«Ù„ Undo/Redo)
  useEffect(() => {
    const mf = mfRef.current;
    if (mf && isLibLoaded) {
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù„ØªØ¬Ù†Ø¨ Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ù…Ø¤Ø´Ø± (Cursor Jumping)
      if ((mf as any).value !== node.attrs.latex) {
        (mf as any).value = node.attrs.latex || '';
      }
    }
  }, [node.attrs.latex, isLibLoaded]);

  if (!isLibLoaded) {
    return (
      <NodeViewWrapper className="inline-block p-2 border rounded bg-muted text-muted-foreground text-xs">
        Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­Ø±Ø± Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ...
      </NodeViewWrapper>
    );
  }

  return (
    <NodeViewWrapper className="inline-block align-middle mx-1">
      <math-field
        ref={mfRef}
        style={{
          display: 'inline-block',
          minWidth: '20px',
          padding: '2px 4px',
          borderRadius: '4px',
          border: selected ? '2px solid #3b82f6' : '1px solid transparent', // ØªÙ…ÙŠÙŠØ² Ø£Ø²Ø±Ù‚ Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ø¯ÙŠØ¯
          backgroundColor: selected ? 'rgba(59, 130, 246, 0.1)' : 'transparent',
          cursor: 'text',
          outline: 'none',
        }}
      />
    </NodeViewWrapper>
  );
}

// ==========================================
// FILE: src/components/FileUpload.tsx
// ==========================================

'use client';

import { useState, useRef, ChangeEvent } from 'react';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { UploadCloud, X, File as FileIcon, Loader2 } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface FileUploadProps {
  label: string;
  accept: string;
  maxSizeMB: number;
  value?: string; // Will now hold the file name
  onChange: (fileInfo: { fileId: string; fileName: string; fileUrl: string } | null) => void;
  onUploadStatusChange?: (isUploading: boolean) => void;
  parentFolderId?: string; // The Google Drive folder ID to upload to
  description?: string;
  stage?: string;
  subject?: string;
  teacher?: string;
  lesson?: string;
}

export function FileUpload({
  label,
  accept,
  maxSizeMB,
  value,
  onChange,
  onUploadStatusChange,
  parentFolderId,
  description,
  stage,
  subject,
  teacher,
  lesson,
}: FileUploadProps) {
  const { toast } = useToast();
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleFileChange = async (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Check file size
    const fileSizeMB = file.size / (1024 * 1024);
    if (fileSizeMB > maxSizeMB) {
      toast({
        title: 'Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹',
        description: `ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù Ø£Ù‚Ù„ Ù…Ù† ${maxSizeMB} Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª. Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø­Ø§Ù„ÙŠ: ${fileSizeMB.toFixed(2)} Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª`,
        variant: 'destructive',
      });
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      return;
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‡Ø±Ù…ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø±ÙØ¹
    if (!stage || !subject || !teacher || !lesson) {
      toast({
        title: 'Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©',
        description: 'ÙŠØ±Ø¬Ù‰ ØªØ¹Ø¨Ø¦Ø© Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ (Ø§Ù„Ù…Ø±Ø­Ù„Ø©ØŒ Ø§Ù„Ù…Ø§Ø¯Ø©ØŒ Ø§Ù„Ø£Ø³ØªØ§Ø°ØŒ Ø§Ù„Ø¯Ø±Ø³) Ù‚Ø¨Ù„ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù.',
        variant: 'destructive',
      });
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      return;
    }

    setIsLoading(true);
    onUploadStatusChange?.(true);

    try {
      const formData = new FormData();
      formData.append('file', file);
      if (parentFolderId) formData.append('parentFolderId', parentFolderId);
      formData.append('stage', stage);
      formData.append('subject', subject);
      formData.append('teacher', teacher);
      formData.append('lesson', lesson);

      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      const result = await response.json();

      if (!response.ok) {
        throw new Error(result.message || result.error || 'ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù');
      }
      
      const { fileId, fileName, fileUrl } = result.data;

      onChange({ fileId, fileName, fileUrl });
      
      toast({
        title: 'ØªÙ… Ø§Ù„Ø±ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­',
        description: `ØªÙ… Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù: ${fileName}`,
      });

    } catch (error: any) {
      console.error('File upload error:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù',
        variant: 'destructive',
      });
    } finally {
      setIsLoading(false);
      onUploadStatusChange?.(false);
      // Clear the file input for re-uploading the same file if needed
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleRemove = () => {
    onChange(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  return (
    <div className="space-y-2">
      <Label>{label}</Label>
      {description && (
        <p className="text-sm text-muted-foreground">{description}</p>
      )}

      {!value && (
        <div className="flex items-center justify-center w-full">
          <Label
            htmlFor={`file-upload-${label}`}
            className="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed rounded-lg cursor-pointer bg-muted hover:bg-muted/80 transition-colors"
          >
            {isLoading ? (
              <div className="flex flex-col items-center justify-center pt-5 pb-6">
                <Loader2 className="w-8 h-8 mb-4 text-muted-foreground animate-spin" />
                <p className="text-sm text-muted-foreground">Ø¬Ø§Ø±Ù Ø§Ù„Ø±ÙØ¹...</p>
              </div>
            ) : (
              <div className="flex flex-col items-center justify-center pt-5 pb-6">
                <UploadCloud className="w-8 h-8 mb-4 text-muted-foreground" />
                <p className="mb-2 text-sm text-muted-foreground">
                  <span className="font-semibold">Ø§Ù†Ù‚Ø± Ù„Ù„Ø±ÙØ¹</span> Ø£Ùˆ Ø§Ø³Ø­Ø¨ ÙˆØ£ÙÙ„Øª Ø§Ù„Ù…Ù„Ù
                </p>
                <p className="text-xs text-muted-foreground">
                  {`Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø³Ù…ÙˆØ­ Ø¨Ù‡Ø§: ${accept} (Ø­ØªÙ‰ ${maxSizeMB} Ù…ÙŠØ¬Ø§Ø¨Ø§ÙŠØª)`}
                </p>
              </div>
            )}
            <Input
              ref={fileInputRef}
              id={`file-upload-${label}`}
              type="file"
              className="hidden"
              accept={accept}
              onChange={handleFileChange}
              disabled={isLoading}
            />
          </Label>
        </div>
      )}

      {value && (
        <div className="space-y-2">
          <div className="flex items-center gap-2 p-3 border rounded-lg bg-muted">
              <FileIcon className="h-8 w-8 text-muted-foreground" />
              <div className="flex-1">
                <p className="text-sm font-medium">{value}</p>
                <p className="text-xs text-muted-foreground">ØªÙ… Ø§Ù„Ø±ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­</p>
              </div>
            </div>

          <div className="flex gap-2">
            <Button
              type="button"
              variant="destructive"
              size="sm"
              onClick={handleRemove}
              className="flex-1"
            >
              <X className="ml-2 h-4 w-4" />
              Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ù„Ù
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}


// ==========================================
// FILE: src/components/layout/NotificationBell.tsx
// ==========================================

'use client';

import { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { Bell } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Badge } from '@/components/ui/badge';
import { formatDistanceToNow } from 'date-fns';
import { ar } from 'date-fns/locale';

type Notification = {
  id: number;
  title: string;
  message: string;
  type: string;
  isRead: boolean;
  createdAt: string;
};

export default function NotificationBell() {
  const { data: session, status } = useSession();
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [isOpen, setIsOpen] = useState(false);

  const fetchNotifications = async () => {
    try {
      const response = await fetch('/api/notifications');
      
      // Check if response is OK before parsing
      if (!response.ok) {
        // If unauthorized or server error, just return silently
        if (response.status === 401 || response.status === 403) {
          return; // User not authenticated
        }
        console.error('Error fetching notifications: Server returned', response.status);
        return;
      }

      // Check if response is JSON
      const contentType = response.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        console.error('Error: Expected JSON response but got', contentType);
        return;
      }

      const result = await response.json();
      
      if (result.success) {
        setNotifications(result.data.notifications);
        setUnreadCount(result.data.unreadCount);
      }
    } catch (error) {
      // Only log errors that aren't authentication related
      if (error instanceof SyntaxError) {
        console.error('Invalid JSON response from notifications API');
      } else if (error instanceof TypeError && error.message.includes('fetch')) {
        // Network error - server might be down
        console.error('Network error: Could not connect to server');
      } else {
        console.error('Error fetching notifications:', error);
      }
    }
  };

  useEffect(() => {
    // Only fetch notifications if user is authenticated
    if (status !== 'authenticated') {
      return;
    }

    fetchNotifications();
    
    // Poll for new notifications every 30 seconds
    const interval = setInterval(fetchNotifications, 30000);
    
    return () => clearInterval(interval);
  }, [status]);

  const markAsRead = async (notificationId: number) => {
    try {
      const response = await fetch('/api/notifications', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ notificationId }),
      });
      
      if (!response.ok) {
        console.error('Error marking notification as read:', response.status);
        return;
      }

      // Check if response is JSON
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        await response.json(); // Parse but don't need to use result
      }
      
      fetchNotifications();
    } catch (error) {
      console.error('Error marking notification as read:', error);
    }
  };

  const markAllAsRead = async () => {
    try {
      const response = await fetch('/api/notifications', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ markAllAsRead: true }),
      });
      
      if (!response.ok) {
        console.error('Error marking all as read:', response.status);
        return;
      }

      // Check if response is JSON
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        await response.json(); // Parse but don't need to use result
      }
      
      fetchNotifications();
    } catch (error) {
      console.error('Error marking all as read:', error);
    }
  };

  // Don't render if user is not authenticated
  if (status !== 'authenticated') {
    return null;
  }

  return (
    <Popover open={isOpen} onOpenChange={setIsOpen}>
      <PopoverTrigger asChild>
        <Button variant="ghost" size="icon" className="relative">
          <Bell className="h-5 w-5" />
          {unreadCount > 0 && (
            <Badge
              variant="destructive"
              className="absolute -top-1 -right-1 h-5 w-5 flex items-center justify-center p-0 text-xs"
            >
              {unreadCount > 9 ? '9+' : unreadCount}
            </Badge>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80 p-0" align="end">
        <div className="flex items-center justify-between p-4 border-b">
          <h3 className="font-semibold">Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª</h3>
          {unreadCount > 0 && (
            <Button
              variant="ghost"
              size="sm"
              onClick={markAllAsRead}
              className="text-xs"
            >
              ØªØ¹Ù„ÙŠÙ… Ø§Ù„ÙƒÙ„ ÙƒÙ…Ù‚Ø±ÙˆØ¡
            </Button>
          )}
        </div>
        <ScrollArea className="h-[400px]">
          {notifications.length > 0 ? (
            <div className="divide-y">
              {notifications.map((notification) => (
                <div
                  key={notification.id}
                  className={`p-4 cursor-pointer hover:bg-muted/50 transition-colors ${
                    !notification.isRead ? 'bg-blue-50 dark:bg-blue-950' : ''
                  }`}
                  onClick={() => !notification.isRead && markAsRead(notification.id)}
                >
                  <div className="flex items-start justify-between gap-2">
                    <div className="flex-1">
                      <p className="font-medium text-sm">{notification.title}</p>
                      <p className="text-sm text-muted-foreground mt-1">
                        {notification.message}
                      </p>
                      <p className="text-xs text-muted-foreground mt-2">
                        {formatDistanceToNow(new Date(notification.createdAt), {
                          addSuffix: true,
                          locale: ar,
                        })}
                      </p>
                    </div>
                    {!notification.isRead && (
                      <div className="w-2 h-2 rounded-full bg-blue-500 mt-1" />
                    )}
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="p-8 text-center text-muted-foreground">
              <Bell className="h-12 w-12 mx-auto mb-2 opacity-20" />
              <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª</p>
            </div>
          )}
        </ScrollArea>
      </PopoverContent>
    </Popover>
  );
}


// ==========================================
// FILE: src/components/layout/SidebarNav.tsx
// ==========================================


"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import {
  LayoutDashboard,
  MessageSquare,
  UserCircle,
  School,
  BookCopy,
  Users,
  ClipboardCheck,
  Code2,
  FileQuestion,
  Library,
  TrendingUp,
  Award,
  LogOut,
  Shield,
  FileText,
  Bell,
  Contact,
  CheckCircle,
  XCircle,
  Clock,
  BarChart,
  Settings,
  Book,
  Repeat,
  Database,
  GraduationCap,
  HardDrive,
  ScrollText,
} from "lucide-react";

import {
  SidebarMenu,
  SidebarMenuItem,
  SidebarMenuButton,
  SidebarHeader,
  SidebarGroupLabel,
  SidebarFooter,
  SidebarSeparator
} from "@/components/ui/sidebar";
import { cn } from "@/lib/utils";
import { Badge } from "../ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "../ui/avatar";
import { useEffect, useState } from "react";
import { useSession } from "next-auth/react";

const studentNavItems = [
  { href: "/dashboard", icon: LayoutDashboard, label: "Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…" },
  { href: "/subjects", icon: Library, label: "Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©" },
  { href: "/dashboard/student/progress", icon: TrendingUp, label: "ØªÙ‚Ø¯Ù…ÙŠ" },
  { href: "/dashboard/student/results", icon: Award, label: "Ù†ØªØ§Ø¦Ø¬ÙŠ" },
  { href: "/profile", icon: Settings, label: "Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ" },
];

const teacherNavItems = [
  { href: "/dashboard/teacher", icon: LayoutDashboard, label: "Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…" },
  { href: "/dashboard/teacher/lessons", icon: BookCopy, label: "Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¯Ø±ÙˆØ³" },
  { href: "/dashboard/teacher/exercises", icon: FileQuestion, label: "Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†" },
  { href: "/dashboard/teacher/students", icon: Users, label: "ØªÙ„Ø§Ù…ÙŠØ°ÙŠ" },
  { href: "/dashboard/teacher/submissions", icon: ClipboardCheck, label: "ØªØµØ­ÙŠØ­ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†" },
  { href: "/messages", icon: MessageSquare, label: "Ø§Ù„Ø±Ø³Ø§Ø¦Ù„" },
  { href: "/profile", icon: Settings, label: "Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª" },
]

const parentNavItems = [
  { href: "/dashboard/parent", icon: LayoutDashboard, label: "Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…" },
  { href: "/dashboard/parent/children", icon: Users, label: "Ø£Ø¨Ù†Ø§Ø¦ÙŠ" },
  { href: "/dashboard/parent/reports", icon: FileText, label: "Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±" },
  { href: "/messages", icon: MessageSquare, label: "Ø§Ù„Ø±Ø³Ø§Ø¦Ù„" },
  { href: "/dashboard/parent/notifications", icon: Bell, label: "Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª" },
  { href: "/profile", icon: Settings, label: "Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ" },
];

const supervisorNavItems = [
  { href: "/dashboard/subject-supervisor", icon: LayoutDashboard, label: "Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…" },
  { href: "/dashboard/subject-supervisor/lessons", icon: Book, label: "Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¯Ø±ÙˆØ³"},
  { href: "/dashboard/subject-supervisor/exercises", icon: FileQuestion, label: "Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†"},
  { href: "/dashboard/subject-supervisor/statistics", icon: BarChart, label: "Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª" },
  { href: "/messages", icon: MessageSquare, label: "Ø§Ù„Ø±Ø³Ø§Ø¦Ù„" },
  { href: "/profile", icon: Settings, label: "Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª" },
];

const directeurNavItems = [
    { href: "/dashboard/directeur", icon: LayoutDashboard, label: "Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…" },
    { href: "/dashboard/directeur/users", icon: Users, label: "Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†" },
    { href: "/dashboard/directeur/content", icon: BookCopy, label: "Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­ØªÙˆÙ‰" },
    { href: "/dashboard/directeur/promotions", icon: GraduationCap, label: "Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ø³Ù†ÙˆÙŠØ©" },
    { href: "/dashboard/directeur/backup", icon: HardDrive, label: "Ø§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ" },
    { href: "/dashboard/directeur/logs", icon: ScrollText, label: "Ø³Ø¬Ù„Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…" },
    { href: "/messages", icon: MessageSquare, label: "Ø§Ù„Ø±Ø³Ø§Ø¦Ù„" },
    { href: "/dashboard/directeur/database", icon: Database, label: "Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª" },
    { href: "/dashboard/directeur/settings", icon: Settings, label: "Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª" },
];


const getNavItems = (role?: string, pathname?: string) => {
  if (pathname?.startsWith('/dashboard/teacher')) {
      return teacherNavItems;
  }
  switch (role) {
    case 'directeur':
        return directeurNavItems;
    case 'teacher':
      return teacherNavItems;
    case 'student':
      return studentNavItems;
    case 'parent':
      return parentNavItems;
    case 'supervisor_specific':
      return supervisorNavItems;
    default:
      return studentNavItems; // Default to student
  }
}

export function SidebarNav() {
  const pathname = usePathname();
  const { data: session } = useSession();
  const [user, setUser] = useState<any>(null);
  const [unreadCount, setUnreadCount] = useState(0);

  useEffect(() => {
    if (session?.user) {
      setUser(session.user);
    }
  }, [session]);

  useEffect(() => {
    // Fetch unread messages count
    const fetchUnreadCount = async () => {
      try {
        const response = await fetch('/api/messages/unread-count');
        const result = await response.json();
        if (result.success) {
          setUnreadCount(result.data.unreadCount);
        }
      } catch (error) {
        console.error('Error fetching unread count:', error);
      }
    };

    if (user) {
      fetchUnreadCount();
      // Poll every 30 seconds
      const interval = setInterval(fetchUnreadCount, 30000);
      return () => clearInterval(interval);
    }
  }, [user]);
  
  useEffect(() => {
    // This is a hack for the prototype to persist the "context"
    // of which dashboard the user is in.
    // Only run on client-side after mount
    if (typeof window === 'undefined') return;
    
    try {
        if (pathname.startsWith('/dashboard/directeur')) {
            sessionStorage.setItem('currentRolePath', '/dashboard/directeur');
        } else if (pathname.startsWith('/dashboard/subject-supervisor')) {
            sessionStorage.setItem('currentRolePath', '/dashboard/subject-supervisor');
        } else if (pathname.startsWith('/dashboard/teacher')) {
            // Don't overwrite if the origin is supervisor
            const currentRole = sessionStorage.getItem('currentRolePath');
            if (!currentRole || !currentRole.startsWith('/dashboard/subject-supervisor')) {
                sessionStorage.setItem('currentRolePath', '/dashboard/teacher');
            }
        } else if (pathname.startsWith('/dashboard/parent')) {
            sessionStorage.setItem('currentRolePath', '/dashboard/parent');
        } else if (pathname.startsWith('/dashboard/student') || pathname === '/dashboard') {
             sessionStorage.setItem('currentRolePath', '/dashboard/student');
        }
    } catch (error) {
        // Silently fail if sessionStorage is not available
        console.error('sessionStorage not available:', error);
    }
  }, [pathname]);

  const navItems = getNavItems(user?.role, pathname);

  const getIsActive = (href: string) => {
    // Special handling for dashboards
    if (href.endsWith('dashboard')) {
        const dashboardPaths = ['/dashboard', '/dashboard/student', '/dashboard/teacher', '/dashboard/parent', '/dashboard/subject-supervisor', '/dashboard/directeur'];
        const isDashboard = dashboardPaths.some(p => pathname.startsWith(p) && p.length >= pathname.length)
        if (isDashboard) return true;
    }
    
    // For nested routes, check if the pathname starts with the href
    if (href !== '/' && href.length > 1) {
      return pathname.startsWith(href);
    }
    
    return pathname === href;
  }

  if (!user) {
    return null;
  }
  
  const roleName = (user: any) => {
    if (!user?.role) return 'Ù…Ø³ØªØ®Ø¯Ù…';
    if (user.role === 'supervisor_specific' && pathname.startsWith('/dashboard/teacher')) {
        return 'Ù…Ø¹Ù„Ù… (Ù…Ø´Ø±Ù)';
    }
    return {
        directeur: 'Ù…Ø¯ÙŠØ±',
        teacher: 'Ù…Ø¹Ù„Ù…',
        student: 'Ø·Ø§Ù„Ø¨',
        parent: 'ÙˆÙ„ÙŠ Ø£Ù…Ø±',
        supervisor_specific: 'Ù…Ø´Ø±Ù Ù…Ø§Ø¯Ø©'
    }[user.role] || 'Ù…Ø³ØªØ®Ø¯Ù…';
  }


  return (
    <>
      <div className="flex-1 overflow-y-auto p-2">
          <SidebarHeader className="border-b border-sidebar-border">
            <div className="flex items-center gap-2">
              <School className="h-8 w-8 text-sidebar-primary-foreground" />
              <div className="flex flex-col">
                <h2 className="text-lg font-semibold text-sidebar-primary-foreground">
                  SmartEdu
                </h2>
                <Badge variant="secondary" className="w-fit">{roleName(user)}</Badge>
              </div>
            </div>
          </SidebarHeader>

          <SidebarMenu>
              <SidebarGroupLabel>Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</SidebarGroupLabel>
              {navItems.map((item) => (
              <SidebarMenuItem key={item.href}>
                  <Link href={item.href} passHref>
                    <SidebarMenuButton
                        asChild
                        isActive={getIsActive(item.href)}
                        className="justify-start"
                    >
                      <div className="flex items-center justify-between w-full">
                        <div className="flex items-center">
                          <item.icon className="ml-2 h-5 w-5" />
                          <span>{item.label}</span>
                        </div>
                        {item.href === '/messages' && unreadCount > 0 && (
                          <Badge variant="destructive" className="h-5 min-w-5 flex items-center justify-center px-1.5 text-xs">
                            {unreadCount > 99 ? '99+' : unreadCount}
                          </Badge>
                        )}
                      </div>
                    </SidebarMenuButton>
                  </Link>
              </SidebarMenuItem>
              ))}

              {user.role === 'supervisor_specific' && (
                <>
                    <SidebarSeparator />
                     <SidebarMenuItem>
                        {pathname.startsWith('/dashboard/teacher') ? (
                             <Link href="/dashboard/subject-supervisor" passHref>
                                <SidebarMenuButton className="justify-start">
                                    <div>
                                        <Repeat className="ml-2 h-5 w-5" />
                                        <span>Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø´Ø±Ù</span>
                                    </div>
                                </SidebarMenuButton>
                            </Link>
                        ) : (
                             <Link href="/dashboard/teacher" passHref>
                                <SidebarMenuButton className="justify-start">
                                    <div>
                                        <Repeat className="ml-2 h-5 w-5" />
                                        <span>Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø¹Ù„Ù…</span>
                                    </div>
                                </SidebarMenuButton>
                            </Link>
                        )}
                    </SidebarMenuItem>
                </>
              )}
          </SidebarMenu>
      </div>
      
      <SidebarFooter className="border-t border-sidebar-border p-2 space-y-2">
          <div className="p-2 flex items-center gap-3">
              <Avatar className="h-10 w-10">
                <AvatarFallback>{user?.name?.charAt(0) || 'U'}</AvatarFallback>
              </Avatar>
              <div className="flex flex-col truncate">
                  <span className="font-semibold text-sidebar-primary-foreground text-sm">{user?.name}</span>
                  <span className="text-xs text-sidebar-foreground/70 truncate">{user?.email}</span>
              </div>
          </div>
          <SidebarMenuItem>
              <Link href="/login" passHref>
                <SidebarMenuButton className="justify-start">
                    <div>
                        <LogOut className="ml-2 h-5 w-5" />
                        <span>ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬</span>
                    </div>
                </SidebarMenuButton>
              </Link>
          </SidebarMenuItem>
      </SidebarFooter>
    </>
  );
}


// ==========================================
// FILE: src/components/layout/UserNav.tsx
// ==========================================


"use client";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { LogOut, User } from "lucide-react";
import Link from "next/link";
import { useSession, signOut } from "next-auth/react";

export function UserNav() {
  const { data: session } = useSession();
  const user = session?.user;


  if (!user) {
    return null;
  }

  const fallback = user.name.substring(0, 2).toUpperCase();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="relative h-10 w-10 rounded-full">
          <Avatar className="h-10 w-10">
            <AvatarImage src={user.avatar} alt={user.name} />
            <AvatarFallback>{fallback}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent className="w-56" align="end" forceMount>
        <DropdownMenuLabel className="font-normal">
          <div className="flex flex-col space-y-1">
            <p className="text-sm font-medium leading-none">{user.name}</p>
            <p className="text-xs leading-none text-muted-foreground">
              {user.email}
            </p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator />
        <DropdownMenuGroup>
          <Link href="/profile">
            <DropdownMenuItem>
              <User className="mr-2 h-4 w-4" />
              <span>Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ</span>
            </DropdownMenuItem>
          </Link>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />
        <DropdownMenuItem onClick={() => signOut({ callbackUrl: '/login' })}>
          <LogOut className="mr-2 h-4 w-4" />
          <span>ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}


// ==========================================
// FILE: src/components/layout/Header.tsx
// ==========================================

import { SidebarTrigger } from "@/components/ui/sidebar";
import { UserNav } from "@/components/layout/UserNav";
import NotificationBell from "@/components/layout/NotificationBell";

export function Header() {
  return (
    <header className="sticky top-0 z-10 flex h-16 items-center gap-4 border-b bg-background/80 px-4 backdrop-blur-sm md:px-6">
      <div className="md:hidden">
        <SidebarTrigger />
      </div>
      <div className="flex w-full items-center justify-end gap-2">
        <NotificationBell />
        <UserNav />
      </div>
    </header>
  );
}


// ==========================================
// FILE: src/components/PromotionResponse.tsx
// ==========================================

'use client';

import { useState } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import {
  AlertDialog,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { CheckCircle, XCircle } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import Confetti from 'react-confetti';
import { useWindowSize } from '@/hooks/use-window-size';

interface PromotionResponseProps {
  messageId: number;
  promotionId: string;
  studentName: string;
  currentLevel: string;
  nextLevel: string;
  onResponse?: () => void;
}

export default function PromotionResponse({
  messageId,
  promotionId,
  studentName,
  currentLevel,
  nextLevel,
  onResponse
}: PromotionResponseProps) {
  console.log('ğŸ”µ PromotionResponse component rendered');
  console.log('Props:', { messageId, promotionId, studentName, currentLevel, nextLevel });
  
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [response, setResponse] = useState<'yes' | 'no' | null>(null);
  const [submitting, setSubmitting] = useState(false);
  const [showCelebration, setShowCelebration] = useState(false);
  const [showEncouragement, setShowEncouragement] = useState(false);
  const [showConfetti, setShowConfetti] = useState(false);

  const { toast } = useToast();
  const { width, height } = useWindowSize();

  const handleResponseClick = (responseType: 'yes' | 'no') => {
    console.log('=== handleResponseClick ===');
    console.log('Response type:', responseType);
    console.log('Promotion ID:', promotionId);
    console.log('Message ID:', messageId);
    setResponse(responseType);
    setShowConfirmDialog(true);
    console.log('Confirmation dialog opened - state set to TRUE');
    console.log('showConfirmDialog will be:', true);
    
    // Force re-render after 100ms to ensure state is updated
    setTimeout(() => {
      console.log('After timeout - showConfirmDialog is:', showConfirmDialog);
    }, 100);
  };

  const submitResponse = async () => {
    console.log('ğŸ”´ submitResponse function called!');
    console.log('Response state:', response);
    
    if (!response) {
      console.log('âŒ No response set, returning early');
      return;
    }

    console.log('=== Submitting Response ===');
    console.log('Promotion ID:', promotionId);
    console.log('Response:', response);

    try {
      setSubmitting(true);
      const res = await fetch('/api/academic-years/promotions/respond', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          promotionId,
          response
        })
      });

      console.log('API Response status:', res.status);
      const data = await res.json();
      console.log('API Response data:', data);

      if (res.ok) {
        setShowConfirmDialog(false);
        
        if (data.isApproved) {
          console.log('âœ… Approved - showing celebration');
          setShowConfetti(true);
          setShowCelebration(true);
          setTimeout(() => setShowConfetti(false), 5000);
        } else {
          console.log('âŒ Rejected - showing encouragement');
          setShowEncouragement(true);
        }

        toast({
          title: 'ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­',
          description: data.message,
        });

        if (onResponse) {
          console.log('Calling onResponse callback in 3 seconds...');
          setTimeout(() => {
            console.log('Executing onResponse callback');
            onResponse();
          }, 3000);
        }
      } else {
        console.error('API Error:', data);
        throw new Error(data.error);
      }
    } catch (error: any) {
      console.error('Submit error:', error);
      toast({
        title: 'Ø®Ø·Ø£',
        description: error.message || 'ÙØ´Ù„ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø¯',
        variant: 'destructive'
      });
    } finally {
      setSubmitting(false);
    }
  };

  if (showCelebration) {
    return (
      <>
        {showConfetti && <Confetti width={width} height={height} recycle={false} numberOfPieces={500} />}
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 animate-in fade-in">
          <Card className="max-w-2xl w-full mx-4 border-4 border-green-500 bg-gradient-to-br from-green-50 to-emerald-50">
            <CardContent className="p-12 text-center space-y-8">
              <div className="relative">
                <div className="absolute inset-0 animate-ping opacity-20">
                  <div className="w-32 h-32 mx-auto bg-green-500 rounded-full"></div>
                </div>
                <div className="relative animate-bounce">
                  <div className="w-32 h-32 mx-auto bg-gradient-to-br from-green-400 to-emerald-600 rounded-full flex items-center justify-center shadow-2xl">
                    <CheckCircle className="h-20 w-20 text-white" />
                  </div>
                </div>
              </div>

              <div className="space-y-4">
                <h2 className="text-5xl font-bold text-green-600 animate-in zoom-in" style={{ animationDelay: '0.2s' }}>
                  ğŸ‰ Ø£Ù„Ù Ù…Ø¨Ø±ÙˆÙƒ! ğŸ‰
                </h2>
                <div className="text-2xl font-semibold text-gray-800 animate-in slide-in-from-bottom" style={{ animationDelay: '0.4s' }}>
                  ØªÙ… ØªØ±Ù‚ÙŠØ© <span className="text-green-600">{studentName}</span>
                </div>
                <div className="text-xl text-gray-700 animate-in slide-in-from-bottom" style={{ animationDelay: '0.6s' }}>
                  Ù…Ù† <span className="font-bold">{currentLevel}</span>
                  {' â†’ '}
                  <span className="font-bold text-green-600">{nextLevel}</span>
                </div>
              </div>

              <div className="space-y-4 animate-in slide-in-from-bottom" style={{ animationDelay: '0.8s' }}>
                <div className="text-3xl">ğŸ† ğŸ“ â­ ğŸŒŸ âœ¨</div>
                <p className="text-lg text-gray-600 leading-relaxed">
                  ØªÙ‡Ø§Ù†ÙŠÙ†Ø§ Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² Ø§Ù„Ø±Ø§Ø¦Ø¹!<br />
                  Ù†ØªÙ…Ù†Ù‰ Ù„ÙƒÙ… Ø§Ù„ØªÙˆÙÙŠÙ‚ ÙˆØ§Ù„Ù†Ø¬Ø§Ø­ ÙÙŠ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù‚Ø§Ø¯Ù… Ø¨Ø¥Ø°Ù† Ø§Ù„Ù„Ù‡
                </p>
              </div>

              <Button 
                size="lg" 
                className="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white px-8 py-6 text-lg shadow-xl animate-in zoom-in"
                style={{ animationDelay: '1s' }}
                onClick={() => {
                  setShowCelebration(false);
                  if (onResponse) onResponse();
                }}
              >
                Ø´ÙƒØ±Ø§Ù‹ Ù„ÙƒÙ…! ğŸ’š
              </Button>
            </CardContent>
          </Card>
        </div>
      </>
    );
  }

  if (showEncouragement) {
    return (
      <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 animate-in fade-in">
        <Card className="max-w-2xl w-full mx-4 border-4 border-blue-500 bg-gradient-to-br from-blue-50 to-cyan-50">
          <CardContent className="p-12 text-center space-y-8">
            <div className="relative">
              <div className="absolute inset-0 animate-pulse opacity-20">
                <div className="w-32 h-32 mx-auto bg-blue-500 rounded-full"></div>
              </div>
              <div className="relative animate-bounce">
                <div className="w-32 h-32 mx-auto bg-gradient-to-br from-blue-400 to-cyan-600 rounded-full flex items-center justify-center shadow-2xl">
                  <span className="text-7xl">ğŸ’ª</span>
                </div>
              </div>
            </div>

            <div className="space-y-4">
              <h2 className="text-5xl font-bold text-blue-600 animate-in zoom-in" style={{ animationDelay: '0.2s' }}>
                Ù„Ø§ ØªÙŠØ£Ø³! 
              </h2>
              <div className="text-2xl font-semibold text-gray-800 animate-in slide-in-from-bottom" style={{ animationDelay: '0.4s' }}>
                {studentName}
              </div>
              <div className="text-xl text-gray-700 animate-in slide-in-from-bottom" style={{ animationDelay: '0.6s' }}>
                Ø³ÙŠÙˆØ§ØµÙ„ ÙÙŠ <span className="font-bold text-blue-600">{currentLevel}</span>
              </div>
            </div>

            <div className="space-y-4 animate-in slide-in-from-bottom" style={{ animationDelay: '0.8s' }}>
              <div className="text-3xl">ğŸŒ… ğŸ“š ğŸ¯ âš¡ ğŸ’«</div>
              <p className="text-lg text-gray-700 leading-relaxed bg-white/80 p-6 rounded-lg shadow-inner">
                <strong>Ù„Ø§ ØªÙ‚Ù„Ù‚!</strong><br />
                Ø³ØªÙƒÙˆÙ† Ø§Ù„Ø³Ù†Ø© Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© Ø£ÙØ¶Ù„ Ø¨Ø¥Ø°Ù† Ø§Ù„Ù„Ù‡<br />
                <br />
                <span className="text-blue-600 font-semibold">
                  Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„ØªØ¹Ù„Ù… ÙˆØ§Ù„ØªØ­Ø³Ù†ØŒ ÙˆØ§Ù„Ù†Ø¬Ø§Ø­ ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø±Ùƒ! 
                </span>
                <br />
                <br />
                ØªØ°ÙƒØ±: ÙƒÙ„ ØªØ¬Ø±Ø¨Ø© Ù‡ÙŠ ÙØ±ØµØ© Ù„Ù„ØªØ¹Ù„Ù… ÙˆØ§Ù„Ù†Ù…Ùˆ ğŸŒ±
              </p>
            </div>

            <Button 
              size="lg" 
              className="bg-gradient-to-r from-blue-500 to-cyan-600 hover:from-blue-600 hover:to-cyan-700 text-white px-8 py-6 text-lg shadow-xl animate-in zoom-in"
              style={{ animationDelay: '1s' }}
              onClick={() => {
                setShowEncouragement(false);
                if (onResponse) onResponse();
              }}
            >
              Ù†Ø¹Ù…ØŒ Ø³Ù†Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰! ğŸ’™
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <>
      <Card className="border-2 border-primary bg-gradient-to-br from-blue-50 to-indigo-50">
        <CardContent className="p-8 space-y-6">
          <div className="text-center space-y-4">
            <div className="text-4xl mb-4">ğŸ“</div>
            <h3 className="text-2xl font-bold text-gray-800">
              Ø§Ø³ØªÙØ³Ø§Ø± Ø¹Ù† Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø·Ø§Ù„Ø¨
            </h3>
            <div className="bg-white p-6 rounded-lg shadow-md space-y-3">
              <p className="text-lg">
                <strong>Ø§Ù„Ø·Ø§Ù„Ø¨/Ø©:</strong> <span className="text-blue-600">{studentName}</span>
              </p>
              <p className="text-lg">
                <strong>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ:</strong> <span className="text-gray-700">{currentLevel}</span>
              </p>
              <p className="text-lg">
                <strong>Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ:</strong> <span className="text-green-600">{nextLevel}</span>
              </p>
            </div>
          </div>

          <div className="bg-blue-100 border-2 border-blue-300 rounded-lg p-6">
            <p className="text-xl font-semibold text-center text-blue-800">
              ğŸ“ Ù‡Ù„ Ù†Ø¬Ø­/Øª {studentName} ÙÙŠ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¥Ù„Ù‰ {nextLevel}ØŸ
            </p>
          </div>

          <div className="grid grid-cols-2 gap-4 pt-4">
            <Button
              size="lg"
              className="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white h-20 text-xl shadow-lg"
              onClick={() => handleResponseClick('yes')}
            >
              <CheckCircle className="h-6 w-6 ml-2" />
              Ù†Ø¹Ù…ØŒ Ù†Ø¬Ø­ âœ“
            </Button>
            <Button
              size="lg"
              variant="outline"
              className="border-2 border-gray-400 hover:bg-gray-100 h-20 text-xl shadow-lg"
              onClick={() => handleResponseClick('no')}
            >
              <XCircle className="h-6 w-6 ml-2" />
              Ù„Ø§ØŒ Ù„Ù… ÙŠÙ†Ø¬Ø­
            </Button>
          </div>

          <p className="text-sm text-center text-muted-foreground">
            ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¨ØµØ¯Ù‚ Ù„ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
          </p>
        </CardContent>
      </Card>

      {/* Debug: show dialog state */}
      <div className="fixed top-4 right-4 bg-red-500 text-white p-2 rounded z-[10001]">
        Dialog State: {showConfirmDialog ? 'OPEN' : 'CLOSED'}
      </div>

      <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}>
        <AlertDialogContent className="z-[10000] max-w-2xl">
          <AlertDialogHeader>
            <AlertDialogTitle className="text-right text-2xl">
              {response === 'yes' ? 'âœ… ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù†Ø¬Ø§Ø­' : 'âŒ ØªØ£ÙƒÙŠØ¯ Ø¹Ø¯Ù… Ø§Ù„Ù†Ø¬Ø§Ø­'}
            </AlertDialogTitle>
            <AlertDialogDescription className="text-right">
              <span className="block text-lg mb-3">
                Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† <strong>{studentName}</strong>
                {response === 'yes' 
                  ? ' Ù‚Ø¯ Ù†Ø¬Ø­ ÙˆØ³ÙŠÙ†ØªÙ‚Ù„ Ø¥Ù„Ù‰ ' + nextLevel 
                  : ' Ù„Ù… ÙŠÙ†Ø¬Ø­ ÙˆØ³ÙŠØ¹ÙŠØ¯ ' + currentLevel}
                ØŸ
              </span>
            </AlertDialogDescription>
            {response === 'yes' ? (
              <div className="bg-green-50 p-4 rounded-lg border border-green-200 text-right">
                <span className="text-green-800 block">
                  âœ“ Ø³ÙŠØªÙ… ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø·Ø§Ù„Ø¨ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¬Ø¯ÙŠØ¯<br />
                  âœ“ Ø³ÙŠØªÙ„Ù‚Ù‰ Ø§Ù„Ø·Ø§Ù„Ø¨ Ø±Ø³Ø§Ù„Ø© ØªÙ‡Ù†Ø¦Ø©
                </span>
              </div>
            ) : (
              <div className="bg-blue-50 p-4 rounded-lg border border-blue-200 text-right">
                <span className="text-blue-800 block">
                  â€¢ Ø³ÙŠØ¨Ù‚Ù‰ Ø§Ù„Ø·Ø§Ù„Ø¨ ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªÙˆÙ‰<br />
                  â€¢ Ø³ÙŠØªÙ„Ù‚Ù‰ Ø§Ù„Ø·Ø§Ù„Ø¨ Ø±Ø³Ø§Ù„Ø© ØªØ´Ø¬ÙŠØ¹ÙŠØ©
                </span>
              </div>
            )}
          </AlertDialogHeader>
          <AlertDialogFooter className="gap-2">
            <AlertDialogCancel disabled={submitting}>Ø¥Ù„ØºØ§Ø¡</AlertDialogCancel>
            <Button 
              onClick={() => {
                console.log('ğŸŸ¢ Button clicked!');
                submitResponse();
              }} 
              disabled={submitting}
              className="bg-primary text-primary-foreground hover:bg-primary/90"
            >
              {submitting ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...' : 'Ù†Ø¹Ù…ØŒ ØªØ£ÙƒÙŠØ¯'}
            </Button>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}


// ==========================================
// FILE: prisma/check-stages.ts
// ==========================================

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...\n');

  const stages = await prisma.stage.findMany({
    orderBy: { displayOrder: 'asc' },
  });

  console.log(`ğŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©: ${stages.length}\n`);

  if (stages.length > 0) {
    console.log('âœ… Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©:');
    stages.forEach((stage, index) => {
      console.log(`${index + 1}. ID: ${stage.id}, Ø§Ù„Ø§Ø³Ù…: "${stage.name}", Ø§Ù„ØªØ±ØªÙŠØ¨: ${stage.displayOrder}`);
    });
  } else {
    console.log('âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø±Ø§Ø­Ù„ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!');
  }

  console.log('\n-----------------------------------\n');

  // Check levels
  const levels = await prisma.level.findMany({
    orderBy: { displayOrder: 'asc' },
  });
  console.log(`ğŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©: ${levels.length}`);

  // Check subjects
  const subjects = await prisma.subject.findMany();
  console.log(`ğŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©: ${subjects.length}`);

  // Check users
  const users = await prisma.user.findMany();
  console.log(`ğŸ“Š Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ÙŠÙ†: ${users.length}`);
}

main()
  .catch((e) => {
    console.error('âŒ Ø®Ø·Ø£:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ==========================================
// FILE: prisma/verify-drive-structure.ts
// ==========================================

import 'dotenv/config';
import { PrismaClient } from '@prisma/client';
import { google } from 'googleapis';
import path from 'path';
import fs from 'fs';

const prisma = new PrismaClient();

async function getDriveClient() {
  let credentialsPath = process.env.GOOGLE_APPLICATION_CREDENTIALS;
  if (!credentialsPath) {
    const defaultPath = 'service-account.json';
    if (fs.existsSync(path.resolve(process.cwd(), defaultPath))) {
      credentialsPath = defaultPath;
    }
  }
  
  if (!credentialsPath) throw new Error("No credentials found");

  const auth = new google.auth.GoogleAuth({
    keyFile: path.resolve(process.cwd(), credentialsPath),
    scopes: ['https://www.googleapis.com/auth/drive'],
  });

  return google.drive({ version: 'v3', auth });
}

async function verifyFolderExists(drive: any, folderId: string, label: string) {
  try {
    const res = await drive.files.get({
      fileId: folderId,
      fields: 'id, name, parents, trashed, webViewLink',
      supportsAllDrives: true,
    });
    
    if (res.data.trashed) {
      console.error(`âŒ ${label}: Folder "${res.data.name}" is in trash!`);
      return null;
    }
    console.log(`âœ… ${label}: Found "${res.data.name}"`);
    console.log(`   ID: ${folderId}`);
    console.log(`   Link: ${res.data.webViewLink}`);
    return res.data;
  } catch (e: any) {
    console.error(`âŒ ${label}: Failed to find folder (${folderId}): ${e.message}`);
    return null;
  }
}

async function main() {
  const drive = await getDriveClient();
  
  console.log("ğŸ” Starting Deep Verification of Drive Hierarchy...\n");

  // 1. Get the most recently created Exercise that has a Drive Folder
  const exercise = await prisma.exercise.findFirst({
    where: { driveFolderId: { not: null } },
    include: {
      lesson: {
        include: {
          subject: true,
          author: true
        }
      }
    },
    orderBy: { id: 'desc' }
  });

  if (!exercise) {
    console.log("âš ï¸ No exercises with Drive folders found to verify.");
    return;
  }

  console.log(`Testing Hierarchy for Latest Exercise ID: ${exercise.id}`);
  console.log(`Context: Lesson "${exercise.lesson.title}" by ${exercise.lesson.author.firstName}\n`);

  // 2. Verify Exercise Folder
  const exerciseFolder = await verifyFolderExists(drive, exercise.driveFolderId!, "Exercise Folder");
  
  // 3. Verify Lesson Folder
  if (exercise.lesson.driveFolderId) {
    const lessonFolder = await verifyFolderExists(drive, exercise.lesson.driveFolderId, "Lesson Folder");
    
    // Check if Exercise is inside Lesson
    if (exerciseFolder && lessonFolder) {
      if (exerciseFolder.parents?.includes(lessonFolder.id)) {
        console.log(`   ğŸ”— LINK VERIFIED: Exercise is inside Lesson.`);
      } else {
        console.error(`   âŒ LINK BROKEN: Exercise is NOT inside Lesson folder!`);
      }
    }

    // 4. Verify Teacher Folder (Parent of Lesson)
    if (lessonFolder && lessonFolder.parents && lessonFolder.parents.length > 0) {
        const parentId = lessonFolder.parents[0];
        const teacherFolder = await verifyFolderExists(drive, parentId, "Teacher Folder (in Subject)");
        
        // 5. Verify Subject Folder (Parent of Teacher Folder)
        if (teacherFolder && teacherFolder.parents && teacherFolder.parents.length > 0) {
             const subjectId = teacherFolder.parents[0];
             // Check if this matches the subject ID in DB
             if (subjectId === exercise.lesson.subject.driveFolderId) {
                 console.log(`   ğŸ”— LINK VERIFIED: Teacher folder is inside correct Subject folder.`);
             } else {
                 console.log(`   â„¹ï¸ Teacher folder parent ID: ${subjectId}`);
             }
        }
    }
  }

  console.log("\nâœ… Verification Logic Complete.");
}

main().catch(e => console.error(e)).finally(async () => await prisma.$disconnect());

// ==========================================
// FILE: prisma/seed-users.ts
// ==========================================

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸŒ± Ø¨Ø¯Ø¡ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...');

  // Hash password
  const hashedPassword = await bcrypt.hash('password123', 10);

  // Get role IDs
  const directeurRole = await prisma.role.findUnique({ where: { name: 'directeur' } });
  const teacherRole = await prisma.role.findUnique({ where: { name: 'teacher' } });
  const studentRole = await prisma.role.findUnique({ where: { name: 'student' } });
  const parentRole = await prisma.role.findUnique({ where: { name: 'parent' } });

  if (!directeurRole || !teacherRole || !studentRole || !parentRole) {
    throw new Error('Ø§Ù„Ø£Ø¯ÙˆØ§Ø± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!');
  }

  // Create Director
  const director = await prisma.user.upsert({
    where: { email: 'Lakhdar.director@sep.com' },
    update: {},
    create: {
      email: 'Lakhdar.director@sep.com',
      firstName: 'Lakhdar',
      lastName: 'Ben Director',
      password: hashedPassword,
      roleId: directeurRole.id,
    },
  });
  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¯ÙŠØ±:', director.email);

  // Create Teacher
  const teacher = await prisma.user.upsert({
    where: { email: 'ahmed.teacher@example.com' },
    update: {},
    create: {
      email: 'ahmed.teacher@example.com',
      firstName: 'Ahmed',
      lastName: 'Mahmoud',
      password: hashedPassword,
      roleId: teacherRole.id,
    },
  });
  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¹Ù„Ù…:', teacher.email);

  // Create Student
  const student = await prisma.user.upsert({
    where: { email: 'fatima.student@example.com' },
    update: {},
    create: {
      email: 'fatima.student@example.com',
      firstName: 'Fatima',
      lastName: 'Al-Ghamdi',
      password: hashedPassword,
      roleId: studentRole.id,
    },
  });
  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø·Ø§Ù„Ø¨:', student.email);

  // Create Parent
  const parent = await prisma.user.upsert({
    where: { email: 'khalid.parent@example.com' },
    update: {},
    create: {
      email: 'khalid.parent@example.com',
      firstName: 'Khalid',
      lastName: 'Al-Ghamdi',
      password: hashedPassword,
      roleId: parentRole.id,
    },
  });
  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±:', parent.email);

  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­!');
  console.log('\nğŸ“‹ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:');
  console.log('Ø§Ù„Ù…Ø¯ÙŠØ±: Lakhdar.director@sep.com / password123');
  console.log('Ø§Ù„Ù…Ø¹Ù„Ù…: ahmed.teacher@example.com / password123');
  console.log('Ø§Ù„Ø·Ø§Ù„Ø¨: fatima.student@example.com / password123');
  console.log('ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±: khalid.parent@example.com / password123');
}

main()
  .catch((e) => {
    console.error('âŒ Ø®Ø·Ø£:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ==========================================
// FILE: prisma/seed-lessons.ts
// ==========================================

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸŒ± Ø¨Ø¯Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø¯Ø±ÙˆØ³ ÙˆØªÙ…Ø§Ø±ÙŠÙ† ØªØ¬Ø±ÙŠØ¨ÙŠØ©...');

  try {
    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¹Ù„Ù…
    const teacher = await prisma.user.findFirst({
      where: { 
        role: {
          name: 'teacher'
        }
      },
    });

    if (!teacher) {
      console.error('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ù„Ù…');
      return;
    }

    // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙˆØ§Ø¯ ÙˆÙ…Ø³ØªÙˆÙŠØ§Øª
    const mathSubject = await prisma.subject.findFirst({
      where: { name: 'Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª' },
    });

    const arabicSubject = await prisma.subject.findFirst({
      where: { name: 'Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©' },
    });

    const level = await prisma.level.findFirst({
      where: { name: { contains: 'Ø§Ù„ØµÙ 1' } },
    });

    if (!mathSubject || !arabicSubject || !level) {
      console.error('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø£Ùˆ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª');
      return;
    }

    console.log('ğŸ“š Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¯Ø±ÙˆØ³...');

    // Ø¯Ø±Ø³ 1: Ø§Ù„Ø¬Ù…Ø¹
    const lesson1 = await prisma.lesson.create({
      data: {
        title: 'Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¬Ù…Ø¹',
        content: `
# Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø¬Ù…Ø¹

## Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø¬Ù…Ø¹ØŸ
Ø§Ù„Ø¬Ù…Ø¹ Ù‡Ùˆ Ø¹Ù…Ù„ÙŠØ© Ø­Ø³Ø§Ø¨ÙŠØ© Ù†Ø³ØªØ®Ø¯Ù…Ù‡Ø§ Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„ÙƒÙ„ÙŠ Ù„Ø¹Ø¯Ø¯ÙŠÙ† Ø£Ùˆ Ø£ÙƒØ«Ø±.

## Ø§Ù„Ø±Ù…Ø²
Ù†Ø³ØªØ®Ø¯Ù… Ø±Ù…Ø² (+) Ù„Ù„Ø¬Ù…Ø¹

## Ø£Ù…Ø«Ù„Ø©:
- 2 + 3 = 5
- 5 + 4 = 9
- 10 + 15 = 25

## Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¬Ù…Ø¹:
1. Ø§Ù„Ø¬Ù…Ø¹ ØªØ¨Ø¯ÙŠÙ„ÙŠ: 3 + 5 = 5 + 3
2. Ø§Ù„Ø¬Ù…Ø¹ ØªØ¬Ù…ÙŠØ¹ÙŠ: (2 + 3) + 4 = 2 + (3 + 4)
        `,
        videoUrl: 'https://www.youtube.com/watch?v=example1',
        subjectId: mathSubject.id,
        levelId: level.id,
        authorId: teacher.id,
        type: 'public',
        status: 'approved',
      },
    });

    // Ø¯Ø±Ø³ 2: Ø§Ù„Ø·Ø±Ø­
    const lesson2 = await prisma.lesson.create({
      data: {
        title: 'Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø·Ø±Ø­',
        content: `
# Ù…Ù‚Ø¯Ù…Ø© ÙÙŠ Ø§Ù„Ø·Ø±Ø­

## Ù…Ø§ Ù‡Ùˆ Ø§Ù„Ø·Ø±Ø­ØŸ
Ø§Ù„Ø·Ø±Ø­ Ù‡Ùˆ Ø¹Ù…Ù„ÙŠØ© Ø­Ø³Ø§Ø¨ÙŠØ© Ù†Ø³ØªØ®Ø¯Ù…Ù‡Ø§ Ù„Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„ÙØ±Ù‚ Ø¨ÙŠÙ† Ø¹Ø¯Ø¯ÙŠÙ†.

## Ø§Ù„Ø±Ù…Ø²
Ù†Ø³ØªØ®Ø¯Ù… Ø±Ù…Ø² (-) Ù„Ù„Ø·Ø±Ø­

## Ø£Ù…Ø«Ù„Ø©:
- 5 - 2 = 3
- 10 - 4 = 6
- 20 - 8 = 12

## Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø·Ø±Ø­:
1. Ø§Ù„Ø·Ø±Ø­ Ù„ÙŠØ³ ØªØ¨Ø¯ÙŠÙ„ÙŠØ§Ù‹: 5 - 3 â‰  3 - 5
2. Ø·Ø±Ø­ Ø§Ù„ØµÙØ± Ù„Ø§ ÙŠØºÙŠØ± Ø§Ù„Ø¹Ø¯Ø¯: 5 - 0 = 5
        `,
        subjectId: mathSubject.id,
        levelId: level.id,
        authorId: teacher.id,
        type: 'public',
        status: 'approved',
      },
    });

    // Ø¯Ø±Ø³ 3: Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
    const lesson3 = await prisma.lesson.create({
      data: {
        title: 'Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ù‡Ø¬Ø§Ø¦ÙŠØ©',
        content: `
# Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ù‡Ø¬Ø§Ø¦ÙŠØ©

## Ø§Ù„Ø­Ø±ÙˆÙ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©
Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ 28 Ø­Ø±ÙØ§Ù‹

## Ø§Ù„Ø­Ø±ÙˆÙ:
Ø£ - Ø¨ - Øª - Ø« - Ø¬ - Ø­ - Ø® - Ø¯ - Ø° - Ø± - Ø² - Ø³ - Ø´ - Øµ - Ø¶ - Ø· - Ø¸ - Ø¹ - Øº - Ù - Ù‚ - Ùƒ - Ù„ - Ù… - Ù† - Ù‡Ù€ - Ùˆ - ÙŠ

## Ø£Ø´ÙƒØ§Ù„ Ø§Ù„Ø­Ø±ÙˆÙ:
- ÙÙŠ Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ÙƒÙ„Ù…Ø©
- ÙÙŠ ÙˆØ³Ø· Ø§Ù„ÙƒÙ„Ù…Ø©  
- ÙÙŠ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙƒÙ„Ù…Ø©
- Ù…Ù†ÙØµÙ„Ø©
        `,
        subjectId: arabicSubject.id,
        levelId: level.id,
        authorId: teacher.id,
        type: 'public',
        status: 'approved',
      },
    });

    console.log(`âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ${3} Ø¯Ø±ÙˆØ³`);

    console.log('ğŸ“ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†...');

    // ØªÙ…Ø§Ø±ÙŠÙ† Ù„Ù„Ø¯Ø±Ø³ 1 (Ø§Ù„Ø¬Ù…Ø¹)
    await prisma.exercise.create({
      data: {
        lessonId: lesson1.id,
        question: 'Ø§Ø­Ø³Ø¨ Ù†Ø§ØªØ¬: 5 + 3 = ØŸ',
        modelAnswer: '8',
        displayOrder: 1,
      },
    });

    await prisma.exercise.create({
      data: {
        lessonId: lesson1.id,
        question: 'Ø§Ø­Ø³Ø¨ Ù†Ø§ØªØ¬: 12 + 7 = ØŸ',
        modelAnswer: '19',
        displayOrder: 2,
      },
    });

    await prisma.exercise.create({
      data: {
        lessonId: lesson1.id,
        question: 'Ù…Ø§ Ù‡Ùˆ Ù…Ø¬Ù…ÙˆØ¹: 25 + 15 = ØŸ',
        modelAnswer: '40',
        displayOrder: 3,
      },
    });

    // ØªÙ…Ø§Ø±ÙŠÙ† Ù„Ù„Ø¯Ø±Ø³ 2 (Ø§Ù„Ø·Ø±Ø­)
    await prisma.exercise.create({
      data: {
        lessonId: lesson2.id,
        question: 'Ø§Ø­Ø³Ø¨ Ù†Ø§ØªØ¬: 10 - 4 = ØŸ',
        modelAnswer: '6',
        displayOrder: 1,
      },
    });

    await prisma.exercise.create({
      data: {
        lessonId: lesson2.id,
        question: 'Ø§Ø­Ø³Ø¨ Ù†Ø§ØªØ¬: 20 - 8 = ØŸ',
        modelAnswer: '12',
        displayOrder: 2,
      },
    });

    // ØªÙ…Ø§Ø±ÙŠÙ† Ù„Ù„Ø¯Ø±Ø³ 3 (Ø§Ù„Ø­Ø±ÙˆÙ)
    await prisma.exercise.create({
      data: {
        lessonId: lesson3.id,
        question: 'ÙƒÙ… Ø¹Ø¯Ø¯ Ø§Ù„Ø­Ø±ÙˆÙ ÙÙŠ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©ØŸ',
        modelAnswer: '28 Ø­Ø±ÙØ§Ù‹',
        displayOrder: 1,
      },
    });

    await prisma.exercise.create({
      data: {
        lessonId: lesson3.id,
        question: 'Ø§ÙƒØªØ¨ Ø£ÙˆÙ„ Ø®Ù…Ø³Ø© Ø­Ø±ÙˆÙ Ù…Ù† Ø§Ù„Ø£Ø¨Ø¬Ø¯ÙŠØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
        modelAnswer: 'Ø£ - Ø¨ - Øª - Ø« - Ø¬',
        displayOrder: 2,
      },
    });

    console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ 7 ØªÙ…Ø§Ø±ÙŠÙ†');

    console.log('\nâœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!');
    console.log(`\nğŸ“Š Ø§Ù„Ù…Ù„Ø®Øµ:`);
    console.log(`   - 3 Ø¯Ø±ÙˆØ³ (2 Ø±ÙŠØ§Ø¶ÙŠØ§Øª + 1 Ù„ØºØ© Ø¹Ø±Ø¨ÙŠØ©)`);
    console.log(`   - 7 ØªÙ…Ø§Ø±ÙŠÙ†`);
    console.log(`   - Ø§Ù„Ù…Ø¹Ù„Ù…: ${teacher.firstName} ${teacher.lastName}`);

  } catch (error) {
    console.error('âŒ Ø®Ø·Ø£:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });


// ==========================================
// FILE: prisma/clear-data.ts
// ==========================================

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸ—‘ï¸  Ø¨Ø¯Ø¡ Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„...');

  try {
    // Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„ØµØ­ÙŠØ­ (Ù…Ù† Ø§Ù„Ø£Ø³ÙÙ„ Ù„Ù„Ø£Ø¹Ù„Ù‰ ÙÙŠ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª)
    
    console.log('Ø­Ø°Ù Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª...');
    await prisma.submission.deleteMany({});
    
    console.log('Ø­Ø°Ù Ø§Ù„ØªÙ…Ø§Ø±ÙŠÙ†...');
    await prisma.exercise.deleteMany({});
    
    console.log('Ø­Ø°Ù Ø§Ù„Ø¯Ø±ÙˆØ³...');
    await prisma.lesson.deleteMany({});
    
    console.log('Ø­Ø°Ù Ø§Ù„Ø±Ø³Ø§Ø¦Ù„...');
    await prisma.message.deleteMany({});
    
    console.log('Ø­Ø°Ù Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ù…Ø¹Ù„Ù…ÙŠÙ† ÙˆØ§Ù„Ø·Ù„Ø§Ø¨...');
    await prisma.teacherStudentLink.deleteMany({});
    
    console.log('Ø­Ø°Ù Ø§Ù„Ø¹Ù„Ø§Ù‚Ø§Øª Ø¨ÙŠÙ† Ø§Ù„Ø£ÙˆÙ„ÙŠØ§Ø¡ ÙˆØ§Ù„Ø£Ø¨Ù†Ø§Ø¡...');
    await prisma.parentChildLink.deleteMany({});
    
    console.log('Ø­Ø°Ù Ø§Ù„Ù…ÙˆØ§Ø¯...');
    await prisma.subject.deleteMany({});
    
    console.log('Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª...');
    await prisma.level.deleteMany({});
    
    console.log('Ø­Ø°Ù Ø§Ù„Ù…Ø±Ø§Ø­Ù„...');
    await prisma.stage.deleteMany({});
    
    console.log('Ø­Ø°Ù ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...');
    await prisma.userDetails.deleteMany({});
    
    console.log('âœ… ØªÙ… Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­ (ØªÙ… Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø¬Ø¯ÙˆÙ„ Users ÙÙ‚Ø·)');
  } catch (error) {
    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });


// ==========================================
// FILE: prisma/schema.prisma
// ==========================================

// SmartEdu Platform - Prisma Schema
// Database: MySQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ============================================
// Authentication & User Management
// ============================================

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// Core Tables
// ============================================

model Role {
  id    Int    @id @default(autoincrement())
  name  String @unique @db.VarChar(50)
  users User[]

  @@map("roles")
}

model User {
  id            String    @id @default(cuid())
  firstName     String    @map("first_name") @db.VarChar(100)
  lastName      String    @map("last_name") @db.VarChar(100)
  email         String    @unique @db.VarChar(255)
  emailVerified DateTime? @map("email_verified")
  image         String?   @map("avatar_url") @db.VarChar(255)
  password      String?   @map("password_hash") @db.VarChar(255)
  roleId        Int       @map("role_id")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  role        Role         @relation(fields: [roleId], references: [id])
  userDetails UserDetails?
  accounts    Account[]
  sessions    Session[]

  authoredLessons     Lesson[]
  authoredSubmissions Submission[] @relation("StudentSubmissions")
  sentMessages        Message[]    @relation("SentMessages")
  receivedMessages    Message[]    @relation("ReceivedMessages")
  notifications       Notification[] @relation("UserNotifications")
  logs                Log[]        @relation("UserLogs")
  backups             Backup[]     @relation("UserBackups")

  studentPromotions StudentPromotion[] @relation("StudentPromotions")
  parentPromotions  StudentPromotion[] @relation("ParentPromotions")

  parentLinks ParentChildLink[] @relation("ParentUser")
  childLinks  ParentChildLink[] @relation("ChildUser")

  teacherLinks TeacherStudentLink[] @relation("TeacherUser")
  studentLinks TeacherStudentLink[] @relation("StudentUser")

  @@map("users")
}

model UserDetails {
  userId         String  @id @map("user_id")
  stageId        Int?    @map("stage_id")
  levelId        Int?    @map("level_id")
  subjectId      Int?    @map("subject_id")
  teacherCode    String? @unique @map("teacher_code") @db.VarChar(20)
  parentCode     String? @unique @map("parent_code") @db.VarChar(20)
  aiEvalMode     String  @default("auto") @map("ai_eval_mode") @db.VarChar(10)
  allowMessaging Boolean @default(false) @map("allow_messaging")

  // Google Drive Integration - Main folder for the teacher within their subject
  teacherDriveFolderId String? @unique @map("teacher_drive_folder_id") @db.VarChar(255)

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  stage   Stage?   @relation(fields: [stageId], references: [id])
  level   Level?   @relation(fields: [levelId], references: [id])
  subject Subject? @relation(fields: [subjectId], references: [id])

  @@map("user_details")
}

// ============================================
// Content Structure Tables
// ============================================

model Stage {
  id           Int    @id @default(autoincrement())
  name         String @db.VarChar(100)
  displayOrder Int    @map("display_order")
  driveFolderId String? @unique @map("drive_folder_id") @db.VarChar(255)

  levels      Level[]
  subjects    Subject[]
  userDetails UserDetails[]

  @@map("stages")
}

model Level {
  id           Int    @id @default(autoincrement())
  name         String @db.VarChar(100)
  stageId      Int    @map("stage_id")
  displayOrder Int    @map("display_order")
  driveFolderId String? @unique @map("drive_folder_id") @db.VarChar(255)

  stage       Stage         @relation(fields: [stageId], references: [id], onDelete: Cascade)
  subjects    Subject[]
  lessons     Lesson[]
  userDetails UserDetails[]

  promotionsFrom StudentPromotion[] @relation("PromotionFromLevel")
  promotionsTo   StudentPromotion[] @relation("PromotionToLevel")

  @@map("levels")
}

model Subject {
  id          Int     @id @default(autoincrement())
  name        String  @db.VarChar(100)
  description String? @db.Text
  stageId     Int?    @map("stage_id")
  driveFolderId String? @unique @map("drive_folder_id") @db.VarChar(255)

  levels      Level[]
  stage       Stage?        @relation(fields: [stageId], references: [id])
  lessons     Lesson[]
  userDetails UserDetails[]

  @@map("subjects")
}

// ============================================
// Content Tables
// ============================================

model Lesson {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  content   String?  @db.Text
  videoUrl  String?  @map("video_url") @db.VarChar(512)
  imageUrl  String?  @map("image_url") @db.VarChar(512)
  pdfUrl    String?  @map("pdf_url") @db.VarChar(512)
  authorId  String?  @map("author_id")
  subjectId Int?     @map("subject_id")
  levelId   Int?     @map("level_id")
  type      String   @default("private") @db.VarChar(10)
  status    String   @default("pending") @db.VarChar(20)
  isLocked  Boolean  @default(false) @map("is_locked")
  createdAt DateTime @default(now()) @map("created_at")

  // Ø­Ù‚ÙˆÙ„ Ù…Ø¶Ø§ÙØ© Ù„Ø¯Ø¹Ù… Ø®Ø§ØµÙŠØ© Ø§Ù„Ø±ÙØ¹ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± (Direct Upload)
  fileUrl     String?  @map("file_url") @db.VarChar(512)
  driveFileId String?  @map("drive_file_id") @db.VarChar(255)
  stageName   String?  @map("stage_name") @db.VarChar(100)
  subjectName String?  @map("subject_name") @db.VarChar(100)
  teacherName String?  @map("teacher_name") @db.VarChar(100)

  // Google Drive Integration
  driveFolderId         String? @map("drive_folder_id") @db.VarChar(255) // Folder inside the teacher's "Lessons" directory
  lessonFileIds         Json    @default("[]") @map("lesson_file_ids") // Array of Google Drive File IDs

  author    User?      @relation(fields: [authorId], references: [id])
  subject   Subject?   @relation(fields: [subjectId], references: [id])
  level     Level?     @relation(fields: [levelId], references: [id])
  exercises Exercise[]

  @@map("lessons")
}

model Exercise {
  id                  Int      @id @default(autoincrement())
  lessonId            Int      @map("lesson_id")
  type                String   @default("main") @db.VarChar(30) // 'main', 'support_with_results', 'support_only'
  
  // Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªÙ…Ø±ÙŠÙ†
  question            String?  @db.Text // Ù†Øµ Ø¨Ø³ÙŠØ· (Ù‚Ø¯ÙŠÙ… - Ù„Ù„ØªÙˆØ§ÙÙ‚)
  questionRichContent String?  @map("question_rich_content") @db.Text // Ù…Ø­ØªÙˆÙ‰ TipTap
  
  // Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ (Ù„Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ)
  modelAnswer         String?  @map("model_answer") @db.Text
  
  // Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© (Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ø¯Ø¹Ù… + Ù†ØªØ§Ø¦Ø¬)
  expectedResults     Json?    @map("expected_results") // [{question: "1", result: "45", tolerance: 0.01}, ...]
  
  // Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
  maxScore            Decimal? @map("max_score") @db.Decimal(5, 2) @default(20)
  allowRetry          Boolean  @map("allow_retry") @default(true)
  maxAttempts         Int?     @map("max_attempts") @default(3)
  displayOrder        Int       @map("display_order")
  
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime? @map("updated_at")

  // Google Drive Integration
  driveFolderId       String? @unique @map("drive_folder_id") @db.VarChar(255)
  exerciseFileIds     Json    @default("[]") @map("exercise_file_ids")
  questionFileIds     Json    @default("[]") @map("question_file_ids") // Array of Google Drive File IDs
  modelAnswerFileIds  Json    @default("[]") @map("model_answer_file_ids") // Array of Google Drive File IDs for the model answer

  lesson      Lesson       @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  submissions Submission[]

  @@map("exercises")
}

// ============================================
// User Activity Tables
// ============================================

model Submission {
  id                 Int       @id @default(autoincrement())
  studentId          String    @map("student_id")
  exerciseId         Int       @map("exercise_id")
  
  // Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØªÙ„Ù…ÙŠØ°
  answerText         String?   @map("answer_text") @db.Text
  answerRichContent  String?   @map("answer_rich_content") @db.Text // Ù…Ø­ØªÙˆÙ‰ TipTap
  
  // Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªÙ„Ù…ÙŠØ° (Ù„ØªÙ…Ø§Ø±ÙŠÙ† Ø§Ù„Ø¯Ø¹Ù… + Ù†ØªØ§Ø¦Ø¬)
  studentResults     Json?     @map("student_results") // [{question: "1", answer: "45"}, ...]
  comparisonResults  Json?     @map("comparison_results") // [{question: "1", correct: true}, ...]
  correctCount       Int?      @map("correct_count") // Ø¹Ø¯Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„ØµØ­ÙŠØ­Ø©
  totalCount         Int?      @map("total_count") // Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
  
  // Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª ÙˆØ§Ù„Ù†Ù‚Ø§Ø·
  attemptNumber      Int       @default(1) @map("attempt_number")
  bestScore          Decimal?  @map("best_score") @db.Decimal(5, 2) // Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©
  
  // ØªØµØ­ÙŠØ­ AI (Ù„Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ)
  aiFeedback         String?   @map("ai_feedback") @db.Text
  aiScore            Decimal?  @map("ai_score") @db.Decimal(5, 2)
  
  // Ø§Ù„ØªØµØ­ÙŠØ­ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
  finalScore         Decimal?  @map("final_score") @db.Decimal(5, 2)
  teacherNotes       String?   @map("teacher_notes") @db.Text
  status             String    @default("pending") @db.VarChar(20)
  
  submittedAt        DateTime  @default(now()) @map("submitted_at")
  gradedAt           DateTime? @map("graded_at")

  // Google Drive Integration
  submissionFileIds Json @default("[]") @map("submission_file_ids") // Array of Google Drive File IDs

  student  User     @relation("StudentSubmissions", fields: [studentId], references: [id])
  exercise Exercise @relation(fields: [exerciseId], references: [id])

  @@index([studentId, exerciseId])
  @@map("submissions")
}

// ============================================
// Relationship Tables
// ============================================

model ParentChildLink {
  parentId String @map("parent_id")
  childId  String @map("child_id")

  parent User @relation("ParentUser", fields: [parentId], references: [id], onDelete: Cascade)
  child  User @relation("ChildUser", fields: [childId], references: [id], onDelete: Cascade)

  @@id([parentId, childId])
  @@map("parent_child_links")
}

model TeacherStudentLink {
  teacherId String @map("teacher_id")
  studentId String @map("student_id")

  teacher User @relation("TeacherUser", fields: [teacherId], references: [id], onDelete: Cascade)
  student User @relation("StudentUser", fields: [studentId], references: [id], onDelete: Cascade)

  @@id([teacherId, studentId])
  @@map("teacher_student_links")
}

// ============================================
// Communication Tables
// ============================================

model Message {
  id          Int      @id @default(autoincrement())
  senderId    String   @map("sender_id")
  recipientId String   @map("recipient_id")
  subject     String   @db.VarChar(255)
  content     String   @db.Text
  isRead      Boolean  @default(false) @map("is_read")
  createdAt   DateTime @default(now()) @map("created_at")

  sender    User @relation("SentMessages", fields: [senderId], references: [id])
  recipient User @relation("ReceivedMessages", fields: [recipientId], references: [id])

  @@map("messages")
}

model Notification {
  id        Int      @id @default(autoincrement())
  userId    String   @map("user_id")
  title     String   @db.VarChar(255)
  message   String   @db.Text
  type      String   @db.VarChar(50) // submission_graded, message_received, etc
  relatedId Int?     @map("related_id") // ID of related submission/message
  isRead    Boolean  @default(false) @map("is_read")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@map("notifications")
}

// ============================================
// System Management Tables
// ============================================

model Log {
  id         String   @id @default(cuid())
  level      String   @db.VarChar(20)  // INFO, WARNING, ERROR, SUCCESS, DEBUG
  category   String   @db.VarChar(50)  // AUTH, USER, LESSON, EXERCISE, etc
  action     String   @db.VarChar(255) // USER_LOGIN, EXERCISE_CREATED, etc
  userId     String?  @map("user_id")
  targetId   String?  @map("target_id") // ID of affected resource
  details    String?  @db.Text         // JSON string with additional data
  ipAddress  String?  @db.VarChar(50)  @map("ip_address")
  userAgent  String?  @db.Text         @map("user_agent")
  timestamp  DateTime @default(now())

  user User? @relation("UserLogs", fields: [userId], references: [id], onDelete: SetNull)

  @@index([level])
  @@index([category])
  @@index([userId])
  @@index([timestamp])
  @@map("logs")
}

model Backup {
  id          String   @id @default(cuid())
  filename    String   @db.VarChar(255)
  filepath    String   @db.VarChar(500)
  size        BigInt   // File size in bytes
  type        String   @db.VarChar(20)  // FULL, INCREMENTAL, DIFFERENTIAL
  status      String   @db.VarChar(20)  // PENDING, COMPLETED, FAILED
  createdById String   @map("created_by_id")
  createdAt   DateTime @default(now())  @map("created_at")

  createdBy User @relation("UserBackups", fields: [createdById], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@map("backups")
}

// ============================================
// Academic Year & Student Promotion
// ============================================

model AcademicYear {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(100)  // "2024-2025"
  startDate DateTime @map("start_date") // September 1st
  endDate   DateTime @map("end_date")   // June 30th
  isCurrent Boolean  @default(false) @map("is_current")
  status    String   @default("active") @db.VarChar(20) // active, ended, archived
  createdAt DateTime @default(now()) @map("created_at")

  promotions StudentPromotion[]

  @@index([isCurrent])
  @@index([status])
  @@map("academic_years")
}

model StudentPromotion {
  id             String   @id @default(cuid())
  academicYearId String   @map("academic_year_id")
  studentId      String   @map("student_id")
  parentId       String   @map("parent_id")
  fromLevelId    Int      @map("from_level_id")
  toLevelId      Int?     @map("to_level_id")
  status         String   @default("pending") @db.VarChar(20) // pending, approved, rejected, completed
  parentResponse String?  @db.VarChar(10) // yes, no
  messageId      Int?     @map("message_id") // Link to parent message
  notifiedAt     DateTime? @map("notified_at")
  respondedAt    DateTime? @map("responded_at")
  promotedAt     DateTime? @map("promoted_at")
  createdAt      DateTime @default(now()) @map("created_at")

  academicYear AcademicYear @relation(fields: [academicYearId], references: [id], onDelete: Cascade)
  student      User         @relation("StudentPromotions", fields: [studentId], references: [id], onDelete: Cascade)
  parent       User         @relation("ParentPromotions", fields: [parentId], references: [id], onDelete: Cascade)
  fromLevel    Level        @relation("PromotionFromLevel", fields: [fromLevelId], references: [id])
  toLevel      Level?       @relation("PromotionToLevel", fields: [toLevelId], references: [id])

  @@unique([academicYearId, studentId])
  @@index([status])
  @@index([parentResponse])
  @@map("student_promotions")
}


// ==========================================
// FILE: prisma/create-drive-folders.ts
// ==========================================

import { PrismaClient, Stage, Subject, User } from '@prisma/client';
import { GoogleDriveService, getRootFolderId } from '../src/lib/google-drive';

const prisma = new PrismaClient();
const BATCH_SIZE = 50; // Process 50 records at a time to conserve memory

const log = (message: string) => console.log(`[${new Date().toISOString()}] ${message}`);
const logError = (message: string, error?: any) => {
  console.error(`[${new Date().toISOString()}] ${message}`);
  if (error) {
    console.error(error);
  }
};

/**
 * Creates a unique folder name for a user, handling potential duplicates.
 * Example: "John Doe", "John Doe 1", "John Doe 2"
 * @param user The user object.
 * @param parentFolderId The ID of the parent folder in Google Drive.
 * @returns A unique folder name.
 */
async function getUniqueTeacherFolderName(user: User, parentFolderId: string): Promise<string> {
    const baseName = `${user.firstName} ${user.lastName}`;
    let folderName = baseName;
    let counter = 1;
    while (await GoogleDriveService.findFolder(folderName, parentFolderId)) {
        folderName = `${baseName} ${counter}`;
        counter++;
    }
    return folderName;
}

async function main() {
  log('ğŸš€ Starting Google Drive folder creation script (Safe Batch Mode)...');

  try {
    const rootFolderId = getRootFolderId();
    log(`âœ… Root Google Drive folder ID is: ${rootFolderId}`);

    // 1. Synchronize Stages in Batches
    log('\n--- 1. Synchronizing Stages ---');
    let stagesProcessed = 0;
    while (true) {
      const stagesToSync = await prisma.stage.findMany({
        where: { driveFolderId: null },
        take: BATCH_SIZE,
      });

      if (stagesToSync.length === 0) {
        break; // No more stages to sync
      }

      log(`Found ${stagesToSync.length} stages to sync in this batch...`);
      for (const stage of stagesToSync) {
        log(`Creating folder for Stage: "${stage.name}"...`);
        const folderId = await GoogleDriveService.getOrCreateFolder(stage.name, rootFolderId);
        await prisma.stage.update({
          where: { id: stage.id },
          data: { driveFolderId: folderId },
        });
        log(`   âœ… Synced Stage "${stage.name}" -> Folder ID: ${folderId}`);
        stagesProcessed++;
      }
    }
    log(stagesProcessed > 0 ? `Total stages synchronized: ${stagesProcessed}` : 'All stages were already synchronized.');

    // 2. Synchronize Subjects in Batches
    log('\n--- 2. Synchronizing Subjects ---');
    let subjectsProcessed = 0;
    while (true) {
        const subjectsToSync = await prisma.subject.findMany({
            where: {
                driveFolderId: null,
                stage: {
                    driveFolderId: {
                        not: null,
                    },
                },
            },
            include: { stage: true },
            take: BATCH_SIZE,
        });

        if (subjectsToSync.length === 0) {
            break;
        }

        log(`Found ${subjectsToSync.length} subjects to sync in this batch...`);
        for (const subject of subjectsToSync) {
            if (subject.stage?.driveFolderId) {
                log(`Creating folder for Subject: "${subject.name}" in Stage: "${subject.stage.name}"...`);
                const folderId = await GoogleDriveService.getOrCreateFolder(subject.name, subject.stage.driveFolderId);
                await prisma.subject.update({
                    where: { id: subject.id },
                    data: { driveFolderId: folderId },
                });
                log(`   âœ… Synced Subject "${subject.name}" -> Folder ID: ${folderId}`);
                subjectsProcessed++;
            }
        }
    }
    log(subjectsProcessed > 0 ? `Total subjects synchronized: ${subjectsProcessed}`: 'All subjects were already synchronized.');


    // 3. Synchronize Teachers in Batches
    log('\n--- 3. Synchronizing Teachers ---');
    const teachersFolderId = await GoogleDriveService.getOrCreateFolder('Teachers', rootFolderId);
    log(`âœ… "Teachers" main folder ID: ${teachersFolderId}`);

    let teachersProcessed = 0;
    while(true) {
        const teachersToSync = await prisma.user.findMany({
            where: {
                role: { name: 'teacher' },
                userDetails: { teacherDriveFolderId: null },
            },
            take: BATCH_SIZE,
        });

        if (teachersToSync.length === 0) {
            break;
        }

        log(`Found ${teachersToSync.length} teachers to sync in this batch...`);
        for (const teacher of teachersToSync) {
            const folderName = await getUniqueTeacherFolderName(teacher, teachersFolderId);
            log(`Creating folder for Teacher: "${teacher.firstName} ${teacher.lastName}"...`);
            const folderId = await GoogleDriveService.createFolder(folderName, teachersFolderId);
            
            await prisma.user.update({
                where: { id: teacher.id },
                data: {
                    userDetails: {
                        update: {
                            teacherDriveFolderId: folderId,
                        },
                    },
                },
            });
            log(`   âœ… Synced Teacher "${teacher.firstName} ${teacher.lastName}" -> Folder ID: ${folderId}`);
            teachersProcessed++;
        }
    }
    log(teachersProcessed > 0 ? `Total teachers synchronized: ${teachersProcessed}` : 'All teachers were already synchronized.');

  } catch (error) {
    logError('An error occurred during script execution:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
    log('\n--- Script finished ---');
  }
}

main();

// ==========================================
// FILE: prisma/create-admin.ts
// ==========================================

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸŒ± Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ù…Ø¯ÙŠØ± Ø¬Ø¯ÙŠØ¯...');

  // Ø§Ø³ØªØ¨Ø¯Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
  const email = 'your-email@example.com'; // Ø¶Ø¹ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù‡Ù†Ø§
  const password = 'YourSecurePassword123'; // Ø¶Ø¹ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù‡Ù†Ø§
  const firstName = 'Your First Name'; // Ø§Ø³Ù…Ùƒ Ø§Ù„Ø£ÙˆÙ„
  const lastName = 'Your Last Name'; // Ø§Ø³Ù…Ùƒ Ø§Ù„Ø£Ø®ÙŠØ±

  // Hash password
  const hashedPassword = await bcrypt.hash(password, 10);

  // Get director role
  const directeurRole = await prisma.role.findUnique({ where: { name: 'directeur' } });

  if (!directeurRole) {
    throw new Error('Ø¯ÙˆØ± Ø§Ù„Ù…Ø¯ÙŠØ± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª!');
  }

  // Create Director
  const director = await prisma.user.upsert({
    where: { email: email },
    update: {
      password: hashedPassword,
      firstName: firstName,
      lastName: lastName,
    },
    create: {
      email: email,
      firstName: firstName,
      lastName: lastName,
      password: hashedPassword,
      roleId: directeurRole.id,
    },
  });

  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¯ÙŠØ± Ø¨Ù†Ø¬Ø§Ø­!');
  console.log('ğŸ“§ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ:', director.email);
  console.log('ğŸ‘¤ Ø§Ù„Ø§Ø³Ù…:', firstName, lastName);
  console.log('\nğŸ” ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ù„Ù‰: http://localhost:9002/login');
}

main()
  .catch((e) => {
    console.error('âŒ Ø®Ø·Ø£:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ==========================================
// FILE: prisma/seed-content.ts
// ==========================================

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸŒ± Ø¨Ø¯Ø¡ Ù…Ù„Ø¡ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ...');

  try {
    // 1. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø­Ù„
    console.log('ğŸ“ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø­Ù„...');
    const primaryStage = await prisma.stage.create({
      data: {
        name: 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©',
        displayOrder: 1,
      },
    });

    const middleStage = await prisma.stage.create({
      data: {
        name: 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©',
        displayOrder: 2,
      },
    });

    const secondaryStage = await prisma.stage.create({
      data: {
        name: 'Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙˆÙŠØ©',
        displayOrder: 3,
      },
    });

    console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ 3 Ù…Ø±Ø§Ø­Ù„');

    // 2. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª
    console.log('ğŸ“š Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª...');
    const levels = [];
    
    // Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©
    for (let i = 1; i <= 6; i++) {
      const level = await prisma.level.create({
        data: {
          name: `Ø§Ù„ØµÙ ${i} Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ`,
          stageId: primaryStage.id,
          displayOrder: i,
        },
      });
      levels.push(level);
    }

    // Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©
    for (let i = 1; i <= 3; i++) {
      const level = await prisma.level.create({
        data: {
          name: `Ø§Ù„ØµÙ ${i} Ù…ØªÙˆØ³Ø·`,
          stageId: middleStage.id,
          displayOrder: i,
        },
      });
      levels.push(level);
    }

    // Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙˆÙŠØ©
    for (let i = 1; i <= 3; i++) {
      const level = await prisma.level.create({
        data: {
          name: `Ø§Ù„ØµÙ ${i} Ø«Ø§Ù†ÙˆÙŠ`,
          stageId: secondaryStage.id,
          displayOrder: i,
        },
      });
      levels.push(level);
    }

    console.log(`âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ${levels.length} Ù…Ø³ØªÙˆÙ‰`);

    // 3. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙˆØ§Ø¯
    console.log('ğŸ“– Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙˆØ§Ø¯...');
    const subjects = [
      { name: 'Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª', stageId: primaryStage.id },
      { name: 'Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', stageId: primaryStage.id },
      { name: 'Ø§Ù„Ø¹Ù„ÙˆÙ…', stageId: primaryStage.id },
      { name: 'Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¡', stageId: secondaryStage.id },
      { name: 'Ø§Ù„ÙƒÙŠÙ…ÙŠØ§Ø¡', stageId: secondaryStage.id },
      { name: 'Ø§Ù„Ø£Ø­ÙŠØ§Ø¡', stageId: secondaryStage.id },
    ];

    for (const subject of subjects) {
      await prisma.subject.create({
        data: subject,
      });
    }

    console.log(`âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ${subjects.length} Ù…Ø§Ø¯Ø©`);

    console.log('\nâœ… ØªÙ… Ù…Ù„Ø¡ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù„ÙŠÙ…ÙŠ Ø¨Ù†Ø¬Ø§Ø­!');
  } catch (error) {
    console.error('âŒ Ø®Ø·Ø£:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  });


// ==========================================
// FILE: prisma/seed.ts
// ==========================================

import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  console.log('ğŸŒ± Ø¨Ø¯Ø¡ Ù…Ù„Ø¡ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...');

  // 1. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø¯ÙˆØ§Ø±
  console.log('ğŸ“ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø¯ÙˆØ§Ø±...');
  const roles = await Promise.all([
    prisma.role.upsert({
      where: { name: 'directeur' },
      update: {},
      create: { name: 'directeur' },
    }),
    prisma.role.upsert({
      where: { name: 'supervisor_general' },
      update: {},
      create: { name: 'supervisor_general' },
    }),
    prisma.role.upsert({
      where: { name: 'supervisor_specific' },
      update: {},
      create: { name: 'supervisor_specific' },
    }),
    prisma.role.upsert({
      where: { name: 'teacher' },
      update: {},
      create: { name: 'teacher' },
    }),
    prisma.role.upsert({
      where: { name: 'student' },
      update: {},
      create: { name: 'student' },
    }),
    prisma.role.upsert({
      where: { name: 'parent' },
      update: {},
      create: { name: 'parent' },
    }),
  ]);

  const roleMap = {
    directeur: roles[0].id,
    supervisor_general: roles[1].id,
    supervisor_specific: roles[2].id,
    teacher: roles[3].id,
    student: roles[4].id,
    parent: roles[5].id,
  };

  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø¨Ù†Ø¬Ø§Ø­');

  // 2. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©
  console.log('ğŸ“š Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©...');
  const stage1 = await prisma.stage.upsert({
    where: { id: 1 },
    update: {},
    create: {
      id: 1,
      name: 'Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ… Ø§Ù„Ø¥Ø¨ØªØ¯Ø§Ø¦ÙŠ',
      displayOrder: 1,
    },
  });

  const stage2 = await prisma.stage.upsert({
    where: { id: 2 },
    update: {},
    create: {
      id: 2,
      name: 'Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ… Ø§Ù„Ù…ØªÙˆØ³Ø·',
      displayOrder: 2,
    },
  });

  const stage3 = await prisma.stage.upsert({
    where: { id: 3 },
    update: {},
    create: {
      id: 3,
      name: 'Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ… Ø§Ù„Ø«Ø§Ù†ÙˆÙŠ',
      displayOrder: 3,
    },
  });

  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø±Ø§Ø­Ù„ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­');

  // 3. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª
  console.log('ğŸ“Š Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª...');
  await prisma.level.createMany({
    data: [
      { id: 1, name: 'Ø§Ù„ØµÙ Ø§Ù„Ø£ÙˆÙ„ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ', stageId: stage1.id, displayOrder: 1 },
      { id: 2, name: 'Ø§Ù„ØµÙ Ø§Ù„Ø«Ø§Ù†ÙŠ Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠ', stageId: stage1.id, displayOrder: 2 },
      { id: 3, name: 'Ø£ÙˆÙ„Ù‰ Ù…ØªÙˆØ³Ø·', stageId: stage2.id, displayOrder: 1 },
      { id: 4, name: 'Ø«Ø§Ù†ÙŠØ© Ù…ØªÙˆØ³Ø·', stageId: stage2.id, displayOrder: 2 },
      { id: 5, name: 'Ø«Ø§Ù„Ø«Ø© Ù…ØªÙˆØ³Ø·', stageId: stage2.id, displayOrder: 3 },
      { id: 6, name: 'Ø±Ø§Ø¨Ø¹Ø© Ù…ØªÙˆØ³Ø·', stageId: stage2.id, displayOrder: 4 },
    ],
    skipDuplicates: true,
  });

  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø¨Ù†Ø¬Ø§Ø­');

  // 4. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙˆØ§Ø¯
  console.log('ğŸ“– Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙˆØ§Ø¯...');
  const subjects = [
    { id: 1, name: 'Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª', description: 'Ù…Ø§Ø¯Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©', stageId: stage1.id, levelIds: [1] },
    { id: 2, name: 'Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', description: 'Ù…Ø§Ø¯Ø© Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©', stageId: stage1.id, levelIds: [1] },
    { id: 3, name: 'Ø§Ù„Ø¹Ù„ÙˆÙ…', description: 'Ù…Ø§Ø¯Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø§Ø¨ØªØ¯Ø§Ø¦ÙŠØ©', stageId: stage1.id, levelIds: [1] },
    { id: 4, name: 'Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª', description: 'Ù…Ø§Ø¯Ø© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©', stageId: stage2.id, levelIds: [] },
    { id: 5, name: 'Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', description: 'Ù…Ø§Ø¯Ø© Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©', stageId: stage2.id, levelIds: [] },
    { id: 6, name: 'Ø§Ù„Ø¹Ù„ÙˆÙ… Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ©', description: 'Ù…Ø§Ø¯Ø© Ø§Ù„Ø¹Ù„ÙˆÙ… Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ© Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©', stageId: stage2.id, levelIds: [] },
    { id: 7, name: 'Ø§Ù„Ù„ØºØ© Ø§Ù„ÙØ±Ù†Ø³ÙŠØ©', description: 'Ù…Ø§Ø¯Ø© Ø§Ù„Ù„ØºØ© Ø§Ù„ÙØ±Ù†Ø³ÙŠØ© Ù„Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©', stageId: stage2.id, levelIds: [] },
  ];

  for (const subject of subjects) {
    await prisma.subject.upsert({
      where: { id: subject.id },
      update: {},
      create: {
        id: subject.id,
        name: subject.name,
        description: subject.description,
        stageId: subject.stageId,
        levels: subject.levelIds.length > 0 ? {
          connect: subject.levelIds.map((id) => ({ id })),
        } : undefined,
      },
    });
  }

  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ÙˆØ§Ø¯ Ø¨Ù†Ø¬Ø§Ø­');

  // 5. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  console.log('ğŸ‘¥ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...');
  const hashedPassword = await bcrypt.hash('password123', 10);
  const directorPassword = await bcrypt.hash('Lakhdar14013@Djedid', 10);

  // Ø§Ù„Ù…Ø¯ÙŠØ±
  const director = await prisma.user.upsert({
    where: { email: 'Ladj.director@smartedu.com' },
    update: {},
    create: {
      firstName: 'Ù„Ø®Ø¶Ø±',
      lastName: 'Ø¬Ø¯ÙŠØ¯',
      email: 'Ladj.director@smartedu.com',
      password: directorPassword,
      image: 'https://placehold.co/200x200/3F51B5/FFFFFF?text=AK',
      roleId: roleMap.directeur,
    },
  });

  // Ù…Ø´Ø±Ù Ø§Ù„Ù…Ø§Ø¯Ø©
  const supervisor = await prisma.user.upsert({
    where: { email: 'Nassir.supervisor@smartedu.com' },
    update: {},
    create: {
      firstName: 'Ù†Ø§ØµØ±',
      lastName: 'Ø¹Ù†ØªØ±ÙŠ',
      email: 'Nassir.supervisor@smartedu.com',
      password: hashedPassword,
      image: 'https://placehold.co/200x200/7E57C2/FFFFFF?text=YF',
      roleId: roleMap.supervisor_specific,
      userDetails: {
        create: {
          subjectId: 1,
          teacherCode: 'T-SUPER-01',
        },
      },
    },
  });

  // Ù…Ø¹Ù„Ù…
  const teacher = await prisma.user.upsert({
    where: { email: 'ahmed.teacher@smartedu.com' },
    update: {},
    create: {
      firstName: 'Ahmed',
      lastName: 'Mahmoud',
      email: 'ahmed.teacher@smartedu.com',
      password: hashedPassword,
      image: 'https://placehold.co/200x200/2196F3/FFFFFF?text=AM',
      roleId: roleMap.teacher,
      userDetails: {
        create: {
          subjectId: 1,
          teacherCode: 'T9876',
        },
      },
    },
  });

  // ÙˆÙ„ÙŠ Ø£Ù…Ø±
  const parent = await prisma.user.upsert({
    where: { email: 'khaled.parent@smartedu.com' },
    update: {},
    create: {
      firstName: 'Ø®Ø§Ù„Ø¯',
      lastName: 'Ø¬Ø¯ÙŠØ¯',
      email: 'khaled.parent@smartedu.com',
      password: hashedPassword,
      image: 'https://placehold.co/200x200/FF9800/FFFFFF?text=KG',
      roleId: roleMap.parent,
      userDetails: {
        create: {
          parentCode: 'P54321',
        },
      },
    },
  });

  // Ø·Ø§Ù„Ø¨ 1
  const student1 = await prisma.user.upsert({
    where: { email: 'aya.student@smartedu.com' },
    update: {},
    create: {
      firstName: 'Aya',
      lastName: 'Djedid',
      email: 'aya.student@smartedu.com',
      password: hashedPassword,
      image: 'https://placehold.co/200x200/4CAF50/FFFFFF?text=FG',
      roleId: roleMap.student,
      userDetails: {
        create: {
          levelId: 1,
          aiEvalMode: 'auto',
        },
      },
    },
  });

  // Ø·Ø§Ù„Ø¨ 2
  const student2 = await prisma.user.upsert({
    where: { email: 'omar.student@smartedu.com' },
    update: {},
    create: {
      firstName: 'Omar',
      lastName: 'Hassan',
      email: 'omar.student@smartedu.com',
      password: hashedPassword,
      image: 'https://placehold.co/200x200/F44336/FFFFFF?text=OG',
      roleId: roleMap.student,
      userDetails: {
        create: {
          levelId: 3,
          aiEvalMode: 'auto',
        },
      },
    },
  });

  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø¨Ù†Ø¬Ø§Ø­');

  // 6. Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
  console.log('ğŸ”— Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·...');

  // Ø±Ø¨Ø· Ø§Ù„Ù…Ø¹Ù„Ù… Ø¨Ø§Ù„Ø·Ù„Ø§Ø¨
  await prisma.teacherStudentLink.createMany({
    data: [
      { teacherId: teacher.id, studentId: student1.id },
      { teacherId: supervisor.id, studentId: student2.id },
    ],
    skipDuplicates: true,
  });

  // Ø±Ø¨Ø· ÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø± Ø¨Ø§Ù„Ø·Ù„Ø§Ø¨
  await prisma.parentChildLink.createMany({
    data: [
      { parentId: parent.id, childId: student1.id },
      { parentId: parent.id, childId: student2.id },
    ],
    skipDuplicates: true,
  });

  console.log('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­');

  console.log('\nâœ¨ ØªÙ… Ù…Ù„Ø¡ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­!');
  console.log('\nğŸ“‹ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ©:');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log('Ø§Ù„Ù…Ø¯ÙŠØ±:');
  console.log('  Ø§Ù„Ø¨Ø±ÙŠØ¯: Ladj.director@smartedu.com');
  console.log('  ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±: Lakhdar14013@Djedid');
  console.log('\nØ§Ù„Ù…Ø¹Ù„Ù…:');
  console.log('  Ø§Ù„Ø¨Ø±ÙŠØ¯: ahmed.teacher@smartedu.com');
  console.log('  ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±: password123');
  console.log('\nØ§Ù„Ø·Ø§Ù„Ø¨:');
  console.log('  Ø§Ù„Ø¨Ø±ÙŠØ¯: aya.student@smartedu.com');
  console.log('  ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±: password123');
  console.log('\nÙˆÙ„ÙŠ Ø§Ù„Ø£Ù…Ø±:');
  console.log('  Ø§Ù„Ø¨Ø±ÙŠØ¯: khaled.parent@smartedu.com');
  console.log('  ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±: password123');
  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');
}

main()
  .catch((e) => {
    console.error('âŒ Ø®Ø·Ø£ ÙÙŠ Ù…Ù„Ø¡ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
